INTRO
=======
react
react-dom

babel - translate next gen javascript to browser compatible javascript


react component is just a function that has to return the code to render to the dom
	JSX - needs babel as the preprocessor that converts JSX to normal javascript code
	JSX - requires one root div!

function Person(props) { // React auto gives me the props parameter - the component properties.
	return (
		<div className="person"> // NOTE: use of className not class! This is JSX thing - class is a reserved word in JS so cant be used.
			<h1>{props.name}</h1>
			<p>Some stuff: {stuff}</p>
		</div>
	);
}
ReactDOM.render(<Person name="John" stuff="Whatever"/>, document.querySelector('#p1')); - render a javascript function as a component to the real dom inside div with id "p1"


Could also do 
	app = (
		<div>
			<Person name="John" stuff="blah"/>
			<Person name="Peter" stuff="blah"/>
		</div>
	);
	ReactDOM.render(app, document.querySelector('#app')); # A single page application

React focusus on the what not the how - focus on what you want to see rather than managing individual UI state and keeping track of it all.



SOME RESOURCES
==============
create-react-app: https://github.com/facebookincubator/create-react-app
Introducing JSX: https://reactjs.org/docs/introducing-jsx.html
Rendering Elements: https://reactjs.org/docs/rendering-elements.html
Components & Props: https://reactjs.org/docs/components-and-props.html
Listenable Events: https://reactjs.org/docs/events.html



SETUP LOCAL REACT PROJECT
=========================

Build a workflow - optimize code, lint, make code cross-browser compatible using babel and jsx etc.
Need - dependency management tool, e.g. npm
       bundler - put all our JS modules into one file - use webpack
       compiler - next-gen JS to older-JS = babel + presets
       dev server to test on
^^^^
There is a react-team supported tool that does all this for us! -- `npm install -g create-react-app` - only using nodeJS for the package manager and the dev server
	Use command create-react-app react-complete-guide --scripts-version 1.1.5
		Creates a folder called `react-complete-guide` in the CWD

CD into `react-complete-guide` and type `npm start` to start the development server. It server watches your files so if you change code it will auto-reload it for you!
	Inside that directory, you can run several commands:
	  npm start
	    Starts the development server.
	
	  npm run build
	    Bundles the app into static files for production.
	
	  npm test
	    Starts the test runner.
	
	  npm run eject
	    Removes this tool and copies build dependencies, configuration files
	    and scripts into the app directory. If you do this, you canâ€™t go back!



	
REACT COMPONENT BASICS
======================
Every component needs a `render()` method - it returns an object that react can use to render content to the HTML DOM.

> Components are the core building block of React apps. Actually, React
> really is just a library for creating components in its core.
> A typical React app therefore could be depicted as a component tree -
> having one root component ("App") and then an potentially infinite amount
> of nested child components.
> Each component needs to return/ render some JSX code - it defines
> which HTML code React should render to the real DOM in the end.


JSX v.s. React
--------------
JSX is a syntactic sugar that needs to be translated into javascript code.

For example "<div></div>" would be translated into React.createElement('div', props-object, child1 [,child2[,...]]), where the children are also created using Reac.createElement(...).

JSX restrictions
1. Cannot use JS reserved keywords
2. Must have ONE root element, normally a DIV.


Creating Basic Components
-------------------------
Directory and file(s) in that directory for each component with same name as componenet, normally using capitalised first letter.
In file
  - import React from 'react.js';
  - const component_name = (...) => { return SOME-REACT-ELMENTS-VIA-JSX; }
  - export default component_name;

In root component file:
  - import Component_name from './Comonent_name/Component_name.js' <- Name must have upper-case character because elements starting lower case are reserved for HTML reserved node names
  - then use <Component_name>...</Componeent_name>

To get JSX code to execute and use the output of a JS function (can only use one-line expressions), wrap the code in curley braces - {}

	Props
	-----
	Allow us to pass attributes (and children) specified in the JSX/HTML code to the JS component so that it can display content dynamically.
	Note the props object passed to the componenet should *NOT* be modified by the component.

	If component is constructed using a function, the function gets one parameter - the props obejct.
		const componenet_name = (props) => { return <div><p>I am {props.age} years old.</p><p>I like in the country {props.country}</p></div>; }
	If componeent is constructed using a class then in the render() method use `this.props.age` for example. The props are passed automatically made available as `this.props` for you.

	To access children, e.g. <Component_name>Some text in the middle</Component_name>, use `props.children`, which is created by react for us. It will contain
		all elements between the opening and closing tags of the component, plain text, or an element tree...

	You can pass METHODS as props so that other componenets can access methods, from say, the main app, for example. This could allow a child componenet
	to change data in the parent component. It is a useful pattern.


	State
	-----
	Only for classes exending `Component` (and see also React hooks for function based components) PRE React 16.8. 
		Function based components can, since React 16.8, use the useState() hook
	Create a class variable named `state`, which should be a JS oject with keys, as you want to define them, mapping to values of interest.
	The variable is SPECIAL because if it changes it will triger React to re-render the DOM with the updated data BUT ONLY IF YOU USE `this.setState()`
	!! NOTE you must use `this.setState()` to TRIGGER RE-RENDERING OF DOM !! Do not modify the state variable directly !!
		setState() takes an object as argument and merges it with the class state object for us.


	Generally on PROPS and STATE cause react to re-render the DOM.

	Anything using state is a statefull componenet. Otherwise it is stateless. Design to have few as possible statefull and as many
	as possible stateless (presentation) components.

	!!!! YOU SHOULD NEVER MUTATE THE STATE VARIABLE - ALWAYS TAKE COPIES, ESP FOR ARRAYS ETC, AND THE CALL setState() !!!!
		It is MUCH BETTER TO TAKE A **COPY** of the arrayMember, mutate it, and then setState()! Instead use slice() with no params to copy array:
			const arrayMemberRef = this.state.arrayMember.slice(); // Now arrayMemberRef references a COPY of the reactJs-managed state variable
		OR use ES6 spread operator:
			const arrayMemberRef = [...this.state.arrayMember]; // Now arrayMemberRef references a COPY of the reactJs-managed state variable

		The same is true if the member is an object - you'd get a reference, not a copy of the object. Take a copy using
			const objectmemberRef  = {...this.state.objectReference };
		OR old-school using Object.assign().



Events & Handlers
====================
All HTML attributes like onclick become onClick in JSX.
See https://reactjs.org/docs/events.html#supported-events

In a class that extends `Component`, define arrow function for eventHandler (use arrow function to correctly capture "this"). Then do , for e.g., <button onClick='this.eventHandler'>...</button>. When the button is
clock it will call the function `eventHandler()` of your class, which if it then modifies the class state, will cause the component to be re-rendered into the DOM.

To pass data to a handler use the bind() method.
	<button onClick={this.myHandler.bind(this, param1, param2, ...)>
If you've used arrow functions the binding to this isn't necessary - the arrow function will have captured it, but because we want
to bind other parameters, we now have to have this as the first parameter to bind(). This is why with arrow functions we don't
have to use bind() if there is no extra data to pass into the handler.

The other way to accomplish this is to use an arrow function, and it looks a little nicer IMO, BUT BUT apparently it can be less efficient and bind() is therefore preferred.
	<button onClick={() => this.myHandler(param1, param2, ...)}>

Hooks
======
All React hooks are called "useXXX".
	import React, {useXXX, useYYY, ...} from 'react';


useState() hook
---------------
So, now instead of using class `state` variable, in function-based componenet do:
	const app = (props) => {
		const [ theCurrentState, theSetStateFunction ] = useState({... state object defn ...});
Now, where you would use `this.state` use `theCurrentState` and where you would use `setState()` use `theSetStateFunction()`.
And in your handler functions, just put them inside the component defn function and reference the function in the JSX returned. NOTE - the handler must be an
	arrow function so that it is lexically scoped and captures `theCurrentState` and `theSetStateFunction` in the enclosing compononent def func.

		const app = (props) => {
			const [ theCurrentState, theSetStateFunction ] = useState({... state object defn ...});
			const myHandler = () => {
				theSetStateFunction({...});
			}
			return JSX-which-has-myHandler-as-an-onXXX-function;
		};

	!!!!BUT CAUTION!!!! theSetStateFunction() does **NOT** do a merge like setState() does. You must do the merge yourself manually! But you can get around this with many useSate() calls - state "slices".

This is a new way - the class based method is still seemingly the standard.



CSS
====

Import into your JS files so that WebPack is aware of its existance. Put CSS for component in component's dir and use class name same as component's name.
For things like "box-shadow" it converts this CSS property to the difference browser variables for us like "-webkit-box-shadow" and "box-shadow" for us so our CSS can be more brief and generic.


Inline styles
-------------

The style can be modified in the JS using inline styles. The CSS code ports almost directly to a JS object definition except REPLACE "-" WITH CAMEL CASE
	e.g. 
	render() {
		const style = {
			backgoundColor:'white',
			border:'1px solid blue',
			...
		};

		return ( <div style={style}>.....</div> );
	}



CONDITIONAL RENDERING
=====================

In JSX we can execute simple JS expressions in {...}. This means that we could render based on the ternary operator "cond ? true-path : false-path". Note cannot use if-else as this is
too complicated. Could we use a function and immediately evaluate it though? Not sure - need to try.
E.g.,
	return (
		<div>
			{
				this.state.someCondition ?
					<div>
						... some tags ...
					</div> : null // "null" means nothing is rendered
			}
			...
		</div>
	);

^^^
This gets MESSY fast, especially when multiple conditions are nested. It is BETTER to do the FOLLOWING:

	let myElements = null;
	if(this.state.someCondition)
	{
		myElements = (
			<div>
				... some tags ...
			</div>
		);
	}

	...

	return (
		<div>
			{myElements}
		</div>
	);
^^^
This is EASIER TO READ AND MAINTAIN! Keeps our core JSX template CLEAN!



RENDERING LISTS
===============

If the state, or whatever other variable has a list of attributes for a list of like-tags we can do this:
	return (
		<div>
			{this.state.listMember.map((member, index) => {
				return <TheElement
					somehandler={someHandlerFunction.bind(this, index)}
					prop1={member.prop1}
					prop2={member.anotherProp} 
					key={index} /> // You SHOULD ALWAYS PROVIDE A KEY!!
			})}
		</div>
	);

The map() funciton returns an array - JSX knowns how to render a list of ReactElement objects so this works okay.

NOTE -	arrays are references to an array - so 
		const arrayMemberRef = this.state.arrayMember; // Gets a reference to the state.arraymember!!
		arrayMemberRef[0] = 123; // !!!!WARNING!!!! This mutates the reactJs managed state object which can produce UNDERIABLE BEHAVIOUR
		this.setState({arrayMember : arrayMemberRef});
	It is MUCH BETTER TO TAKE A **COPY** of the arrayMember, mutate it, and then setState()! Instead use slice() with no params to copy array:
		const arrayMemberRef = this.state.arrayMember.slice(); // Now arrayMemberRef references a COPY of the reactJs-managed state variable
	OR use ES6 spread operator:
		const arrayMemberRef = [...this.state.arrayMember]; // Now arrayMemberRef references a COPY of the reactJs-managed state variable


NOTE -	When rendering lists of data ALWAYS USE THE KEY PROP. It helps react know what changed in the list more efficiently.



	
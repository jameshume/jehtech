<!DOCTYPE HTML>
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
   <meta charset="UTF-8">                                              <!-- HTML 5 -->
   <title>Linux (Scripting) notes</title>
   <!-- META_INSERT -->
   <!-- CSS_INSERT -->
   <!-- JAVASCRIPT_INSERT -->
</head>

<body>
   <div id="header">
      -- This is JEHTech --
   </div>

   <div id="sidebar">
      <h1 class="title">Links...</h1>
      <div id="includedContent"></div>
   </div>

   <div id="content">

      <h1 class="title">Linux (Scripting)</h1>
      <div style="padding-right:10px;">

      <h2>Page Contents</h2>
      <div id="page_contents">
      </div>

      <h2>References</h2>
      <div>
         <ol>
				<!-- 1 -->
            <li><a href="http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/"
               target="_blank">BASH Shell: Change The Color of My Shell Prompt, Vivek Gite, October 2006</a>
            </li>
				<!-- 2 -->
            <li><a href="http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses"
               target="_blank">Eval command in Bash and its typical uses</a>.
            </li>
				<!-- 3 -->
            <li><a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
               target="_blank">How do I split a string on a delimiter in Bash?</a>
            </li>
				<!-- 4 -->
            <li><a href="https://en.wikipedia.org/wiki/User_identifier"
               target="_blank">Linux User Identifier, Wikipedia</a>.
            </li>
				<!-- 5 -->
            <li><a href="http://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex"
                   target="_blank">StackOverflow: Capturing Groups From a Grep RegEx</a>.
            </li>
				<!-- 6 -->
            <li><a href="https://tiswww.case.edu/php/chet/bash/bash.html"
                   target="_blank">Bash Manual Page</a>.
            </li>
				<!-- 7 -->
            <li><a href="http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash"
                   target="_blank">Parse script parameters</a>.
            </li>
				<!-- 8 -->
            <li><a href="http://www.tldp.org/LDP/abs/html/parameter-substitution.html"
               target="_blank">Parameter Substitution</a> - The Linux Docimentation Project.
            </li>
				<!-- 9 -->
            <li><a href="http://www.tldp.org/LDP/abs/html/string-manipulation.html"
               target="_blank">Manipulating Strings</a> - The Linux Docimentation Project.
            </li>
				<!-- 10 -->
				<li><a name="ref10"></a><a href="http://tldp.org/LDP/abs/html/internalvariables.html"
					target="_blank">Bash Internal Variables</a>.
				</li>
				<!-- 11 -->
				<li><a name="ref11"></a><a href="http://unix.stackexchange.com/questions/126938/why-is-setting-a-variable-before-a-command-legal-in-bash"
					target="_blank">Why Setting A Variable Before A Command Is Legal In Bash</a>, StackOverflow Q&amp;A,
				</li>
				<!-- 12 -->
				<li><a name="ref12"></a><a href="http://unix.stackexchange.com/questions/264635/when-can-i-use-a-temporary-ifs-for-field-splitting"
					target="_blank">When A Temporary IFS Can Be Used For Field Splitting</a>, StackOverflow Q&amp;A,
				</li>
				<!-- 13 -->
				<li><a name="ref13"></a><a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
					target="_blank">How To Split A String On Any Delimiter In Bash</a>, StackOverflow Q&amp;A.
				</li>
         </ol>
      </div> <!-- END H2: References -->

      <h2>To Read</h2>
      <div>
          <ul>
            <li>https://magcius.github.io/xplain/article/index.html</li>
            <li>http://byobu.co/about.html</li>
            <li>http://stackoverflow.com/questions/16045139/redirector-in-ubuntu</li>
            <li>To reference: https://www.gnu.org/software/bash/manual/bashref.html</li>
            <li>http://www.learnshell.org/</li>
            <li>Systemd vs Init.rc: https://www.redhat.com/archives/rh-community-de-nrw/2014-July/pdfC1TTlawaxB.pdf<br/>https://www.linux.com/learn/understanding-and-using-systemd</li>
            <li>http://tldp.org/LDP/abs/html/colorizing.html</li>
          </ul>
      </div>

      <h2>Get An Explanation Of Complex Shell Commands</h2>
      <div>
        <p>
            See
            <a href="http://explainshell.com" target="_blank">http://explainshell.com</a>!
        </p>
      </div>

      <h2>.bashrc</h2>
      <pre class="prettyprint linenums">export PATH=$PATH:/home/$(whoami)/bin

# https://stackoverflow.com/questions/2314643/how-can-i-get-find-to-ignore-svn-directories
grp(){
    find . \( -path \*/.svn -o -path \*/.git \) -prune \
           -o \
           \( -name .\#\* -o -name \*.o -o -name \*\~ -o -name \*.bin -o -name \*.lbin \
                -o -name \*.so -o -name \*.a -o -name \*.ln -o -name \*.map \
                -o -name \*.class -o -name \*.lib -o -name \*.mem \
                -o -name \*.pyc -o -name \*.pyo -o -name GTAGS \
           \) -prune \
           -o \
           -type f \
           -exec grep --color=auto -i -nH -e $@ {} \;
}

cgrp(){
    find . \( -path \*/.svn -o -path \*/.git \) -prune \
           -o \
           \( -name .\#\* -o -name \*.o -o -name \*\~ -o -name \*.bin -o -name \*.lbin \
                -o -name \*.so -o -name \*.a -o -name \*.ln -name -o -name \*.map \
                -o -name \*.class -o -name \*.lib -o -name \*.mem \
                -o -name \*.pyc -o -name \*.pyo -o -name GTAGS \
           \) -prune \
           -o \
           \( -name \*.cpp -o -name \*.c -o -name \*.h -o -name \*.hpp \) \
           -type f \
           -exec grep --color=auto -i -nH -e $@ {} \;
}

parse_git_branch() {
   git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' | sed -e 's/^\s*//g'
}

parse_svn_branch() {
   svn info 2> /dev/null | grep "Relative URL" | sed -e "s/Relative URL:\s*//g"
}

parse_repo() {
   git_branch="$(parse_git_branch)"
   if [ ! -z "$git_branch" ]
   then
      echo -e "\nGIT: $git_branch"
   fi

   svn_branch="$(parse_svn_branch)"
   if [ ! -z "$svn_branch" ]
   then
      echo -e "\nSVN: ($svn_branch)"
   fi

   echo ""
}

## COMMAND: strip_ws
strip_ws() {
   sed -i 's/[[:space:]]*$//' $@
}

## COMMAND: svnmods
alias svnmods='svn status | grep "^\s*[MAD]"'

## COMMAND: svnfindexernaldirs
alias svnfindexernaldirs='find . -type d -a -not -path \*/.svn\* -print | while read f;do svn propget svn:externals "$f" >.svnproptmp 2>&1 && echo "$f" && cat -b .svnproptmp && rm .svnproptmp; done'

## COMMAND: gap
alias gap='printf "\n%.0s" {1..100}'

## Custom Prompt
PS1="\[\e[0;33m\]\$(parse_repo)\[\e[0m\]\n[\w]\n\u@\h\$ "</pre>
      <p></p>

      <h2>Writing UDev Rules</h2>
      <div>
      	<p>http://www.reactivated.net/writing_udev_rules.html</p>
      </div>

      <h2>Running Ubuntu On VirtualBox</h2>
      <div>
         <h3>Installing Ubuntu Guest Additions</h3>
         <p>
            The <a href="https://www.virtualbox.org/manual/ch04.html"
                   target="_blank">guest additions</a> are needed because
            <q>they consist of device drivers and system applications that optimize
            the guest operating system for better performance and usability</q>.
            They allow the system to do things like get the screen to scale
            correctly in full screen mode, enable mouse pointer integration,
            share clipboard and folders between host and guest and so on. See
            the link for full details.
         </p>
         <p>
            You can normally just install them from the VirtualBox menu as
            shown below:
         </p>
         <p>
            <img src="##IMG_DIR##/install_guest_additions_from_menu.png" alt="Image showing how to install guest additions on VirtualBox from VirtualBox menu"/>
         </p>
         <p>If that fails for whatever reason you can install and <a href="https://download.virtualbox.org/virtualbox" target="_blank">download the
            latest guest additions ISO from the VirtualBox webstite</a>. You can then
            add the CD to the VM's media as shown below (whilst the VM is powered
            off).
         </p>
         <p>
            <img src="##IMG_DIR##/add_vbox_additions_iso.png" alt="Image showing how to add a CD ISO to VM on VirtualBox"/>
         </p>
         <p>Now power up the VM. It will be
            mounted on <code>/media/&lt;user name&gt;/VBOXADDITIONS_x.x.x_xxxxx</code>.
            Change dir into that folder and <code>sudo sh VBoxLinuxAdditions.run</code>.
            Reboot.
         </p>
         <h3>Adding A Shared Directory Between Host and Guest</h3>
         <p>
            Whilst the VM is powered off, do the following to share a directory
            from the host (in my case Windows 7) and the guest (in my case Ubuntu 16).
         </p>
         <p>
            <img src="##IMG_DIR##/virtual_box_add_shared_dir.png" alt="Visual instruction on how to add shared folder in VirtualBox"/>
         </p>
         <p>Once you have created this share and select the auto-mount option,
            you may still not be able to access it. If you get a <em>permission denied</em>
            error then it is probably because your user account is not part
            of the <code>vboxsf</code> group and does not have permissions to access
            shared folders.
         </p>
         <p>
            To fix, open a terminal window and type &quot;<code>sudo usermod -G vboxsf -a &lt;user name&gt;</code>&quot;.
            Then log off, log on again. Now you should be able to acccess the
            shared directory, found under <code>/media/sf_&lt;share dir name&gt;</code>,
            which from the above example would be <code>/media/s_virtual_transfer</code>.
         </p>
      </div> <!-- END H2: Run ubuntu on vb -->

      <h2>Install Ubuntu MATE On Lenovo G510</h2>
      <div>
         <p>
            Installing from a USB stick is sorta easy. Set the BIOS to boot use UEFI:
            <q>... UEFI ... allows booting from hard disks as large as 9.4 ZB ...
            UEFI allows more boot options, doesnâ€™t prescribe particular file systems,
            and has excellent network booting abilities. OS boot loaders can also serve
            as extensions to the UEFI, which itself can function as a proper boot loader...</q>
            <a href="http://www.howtogeek.com/56958/" target="_blank">[ref]</a>
            To do this reboot your laptop and press F2 continually until the BIOS config
            opens.
         </p><p>
            Then the next challenge is to get the wireless working. You need to
            install the broadcom drivers. To do this you must <b>disable</b>
            <a href="http://forums.fedoraforum.org/showthread.php?p=1758847" target="_blank">[ref]</a>
            secure booting
            <a href="http://www.pcworld.com/article/2901262/microsoft-tightens-windows-10s-secure-boot-screws-where-does-that-leave-linux.html"
               target="_blank">[ref]</a>
            in your BIOS settings. If you don't do this you will find that the next steps
            <a href="http://askubuntu.com/questions/553615/cant-enable-the-proprietary-drivers-for-broadcom-bcm43142-wireless-after-instal"
               target="_blank">[ref]</a> give you an error along the lines of
            &quot;ERROR: could not insert 'wl': Required key not available&quot;.
         </p> <p>
            Boot Ubuntu and load a console window. Type the following:
         </p>
         <pre>sudo apt-get update
sudo update-pciids
sudo apt-get install bcmwl-kernel-source</pre>
         <p>
            Reboot. This should get your wireless up and running.
         </p>
      </div>

      <h2>Running XServer On Windows</h2>
      <div>
            <p>
                <a href="http://www.straightrunning.com/XmingNotes/" target="_blank">Xming</a>
                with putty worked out-of-the-box for me on my Windows 10 machine. Download
                and install Xming. Once installed, from the start menu, run Xming &gt; XLaunch.
                From there select &quot;Multiple windows&quot;. If you're only going to have the
                one XServer running, just leave the display number as zero.
            </p>
            <p>
                Next start a Putty session with X11 forwarding enabled:
            </p>
            <p>
                <img src="##IMG_DIR##/setup_x11_putty.png" alt="Screen shot of Putty with X11 forwarding enabled"/>
            </p>
            <p>
                From your SSH session, if you launch a GUI application should now magically appear
                on your desktop :)
            </p>
            <p>
                If, for some reason, it does not, check the XMing log. If you see
                that your IP has been rejected with a message like &quot;<code>AUDIT: Thu Mar 15 15:28:10 2018: 7452 C:\Program Files (x86)\Xming\Xming.exe: client 4 rejected from IP 192.168.1.208</code>&quot;, add your client IP to the file <code>X0.hosts</code> in the XMing installation directory.
            </p>
      </div>

      <h2>Fix Putty Linux Terminal Session Function Keys And Keypad</h2>
      <div>
          <p>Pressing the HOME key normally doesn't work in my Putty sessions when loggin onto a Linux box.
          This is because the Putty terminal type needs setting up:</p>
          <p><img src="##IMG_DIR##/putty_linux_terminal_type.png" alt="Screenshot of Putty terminal type configuration for Linux"/></p>
      </div>

      <h2>Install Packages Offline</h2>
      <p>
        Needed to do this for a computer without an internet connection. SO to the rescue again:
      </p>
      <ul>
        <li><a href="http://stackoverflow.com/questions/4419268/how-do-i-download-a-package-from-apt-get-without-installing-it" target"_blank">Download a package without installing it</a>,</li>
        <li><a href="https://askubuntu.com/questions/974/how-can-i-install-software-or-packages-without-internet-offline" target"_blank">Install packages without internet</a>.</li>
      </ul>
      <p>
        In summary, to download a package and all of its dependencies, without installing them, to
        a directory of your choosing use the following commands:
      </p>
      <pre>MYBASE=/a/directory/of/your/choosing
mkdir -p $MYBASE/archives/partial
apt-get -d -o dir::cache=$MYBASE -o Debug::NoLocking=1 install package</pre>
      <p>
        The <code>-d</code> option tells <code>apt-get</code> not to install, just download (although
        you still need to use the <code>install</code> command in the command line string).
      </p>
      <p>
        The <code>-o dir::cache=$MYBASE</code> option means use the specified directory as the location to cache all the
        <code>.deb</code> files required.
      </p>
      <p>
        Then all yoy need to do is to copy your directory to your other machine with no internet
        (tar up the cache directory to transfer) and run the following:
      </p>
      <pre>MYBASE=/where/you/copied/the/cache/to
apt-get dir::cache=$MYBASE install package</pre>

		<h2>GRUB - A Bootloader</h2>
		<div>
			<h3>Access From Bootup</h3>
			<p>
				Hold down shift on bootup.
			</p>
			<h3>Access from Linux</h3>
			<p>
				Config file is <code>/boot/GRUB/GRUB.cfg</code> - do <b>not</b> edit this directly. It is
				a generated file.
			</p>
			<p>
				Instead edit <code>/etc/default/GRUB</code> and regenerate the above CFG using <code>sudo update-GRUB</code>.
			</p>
		</div>

		<h2>Static Shell Script Analysis With ShellCheck</h2>
		<div>
			<p>
				Visit the <a href="http://www.shellcheck.net" target="_blank">ShellCheck website</a>
				and paste in your script to get a detailed analysis. You can learn a
				ton of reaslly useful bash information using this really quickly. For example,
				two common errors I used to make were:
			</p>
			<ul>
				<li><a href="https://github.com/koalaman/shellcheck/wiki/SC2086#double-quote-to-prevent-globbing-and-word-splitting"
					    target="_blank">Double quote to prevent globbing and word splitting</a>.
				</li>
				<li><a href="https://github.com/koalaman/shellcheck/wiki/SC2045"
					    target="_blank">Iterating over ls output is fragile. Use globs</a>.
				</li>
				<li><a href="https://github.com/koalaman/shellcheck/wiki/SC2015"
					    target="_blank">A &amp;&amp; B || C is not if-then-else</a>.
			</ul>
		</div>

		<h2>Simple Commands and Their Execution</h2>
		<div>
			<p>
				Often in bash scripts you see variable assignments on the same line
				as a command that is being executed, for example:
			</p>
			<pre>JEHTECH=1234 some-command</pre>
			<p>
				What is this doing and why is it possible? References <a href="#ref10">10</a>
				through <a href="#ref13">13</a> are really good starters, but in the end, however, it is all
				available in the bash man page :) It says:
			</p>
			<blockquote>
				<p>
					...A  simple command is a sequence of optional variable assignments
					followed by blank-separated words and redirections,
					and terminated by a control operator...
				</p>
				<footer>-- Bash man page</footer>
			</blockquote>
			<p>
				Ignoring redirections and the control character
				(&quot;||&quot;, &quot;&amp;&quot;, &quot;&amp;&amp;&quot;,
				&quot;;&quot;, &quot;;;&quot;, &quot;(&quot;, &quot;)&quot;,
				&quot;|&quot;, &quot;|&amp;&quot;, &quot;&lt;newline&gt;&quot;),
				this means that a simple command is:
			</p>
			<pre  class="prettyprint linenums">[VAR1=value VAR2=value ...] COMMAND PARAM1 PARM2 ...</pre>
			<p>
				The command can result from the expansion of a variable, or be a
				literal. It also does not have to be present (ie., you just have a
				variable assignment on its own).  The bash man page proceeds to say
				later on...
			</p>
			<blockquote>
				<p>
					...When a simple command is executed, the shell performs the
					following expansions, assignments, and redirections, from left
					to right.
				</p>
				<ol>
					<li>
						The words that the parser has marked as variable assignments
						(those preceding the command name) and redirections are saved
						for later processing.
					</li>
					<li>
						The words that are not variable assignments or redirections are
						expanded.  If any words remain after expansion, the first word
						is taken to be the name of the command and the  remaining  words
						are the arguments.
					</li>
					<li>Redirections are performed ...</li>
					<li>
						The  text  after  the  = in each variable assignment undergoes
						tilde expansion, parameter expansion, command substitution,
						arithmetic expansion, and quote removal before being assigned to the
						variable.
					</li>
				</ol>
				<p>
					If no command name results, the variable assignments affect the
					current shell environment.  <b>Otherwise, the variables are added
					to the environment of the executed command and do not affect
					the current shell environment</b>...
				</p>
				<footer>
					-- Bash man page.
				</footer>
		 	</blockquote>
			<p>
				Therefore when you write commands such as &quot;<code>JEHTECH=1234 some-command</code>&quot; the
				enironment variable &quot;<code>JEHTECH</code>&quot; would be set only in the sub-shell that
				the command is executed in and won't affect the existing shell (unless
				the command is a built-in or function, then it will!).
			</p>
			<p>
			You'll also notice from the above that <q>...words that are not variable assignments or redirections are expanded...</q> <b>before</b> the command is executed.
			This means that in the following section of code &quot;HELLO&quot; is printed out instead of &quot;BYE BYE&quot;...
			</p>
			<pre  class="prettyprint linenums">$ JAMES="HELLO"
~$ JAMES="BYE BYE" echo "$JAMES"
HELLO</pre>
			<p>
				This puzzled me for a bit, but because <q>...words that are not variable assignments or redirections are expanded...</q>
				<b>before</b> the command is executed, the following is happening.
			</p>
			<ol>
				<li>The variable assignment <code>JAMES="BYE BYE"</code> is saved. So the line being processed is now just <code>echo "$JAMES"</code>
				</li>
				<li>Now variable expansion occurs. The value of <code>$JAMES</code> is still &quot;HELLO&quot; because that is the value
				    of the variable in the current shell. The new assignment that happens as part of our simple command has not
					 taken effect yet! The command to be executed is therefore now <code>echo HELLO</code>.
				</li>
				<li>To execute this command a new subshell is created in which it. As part of that new subshell, the
				variable assignment <code>JAMES="BYE BYE"</code> is added to the new sub shell. But the command being
				executed in the subshell is <code>echo HELLO</code>, and that's why we see the output we do.
				</li>
			</ol>
		</div>

		<h2>Word Splitting</h2>
		<div>
			<p>
				The bash shell variable <code>$IFS</code> is a list of delimeters that
				the shell will use to split words on. I like to think of it as
				the delimeter list I'd supply to the C function <code>strtok()</code>.
				Once a word has been tokenized the shell does not see it as one &quot;block&quot;
				but as many seperate tokens/parameters.
			</p>
			<p>
			The shell will word split in 3 instances <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html" target="_blank">[ref]</a>:
			</p>
			<ol>
				<li>Parameter expansion,</li>
				<li>Command substitution,</li>
				<li>Arithmetic expansion.</li>
			</ol>
			<p>
				References <a href="#ref10">10</a> through <a href="#ref13">13</a> are really good starters
				that I have used to help myself understand what is going on. The bash
				man page is also increadibly useful and arguably the most authorative.
			</p>
			<p>
				Lets look at some examples... to begin with we'll export one
				variable for us to play with:
			</p>
			<pre class="prettyprint linenums">~$ export JEHTECH="a b c d     e#f"</pre>
			<p>
				We can immediately see word splitting occuring if we do the following:
			</p>
			<pre class="prettyprint linenums">~$ echo $JEHTECH
a b c d e#f</pre>
			<p>
				Our original string had many spaces between the &quot;d&quot; and &quot;e&quot; but
				the <code>echo</code> output does not. What has happened here is that parmeter expansion
				occured (this occurs <b>before</b> the entire command line is evaluated).
			</p>
			<p>
				The bash shell had to substitute the value of <code>$JEHTECH</code> and when
				it does this is splits or tokenises the resulting expansion based on the
				delimeters in <code>$IFS</code>. The default value for <code>$IFS</code> is <code>&lt;space&gt;&lt;tab&gt;&lt;newline&gt;</code>,
				so any of the characters in any consecutive order are &quot;deleted&quot; and used as a
				seperator between words. The result is that bash finds the tokens
				&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, and &quot;e#f&quot;.
			</p>
			<p>
				Notice the difference when we enclose the variable <code>$JEHTECH</code> in
				quotes:
			</p>
			<pre class="prettyprint linenums">~$ echo "$JEHTECH"
a b c d     e#f
			</pre>
			<p>
				In the above example, although parameter expansion has taken place,
				no word splitting has been performed. The reason is, is that bash
				will not perform word splitting when the expansion (be it parmeter,
				arithemetic or command substitution) occurs in quotes.
			</p>
			<div class="box_container"><div class="info">
				<p>
					 Bash will not perform word splitting when the expansion (be it parmeter,
					arithemetic or command substitution) occurs in quotes.
				</p>
			</div></div>
			<p>
				It is for this reason that tools like <a href="http://www.shellcheck.net" target="_blank">ShellCheck</a>
				will always recommend that double quotes should be used to avoid word splitting.
				This is because the effects of word splitting are often not wanted. For example, if
				you received a variable from the user in one of your scripts, and lets say it is
				a directory from which you need to work from. If you do the following, and the
				directory name contains a space, the parameter substitution will create two tokens
				when only one was meant - the directory name that unluckily contained a space. Try
				the following:
			</p>
			<pre class="prettyprint linenums">~$ mkdir "jeh tech"
~$ ll -d jeh\ tech/
drwxr-xr-x 2 jehtech jehtech 4096 Aug 12 10:36 jeh tech//

~$ export MYDIR="jeh tech"
~$ ll -d $MYDIR
ls: cannot access jeh: No such file or directory
ls: cannot access tech: No such file or directory

~$ ll -d "$MYDIR"
drwxr-xr-x 2 jehtech jehtech 4096 Aug 12 10:36 jeh tech/

~$ rmdir jeh\ tech/</pre>
			<p>
				Note how the command <code>ll -d $MYDIR</code> fails, but
				<code>ll -d &quot;$MYDIR&quot;</code> does what is expected!
			</p>
			<p>
				We can play with the value of <code>$IFS</code> to further split the
				characters in our example variable <code>$JEHTECH</code> on the &quot;#&quot;
				character too:
			</p>

			<h3>Parse Version Strings: Splitting Strings On A Delimeter</h3>
			<p>
				I wanted to be able to check the IPython version in a shell script to
				let the user know if it needed upgrading and to offer to do the upgrade
				automatically. I knew I could spit the string onto multiple lines
				using <code>tr</code> and then parse it in a <code>for</code> loop, but a quick
				bit of googling and StackOverflow came to the rescue again
				<a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
				   target="_blank">[3]</a>.
			</p>
			<pre class="prettyprint linenums">IFS="." read -a pyVerInfo &lt;&lt;&lt; "$pyVer"
if [ ${pyVerInfo[0]} -ne 3 ]; then
   #error
fi</pre>
			<p>
				This cool little snippet splits the string up using a full-stop as the
				delimeter and saves it as an array to the variable <code>pyVerInfo</code>.
			</p>
		</div>

      <h2>Ensure A Script Runs As Root</h2>
      <div>
         <p>
            If you know that your shell script will require root permissions
            and must be run with <code>sudo</code>, you can cause the script to
            output a useful error message and abort if it isn't run as such,
            rather than a bunch of commands just failing. To do this you can
            check the user's effective user ID
            <a href="https://en.wikipedia.org/wiki/User_identifier"
               target="_blank">[4]</a>, which will be zero if s/he has
            root privileges...
         </p>
         <pre class="prettyprint linenums">if [ "$(id -u)" -ne 0 ]
then
   echo "### ERROR: You must run this script as root"
   exit 1
fi</pre>
         <p>
            Instead of <code>$(id -u)</code> you could also use <code>$EUID</code> and
            you can be more consise using:
         </p>
         <pre class="prettyprint linenums">[ "$(id -u)" -ne 0 ] &amp;&amp; { echo "### ERROR: You must run this script as root"; exit 1; }</pre>
         <p>
            Where the <code>{...}</code> braces group the commands but executes them
            in the current shell context. If you used <code>(...)</code> braces then
            the group commands would be executed in a sub-shell.
         </p>
      </div> <!-- END: H2 -->

      <h2>Modifying The Linux Shell's Command Prompt</h2>
      <div>
         <h3>Adding Colour To The Linux Prompt</h3>
         <p>
            To set prompt to be yellow:
         </p>
         <pre>PS1='\[\e[0;33m\]\u@\h:\w\$ \[\e[0m\]'</pre>
         <p>
            Note that the &quot;<code>\[</code>&quot; and &quot;<code>\]</code>&quot;
            surrounding the &quot;<code>\e...</code>&quot; constructs
            are very important as otherwise the size of the prompt is
            miscalculated and when cycling through command history the display
            messes up
            <a href="http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/"
            target="_blank">[1]</a>.
         </p>
         <p>
            Add this to your <code>~/.bashrc</code> file to make it permanent.
         </p>
         <h3>Collapsing The Path Displayed In The Linux Prompt</h3>
         <p>
            I really dislike it when the cwd printed in the prompt begins
            to get too long and take up most of the terminal line. What I
            wanted was for the cwd to collapse a little when this happended.
            To do this I set my <code>PS1</code> environment variable as follows
            and used the (hacky) Python script, also shown below.
         </p>
         <p>
            Set <code>PS1</code> as follows:
         </p>
         <pre>PS1="\[\e[0;33m\]\$(python ~/ps1.py)\$ \[\e[m\]"</pre>
         <p>
          NOTE the backslash in front of <code>$(python ...)</code>. This
          prevents the python script from being run and the output evaluated
          immediately: you want the script to be run each time PS1 is itself
          evaluated, not just one when setting the value of PS1.
         </p>
         <p>
            Then created the file <code>ps1.py</code> in my home directory:
         </p>
         <pre class="prettyprint linenums lang-python">import os

pref = os.path.sep
home = os.path.expanduser("~").split(os.sep)
home.remove('')

l = os.getcwd().split(os.sep)
l.remove('')

if l[0:len(home)] == home:
   l = l[len(home):]
   l.insert(0, "~")
   pref = ""

if len(l) &gt; 4:
   ll = [l[0], l[1], l[2], "...", l[-1]]
   print pref + os.path.join(*ll)
else:
   print pref + os.path.join(*l)</pre>

         <a name="Adding-Current-Git-Or-Svn-Branch-To-The-Linux-Prompt"></a>
         <h3>Adding Current Git Banch To The Linux Prompt</h3>
         <p>
          <b>References:</b>
         </p>
         <ul>
           <li><a href="https://coderwall.com/p/fasnya/add-git-branch-name-to-bash-prompt"
                  target_"_blank">Add git branch name to bash prompt</a>, Eranga Bandara.
           </li>
           <li><a href="https://serverfault.com/questions/4889/what-are-some-informative-and-useful-shell-prompts-bash-csh-ksh-etc"
                  target_"_blank">What are some informative and useful shell prompts?</a> Stack Overflow.
           </li>
         </ul>
         <p>Slight mod from Bandara's example to strip starting whitespace, add some colour, and detevt SVN repos too...</p>
         <pre class="prettyprint linenums lang-python">parse_git_branch() {
   git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' | sed -e 's/^\s*//g'
}

parse_svn_branch() {
   svn info 2> /dev/null | grep "Relative URL" | sed -e "s/Relative URL:\s*//g"
}

parse_repo() {
   git_branch="$(parse_git_branch)"
   if [ ! -z "$git_branch" ]
   then
      echo -e "\nGIT: $git_branch"
   fi

   svn_branch="$(parse_svn_branch)"
   if [ ! -z "$svn_branch" ]
   then
      echo -e "\nSVN: ($svn_branch)"
   fi

   echo ""
}

PS1="\[\e[0;33m\]\$(parse_repo)\[\e[0m\]\n[\w]\n\u@\h\$ "</pre>
      </div> <!-- END H2: Linux Prompt With Colours -->

      <h2>Modify Any PATH-like Variable And Variable Dereferencing</h2>
      <div>
         <p>
            Modifying a <code>PATH</code>-like variable (eg. <code>PATH</code>,
            <code>LD_LIBRARY_PATH</code>, <code>PYTHONPATH</code> etc is obviously easy.
            What I found was I often wanted to script it and only modify a path
            if what I wanted to add wasn't already listed. Also, sometimes I
            wanted to remove a path from a <code>PATH</code>-like variable.
         </p>
         <p>
            Accomplishing this required the use of functions and the <code>eval</code>
            statement to dereference a variable twice, i.e. to use one variable
            as a &quot;reference&quot; to another. There are also the little
            corner cases when adding to a path... if it's empty then don't
            add a colon and when removing a path don't leave a trailing colon.
         </p>

         <h3>Dereference Variable Name</h3>
         <p>
            The first method I learnt to dereference a variable was this:
         </p>
         <pre class="prettyprint linenums">$ jtRef=JEH_TECH
$ JEH_TECH="This is JEH-Tech.com"
$ eval echo \$$jtRef
This is JEH-Tech.com</pre>
         <p>
            Works quite well. <code>eval</code>'s parameters are evaluated by the
            shell and passed to <code>eval</code>. Thus, <code>echo \$$jtRef</code> gets parsed
            by the shell as <code>echo $JEH_TECH</code>, which is passed to <code>eval</code>.
            Eval then re-evalulates this string which <code>echo</code>es the value
            of the variable <code>JEH_TECH</code>. Thus we have essentially
            dereferenced <code>jtRef</code>. <b>Note however that eval is a potentially massive security whole!!</b>
         </p>
         <p>
            However, in Bash, there is a much easier syntax
            <a href="http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses"
               target="_blank">[2]</a>. We could just write
            the following.
         </p>
         <pre class="prettyprint linenums">$ echo ${!jtRef}
This is JEH-Tech.com</pre>
         <p>
            In Bash, the variable expansion mechanism
            <code>${!<em>varName</em>}</code> does the dereferencing much more
            elegantly for us...
         </p>

         <h3>Splitting up PATH-like Variable Using Sed and Tr</h3>
         <div>
            <p>
               To split up the path variable, i.e, do the equivalent of a
               <code>split()</code> function in bash, I used a combination of
               <code>tr</code> and <code>sed</code>.
            </p>
            <p>
               Why do the split? Two reasons. Firstly, grep would match
               the first occurrence of a string. So if <code>PATH=/aaa/bbb</code>
               and I wish to add <code>/aaa</code>, <code>grep</code>ing for it before
               adding it to the path (so I don't clutter it with duplicates)
               won't work: I can't use word boundaries in the regexp because the
               <code>/</code> appears to count as a word boundary and grepping for
               possible colons becomes tedious. Secondly, sed works on a line by
               line basis.
            </p>
            <p>
               So, my solution is this... use <code>tr</code> to break the path
               string across many lines, one line per path element, and then
               use <code>sed</code> to blank out the matching path, and then use
               <code>tr</code> to re-collapse it all back into one string (removing
               the duplicate newline resulting from the blank line created by
               <code>sed</code>
            </p>
            <p>
               For example, removing a path element has the following script
               snuippet
            </p>
			<pre class="prettyprint linenums">echo -e "${!varname}" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//'</pre>
            <p>
               The snipped works as follows...

               <ol>
                  <li><code>echo -e "${!varname}"</code> echoes the value of the
                      variable referenced by <code>varname</code> to stdout, which
                      is piped into <code>tr</code>.
                  </li>
                  <li><code>tr ":" "\n"</code> replaces all colons in the path
                      string with newlines so that sed can work line by line
                  </li>
                  <li><code>sed -e "s@^$path_2_del\$@@g"</code> blanks out the line
                      (deletes the line but not the trailing newline) that
                      matches <em>the entire</em> path and no more. The use of
                      the <code>@</code> is because if we used a forward slash we'd
                      have to go to the trouble of escapre the path seperators.
                  </li>
                  <li><code>tr -s "\n" ":" | sed -e 's/:$//'</code> staples the
                      lines back into one string and removes any trailing colon
                      that may have been left.
                  </li>
               </ol>
			</p>
			<p>
				Or... the following sed script would have done the same...
			</p>
			<pre class="prettyprint linenums">s/\(:\{0,1\}\)PATH_TO_DELETE\(:\{0,1\}\)/\1\2/g
s/::*/:/g
s/^://g
s/:$//g</pre>
         </div>

         <h3>Resulting Script To Add/Remove Path Elements From PATH-like Variables</h3>
         <div>
            <p>
               I made the following script to accomplish addition and removal of
               elements from <code>PATH</code>-like variables. Quite possibly could be
               more elegant so any suggestions welcome :) Above each use of the
               <code>${!<em>varName</em>}</code> syntax is a commented-out equivalent
               using <code>eval</code>.
            </p>
            <pre class="prettyprint linenums">#
# Expects 2 arguments. The name of the variable to have a path element
# added to it and the path element.
# eg. add_to_path LD_LIBRARY_LATH /my/special/directory
function add_to_path() {
   if [ $# != 2 ]; then
      &gt;&amp;2 echo "### ERROR: Bad number of params! Expected varname and path"
      return 1
   fi

   varname=$1
   path_2_add=$(readlink -f $2)
   if [ -z "$path_2_add" ]; then
      &gt;&amp;2 echo "### ERROR: Could find the directory!"
      return 2
   fi

   if [ -d "$path_2_add" ]; then
      #found=$(eval echo -e "\$$varname" | tr ":" "\n" | grep -c "^$path_2_add\$")
      found=$(echo -e "${!varname}" | tr ":" "\n" | grep -c "^$path_2_add\$")
      echo "FOUND=$found"
      if [ "$found" == "0" ]; then
         #if [ -z "$(eval echo \$$varname)" ]; then
         if [ -z "${!varname}" ]; then
            export $varname=$path_2_add
         else
            #export $varname=$(eval echo \$$varname:$path_2_add)
            export $varname=${!varname}:$path_2_add
         fi
      fi
   else
      &gt;&amp;2 echo "### ERROR: The directory $path_2_add does not exist!"
      return 3
   fi

   return 0
}

#
# Expects 2 arguments. The name of the variable to have a path element
# added to it and the path element.
# eg. remove_from_path LD_LIBRARY_LATH /my/special/directory
function remove_from_path() {
   if [ $# != 2 ]; then
      &gt;&amp;2 echo "### ERROR: Bad number of params! Expected varname and path"
      return 1
   fi

   varname=$1
   path_2_del=$2

   #export $varname=$(eval echo -e "\$$varname" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//')
   export $varname=$(echo -e "${!varname}" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//')</pre>
         </div> <!-- END: H3 -->
      </div> <!-- END: H2: Modify Any Path... -->

      <h2>New Bash Test [[...]] &amp; Regular Expressions</h2>
      <div>
         <p>
            Recently I had a problem where I wanted to recurse through a set
            of files, get their names to pass to a program but also parse the
            file name to get another bit of information which had to be used
            to construct another parameter that was to be passed to the same
            program.
         </p>
         <p>
            Regular expressions and group captures spring to mind and as it turns out
            that Bash (and some other more modern shells) can so this using the
            new test built-in: <code>[[...]]</code>.
         </p>
         <p>
            Thanks to the following references:
            <ul>
               <li><a href="http://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex"
                      target="_blank">StackOverflow: Capturing Groups From a Grep RegEx</a>.
               <li><a href="https://tiswww.case.edu/php/chet/bash/bash.html"
                      target="_blank">Bash Manual Page</a>.</li>
            </ul>
         </p>
         <p>
            Combining this with the info from section &quot;<a href="#ExecAlternative">Find --exec alternative when you want to exec a script function</a>&quot;
            the following worked quite well. This would work for files of the format
            &quot;part1_part2.txt&quot;
         </p>
         <pre class="prettyprint linenums">dir="/A/path/to/the/root/folder"
regex="^([^_]*)_([^_]*)\.txt"
find $dir -name '*.txt' -print |
while read fname
do
   [[ $fname =~ $regex ]]
   group1="${BASH_REMATCH[1]}"
   group2="${BASH_REMATCH[2]}"
   echo "First group is $group1 and second is $group2"
done</pre>

         <p>From the Bash manual: <q>... parenthesized subexpressions ... are
            saved in the array variable <code><b>BASH_REMATCH</b></code> ...  index 0 is
            [the match of] the entire regular expression ... index n is the
            [match of] the nth parenthesized subexpression.</q>
         </p>
      </div> <!-- End H2: New bash Test -->

      <h2>User Limits</h2>
      <div>
          <p>Display the current hard limit of your machine:
          <pre>ulimit -aH</pre>

          <p>To increase the file descriptor limit:</p>
          <ol>
            <li>Add extra lines to <code>/etc/security/limits.conf</code>:
                <pre>&lt;username&gt;     soft   nofile  1024
&lt;username&gt;     hard   nofile  4000 #< Use what you like</pre>
                (Use a '*' for the username if you want to match all users).
            </li>
            <li>Make sure <code>session required /lib/security/pam_limits.so</code> appears in <code>/etc/pam.d/login</code>.
            </li>
            <li>Reboot your system.</li>
            <li>Use the command <code>ulimit -n unlimited</code>, to use the hard
                limit you wrote to <code>/etc/security/limits.conf</code>.
            </li>
          </ol>
      </div>

      <h2>Misc Script Stuff</h2>
      <div>
         <h3>Rediection Tutorials</h3>
         <p>
            <a href="http://wiki.bash-hackers.org/howto/redirection_tutorial"
               target="_blank">Illustrated Redirection Tutorial</a>.
         </p>
         <p>
            <a href="http://tldp.org/LDP/abs/html/ioredirintro.html"
               target="_blank">A Detailed Introduction to I/O and I/O Redirection</a>.
         </p>

         <h3>Pretty Print Script Status Output</h3>
         <p>
            <a href="http://stackoverflow.com/questions/5506176/bash-echo-something-to-right-end-of-window-right-aligned"
               target="_blank">SO thread: Bash, echo something to right end of window (right aligned)</a>
         </p>
         <p>
            <a href="http://stackoverflow.com/questions/2494902/how-to-write-a-bash-script-like-the-ones-used-in-init-d"
               target="_blank">SO thread: How to write a bash script like the ones used in init.d?</a>
         </p>

         <h3>Get My Ubuntu Version</h3>
         <pre class="prettyprint linenums">lsb_release -a</pre>

         <h3>Ping A Range Of Addresses</h3>
         <pre>nmap -sP 192.168.0.0-255</pre>
         <p>Use the timeout option <code>-T</code> to make the scan quicker
            if you wish...
         </p>

         <h3>Rename A Set Of Files</h3>
         <p>
            I had a set of files where part of the filename identified a test
            sample. The samples had been labelled wrongly, but consistently so,
            so all that was needed was exhanging one sample name for another...
         </p>
         <pre class="prettyprint linenums">N=new_samp &amp;&amp;
O=old_samp &amp;&amp;
find -name "*$O*" |
  while read oldf
  do
    newf=$(echo $oldf | sed "s/$O/${N}_corrected/")
    cp o=$oldf n=$newf
done</pre>
         <p>The &quot;_corrected&quot; suffix was added to stop the situation
            where sample A is renamed to B, but there are existing B's that
            must also be renamed.</p>

         <h3>Halt script if variable NOT set</h3>
         <pre class="prettyprint linenums"><a href="http://linuxcommand.org/lc3_man_pages/seth.html" target="_blank">set</a> -u</pre>

         <a name="ExecAlternative"><h3>Find --exec alternative when you want to exec a script function</h3></a>
         <p>
            For when you want to do an operation on a set of files but can't
            use &quot;<code>find ... -exec ...</code>&quot; because you want to
            call a script function, for example...
         </p>
         <pre class="prettyprint linenums">find path ..options.. -print |
while read variable_name
do
   my_function "$variable_name"
done</pre>

         <h3>Read</h3>
         <h4>Piping Output To Read</h4>
         <p>
            The builtin
            <code><a href="http://linuxcommand.org/lc3_man_pages/readh.html" target="_blank">read</a></code>
            is very useful for
            <a href="http://stackoverflow.com/questions/226703/how-do-i-prompt-for-input-in-a-linux-shell-script/27875395#2787539"
               target="_blank">reading in user input</a>,
            or for reading and processing the output of a command like <code>find</code> line by line. For example:
         </p>
         <pre class="prettyprint linenums">for dir in "list of dirs ":
do
   echo "LOOKING IN DIR '$dir'"
   find "$dir" -name '*.csv' -print |
   while read fname
   do
      echo "$fname"
   done
done</pre>
         <p>
            One thing that might catch you out is that variables inside the
            <code>while</code> loop
            <a href="http://mywiki.wooledge.org/BashFAQ/024"
               target="_blank">disappear after the loop terminates</a>. The
            summary is that the <code>while</code> loop is executed in a
            sub shell, so will have a new variable and context.
         </p>
         <p>
            This is further explained in this <a href="https://unix.stackexchange.com/questions/272698/why-is-the-array-empty-after-the-while-loop" target="_blank">SO thread</a> - 
            the <q>problem is that <b>in a pipeline ( command1 | command2 | command3 ... ) the commands are run in subshells</b></q>.
         </p>
         <h4>Reading Files Line By Line</h4>
         <p>
            Another useful example is when you want to read a file line by
            line in your bash script. This was answered perfectly in
            <a href="http://stackoverflow.com/questions/10929453/bash-scripting-read-file-line-by-line this"
               target="_blank">SO thread</a>.
         </p>
         <p>
            I found it really useful to take a summary of SVN diffs, delete the
            stuff I wasn't interested in and then only diff the remaining.
            The script is on the <a href="svn.html#Diff2Paths">SVN page</a>.
         </p>

         <h3>Useful builtins</h3>
         <ul>
            <li>readlink. options like --canonicalize (-f is synonym)</li>
            <li><a href="http://www.tldp.org/LDP/abs/html/parameter-substitution.html"
               target="_blank">Variable substitution</a>.
            </li>
            <li><a href="http://mywiki.wooledge.org/BashFAQ/035#getopts"
               target="_blank">getopts</a>.
            </li>
         </ul>

         <h3>Kill Script On First Error</h3>
         <p>
            If you would like your bash script to fail on the first command that returns a non
            zero error code use:
         </p>
         <pre>set -e # On its own may not be enough - see below...
set -o pipefail # Make sure errors propogate through pipes!!</pre>
         <p>
            You can cancel it by using <code>+e</code>
         </p>

         <h3>Echo Each Command Before Execution</h3>
		 <pre>set -x</pre>
      </div><!-- End H2: Misc Script Stuff -->

      <h2>Debug .so Loading Using LD_DEBUG</h2>
      <div>
         <p>
            If a program is complaining that it cannot find a library you can always try setting <code>export LD_DEBUG=libs</code>
            before running that program (or <code>export LD_DEBUG=help</code> to get help). You'll get debug output describing libraries being searched for and
            loaded. You can also set <code>export LD_DEBUG=all</code> for an absolute shed-load of debug info, which might be too much, but at least
            you'll be able to see where the loader is searching for libraries and what, if anything, it finds. To clear the
            loader debug output just set <code>export LD_DEBUG=</code>.
         </p>
         <p>
            Annoyingly on QNX (I know it's POSIX-like and not Linux) it appears
            you need to set <code>DL_DEBUG</code> (Note &quot;DL&quot;,
            not &quot;LD&quot;)...
         </p>
      </div>  <!-- END: H2: Debug .so Loading Using LD_DEBUG -->

      <h2>Network Emulation With Netem</h2>
      <div>
      	<ul>
      		<li><a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank">NetEm</a>.</li>
      	</ul>
      </div> <!-- END H2 Netem -->

      <h2>Bash History Expansion</h2>
      <div>
        <p>Notes based on <a href="http://www.thegeekstuff.com/2011/08/bash-history-expansion/" target="_blank">this article</a>.
        </p>
        <p>&quot;Basic&quot; execution of commands from the shell history:</p>
        <pre>!4              # Display and execute the fourth commnd in the history table
!-2             # Display and execute command type 2 commands back
!!              # Display and execute previous command  } These two are ...
!-1             # Display and execute previous command  } ... equivalent
!word           # Search backwards through command history for first command
                # that <em>starts</em> with &quot;word&quot;. If found,
                # display and execute command
!?word          # Search backwards through command history for first command
                # that <em>contains</em> &quot;word&quot;. If found,
                # display and execute command
^str1^str2^     # Change the first occurence of str1 in previous command
                # to str2
!!:s/str1/str2  # Same as previous
!!:gs/str1/str2 # Change ALL occurences of str1 in previous command to str2
!!:n            # Get the nth argument of the previous command
!!:$            # Get last argument or the previous command
!$              # Shorthand for above</pre>
      </div>

      <h2>Systemd &amp; D-bus</h2>
      <div>
        <pre>
http://mirror.linux.org.au/pub/linux.conf.au/2014/Friday/104-D-Bus_in_the_kernel_-_Lennart_Poettering.mp4

d-bus - IPC system for Linux
  Better than pipes etc...
    Method Call Transactions - call method on another service and get an answer
    Signals - Send messages to notify rest of system
    Properties - Can notify others about changes in properties. makes it language -like OO
    Broadcasting
    Discovery - which services, what's available
    Introspection - can look at the service and find its signals, properties etc.
    Policy - security
    Activation - System runs with minimal resource usage. At boot up you don't have to start all the services - delay until they're needed
    Synchronisation - Discovery via names, and names can be used as mutexes
    Time-safe Marshalling - FIFOs make no requirement as to what's transferred but d-bus is more strict - must define a binary presentation of your objects you're sending.
    Security - you can query the identity of everyone on the system
    Monitoring
    Exposes APIs not streams
    File Descriptor Passing - pass resources across security boundaries
    Language agnostic
    High-level error concept

Limitations
  Can send huge amounts of data. So can use it for control but not payload (e.g. sound server control but not audio)
  A little inefficient.
  Credentials on can send/recv are limited
  No implicit time-stamping
  Only available in late boot

kdbus - Like a re-implementation of d-bus that solves:
    Suitable for large data, zero-copy, optionally reusable
    More efficient that classic d-bus
    Better, more comprehensive credentials - uid pid, gid, selinux etc etc
    Implicit time-stamping
    Always available from earliest boot to latest shut down
    Race-free exit-on-idle for bus activated services

  Character bus in /dev
  You can memory map the file descriptor to set up a memory arena where kernel drops messages


http://0pointer.net/blog/the-new-sd-bus-api-of-systemd.html
https://www.linux.com/learn/here-we-go-again-another-linux-init-intro-systemd
https://www.linux.com/learn/understanding-and-using-systemd
https://www.linux.com/blog/learn/intro-to-linux/2018/5/writing-systemd-services-fun-and-profit
https://learn.adafruit.com/running-programs-automatically-on-your-tiny-computer/systemd-writing-and-enabling-a-service</pre>
      </div>

      <h2>Setup/Install SSH Daemon for SSH access</h2>
      <div>
         <pre>$sudo apt update
$ sudo apt install openssh-server   # Instal the server
$ sudo systemctl status ssh         # Make sure its running

# Root login and password based authentication enabled by default
# Security practice is to disable both and require users to provide keys.

$ sudo vi /etc/ssh/sshd_config
# Change ChallengeResponseAuthentication to &quot;no&quot;
#        PasswordAuthentication to &quot;no&quot;
#        UsePAM to &quot;no&quot;
#        PermitRootLogin to &quot;no&quot;
#        PermitRootLogin to &quot;prohibit-password&quot;

$ sudo /etc/init.d/ssh reload
# OR
$ sudo systemctl reload ssh</pre>
      </div>

	  <h2>Sed</h2>
	  <div>
		<h3>Intro</h3>
		<p>
			Sed applies each command to line 1, then each command to line 2 and so on. Each line of input is held in the <em>pattern space</em>, a small temporary buffer where commands are applied. The basic command flow is shown below but it does not account
			for commands that can alter flow control etc.
		</p>
		<p>
			<img src="##IMG_DIR##/sed_basic_flow.png" alt="Diagram of Sed data flow"/>
		</p>
		<p>
			So if there is a file with the following contents:
		</p>
		<pre>jeh-tech</pre>
		<p>
			And we use the following script:
		</p>
		<pre>s/jeh/JEH/
s/jeh/DOH/</pre>
		<p>The output would be</p>
		<pre>JEH-tech</pre>
		<p>
			This is because the line <code>jeh-tech</code> is read into the pattern buffer. The first 
			replace command changes the string to <code>JEH-tech</code>, which means that the second 
			command does not match so no replacement is made.
		</p>
		<p>
			Sed will apply commands to every line. To stop this behaviour Sed must be told which lines
			to match by suppling zero through two <em>addresses</em> (which can be regular expressions 
			or line numbers etc).
		</p>
		<p>
			The general syntax is:
		</p>
		<pre>[address[, address]]command</pre>
		<p>
			Or...
		</p>
		<pre>[address[, address]] { 
command
command
...
command
} # << Ending brace must be on it's own line.</pre>
		<p>
			The above applies multiple commands to each line matching the main address (and possibly sub addresses). 
		</p>
		<p>
			Addresses always require a slash (/) as a delimeter.
		</p>
		<p>
			<ul>
				<li>No address = command applied to each line,</li>
				<li>One address = applied to any line matching,</li>
				<li>
					<p>
						Two comma seperated address = command applied to first line matching first address 
						and all lines until (including) line matching second address. For example, using 
						the following script:
					</p>
					<pre>/^START/,/^END/ {
   s/jeh/JEH/
}</pre>
					<p> Applied to the following file:
					</p>
					<pre>jeh-tech
START
jeh-tech
jehtest
END
jeh-tech</pre>
					<p>Sed would output the following:
					</p>
					<pre>jeh-tech
START
<b>JEH</b>-tech
<b>JEH</b>test
END
jeh-tech</pre>
					<p>Note how the text subsitution that capitalised the letters <code>jeh</code>
					 	is only applied to lines between <code>START</code> and <code>END</code>.
					</p>
				</li>
				<li>Address suffixed by ! = command applied to lines not matching.</li>
			</ul>
		</p>

		<h3>Substitution</h3>
		<p>
			The substituion command looks like this:
		</p>
		<pre>[address]s/search_pat/replace/flags</pre>
		<p>
			Command delimeter can be any character, you don't have to use slash (/). Note, you have to use slashes 
			for addresses, however.
		</p>
		<p>
			The following meta-characters can be used in the replacement string:
		</p>
		<p>
			<table>
				<tr><td>&amp;</td><td>Replaced by the string matched by the regular expression.</td></tr>
				<tr><td>\n</td><td>Matches n<sup>th</sup> substring match by &quot;\(&quot; and &quot;\)&quot;.</td></tr>
				<tr><td>\</td><td>Escapre char</td></tr>
			</table>
		</p>
		<p>
			Flags can include:
			<table>
			<tr><td>n</td><td>Number from 1 to 512: Replacement made for n<sup>th</sup> occurence of search_pat.</td></tr>
			<tr><td>g</td><td>Change all occurrences in pattern space, not just first (default behaviour)</td></tr>
			<tr><td>p</td><td>Print contents of pattern space</td></tr>
			<tr><td>w <em>file</em></td><td>Write pattern space to file</td></tr>
			</table>
		</p>
		<p>
			For example, to apply a substitution command to the second occurence of a search pattern 
			to only those lines containing the word &quot;test&quot;, one could use the following
		</p>
		<pre>/test/s/jeh/JEH/2
^^^^^ ^^^^^^^^^ ^
^^^^^ ^^^^^^^^^ 2nd occurence
^^^^^ <em>command</em>
^^^^^
<em>address</em></pre>
		<p>	
			If we applied the above to the following lines:	
		</p>
		<pre>jeh-tech-jeh
jehtest
jehtestjeh</pre>
		<p>
			We would get the following output:
		</p>
		<pre>
jeh-tech-jeh # Second occurence not replaced - no address "test"
jehtest      # The address "test" is present but no 2nd occurence of "jeh"
jehtestJEH   # Address "test" found and second occurence of "jeh" replaced</pre>

		<h3>Deletion</h3>
		<pre>/<em>address</em>/d</pre>
		<p>
			Deletes the entire line (contents of pattern space really) matched by <em>address</em>. A new line
			of input is then read and the script starts from the top again.
		</p>

		<h3>Append, Insert, Change</h3>
		<p>
			These are <b>multi-line</b> commands...
		</p>
		<h4>Append</h4>
		<pre># Append text after current line in pattern space
[<em>line-address</em>]<b>a</b>\
text1\ #< To insert multiple lines use more backslashes
text2</pre>
		<p>
			For example, operating on the following file:
		</p>
		<pre>jeh-tech-jeh
jehtest</pre>
		<p>
			Using the insert command:
		</p>
		<pre>/test/a\
Text to be inserted</pre>
		<p>
			Will give the following output:
		</p>
		<pre>jeh-tech-jeh
jehtest
Text to be inserted</pre>

		<h4>Insert</h4>
		<pre># Insert text before current line in pattern space
[<em>line-address</em>]<b>i</b>\
text</pre>
		<p>
			On the same file, replacing the append with an insert would give the following:
		</p>
		<pre>jeh-tech-jeh
Text to be inserted
jehtest</pre>
		<h4>Change</h4>
		<pre># Change contents of pattern space
[<em>address</em>]<b>c</b>\
text</pre>
		
		<h3>Transform</h3>
		<pre>[<em>address</em>]<b>y</b>/abc/xyz/</pre>

		<h3>Printing</h3>
		<pre>p</pre>
		<p>
			Normally just on its own. It prints the contents of the pattern buffer.
		</p>
		<pre>[<em>address</em>]=</pre>
		<p>
			The above will print the line number of the match.
		</p>

		<h3>Multiple Lines</h3>
		<h4>Joining Lines</h4>
		<p>
			To append a new line (with new line character) to the pattern space use the <code><b>N</b></code> 
			command. Meta character &quot;<code>^</code>&quot; matches the start of the <em>first</em> line.
			The meta character &quot;<code>$</code>&quot; matches the very last end-of-line missing all intermediate
			new lines.
		</p>
		<p>
			To find the string &quot;See chapter eight for more details&quot;, and replace &quot;eight&quot; with,
			say, &quot;nine&quot; we may have to use a multi-line match if the string could be split across two
			lines. To find it you need to use this:
		</p>
		<pre>s/See chapter eight for more details/See chapter nine for more details/g
/See/ {
   $!N  # Use $! to make 'N' more 'friendly'
   s/ *\n//g
   s/See chapter eight for more details/See chapter nine for more details/g
}</pre>
		<p>
			The above could be refined quite a bit because it will mess up the output line splitting
			a little, but beyond the amount of time I want to spend on this.
		</p>
		<p>
			The command <code>N</code> will cause Sed to quit if there is no next line. The current line
			won't even be printed out. <b>To get around this use <code>$!N</code></b>... it's a more
			friendly behaviour.
		</p>

		<h3>The Hold Space</h3>
		<p>
			The <b>hold space</b> is a little side buffer that can have the contents of the pattern 
			space copied into it and vice versa.

			<table>
				<tr><td>h or H</td><td>Copy or append pattern space into hold space</td></tr>
				<tr><td>g or G</td><td>Copy or append hold space into pattern space</td></tr>
				<tr><td>x</td><td>Exchange pattern space contents with hold space</td></tr>
			</table>
		</p>

		<h3>Analysis Of Some One Liners</h3>
		<p>
			Eric Pement has made a <a href="http://sed.sourceforge.net/sed1line.txt" target="_blank">compilation 
			of some useful Sed one liners</a>. I thought we could use the above notes to try and understand
			some of them...
		</p>
		<pre># insert a blank line above and below every line which matches "regex"
sed '/regex/{x;p;x;G;}'</pre>
		<p>
		 	The line in the pattern buffer matches regex. It is placed onto the hold space using the &quot;x&quot;
		 	command (the hold space is empty). Then contents of pattern space, which is now empty, is printed, 
		 	so a blank line gets output. Exchange back and append the contents of the hold space (blank) into pattern space,
			effectively appending a blank line. So a blank line gets inserted before and after the line matching
			regex! Clever Eric :)
		</p>
		<pre># number each line of a file (simple left alignment).
sed = filename | sed 'N;s/\n/\t/'</pre>
		<p>
			The first sed command prints the line number of the match (and every line is matched), then a newline,
			then the contents of the matched line. This is piped into a new sed which then re-joins these lines and
			replaces the embeddewd new line created with a tab.
		</p>
		<pre># join pairs of lines side-by-side (like "paste")
sed '$!N;s/\n/ /'</pre>
		<p>
			This one is interesting because it does pairs of lines. It doesn't just join every single line.
			The reason is the way the command &quot;N&quot; functions. First line read into pattern space.
			Second line appended into pattern space. Then embedded newline replaced by a space. Then next line
			from file (now the third line) is then read into the pattern space and the process continues. Hence
			paris of lines being joined.
		</p>
		<pre> # print only lines which match regular expression (emulates "grep")
 sed -n '/regexp/p'           # method 1
 sed '/regexp/!d'             # method 2</pre>
	 	<p>
	 		The command <code>sed -n</code> stops the automatic printing of the pattern space.
	 	</p>
	  </div> <!-- End Sed notes -->


    <h2>Screen Sessions</h2>
    <div>
      <p>
        When SSH'ing into you Linux machine, if you leave the terminal alone for too long it will
        disconnect, which could kill a long-running application you've set up. Soloution is to use
        the screen utility <a href="https://www.howtoforge.com/linux_screen" target="_blank">[Ref]</a>.
      </p>
      <h3>Cheat Sheet</h3>
      <pre>screen # Start screen session
       # Ctrl+a, c   - Create new screen.
       # Ctrl+a, n   - Switches to next screen.
       # Ctrl+a, p   - Switches to previous screen.
       # Ctrl+a, d   - Detaches a screen session (session keeps running in bg).
       # Ctrl+a, ESC - Allows you to move cursor around screen - copy/scrollback mode.
                       Can use vim-like search syntax...
                       When in copy mode these keys are useful...
                          - B|b, E|e       - move the cursor WORD by WORD
                          - Ctrl+b, Crel+f - scroll the display up/down a full screen.
       # Ctrl+a, r   -   Toggle the current window's line-wrap setting.
       # Ctrl+a, *   - List users connected to your screen session.
       # Ctrl+a, w   - List all windows.
       # Ctrl+a, :   - Enter command mode.</pre>

      <h3>Name Your Session</h3>
      <p>
        By default screen just assigns your session a name that is rather non-descriptive.
        To give it a more meaningful name, use the <code>-S</code> option:
      </p>
      <pre>&gt; screen -S jehtech
&gt; screen -ls
9240.jehtech    (07/21/17 08:35:01)     (Attached)</pre>

      <h3>View Available Screens</h3>
      <p>
        If you detach a screen session you can see a list of available sessions using:
      </p>
      <pre>screen -ls</pre>
      <h3>Reconnect To A Screen</h3>
      <p>
        Reconnect to one of them using:
      </p>
      <pre>screen -r xxxx</pre>
      <h3>Are You On A Screen Or A Real Terminal</h3>
      <p>
        To find out if you are running in a screen or a real terminal type:
      </p>
      <pre>echo $STY</pre>
      <p>
        If the result is an empty string then you're on a real terminal.
      </p>
      <p>
        To find out who else is connected to your screen session you can either use
        <code>ctrl+a, *</code> or the <code>lsof</code> command that displays information about 
        files opened by processes.
      </p>
      <h3>Detatch A Screen</h3>
      <p>
        To detach an attached screen, enter:
       </p>
      <pre>screen -D [<i>screenName</i>]</pre>
    </div> <!-- END Screen sessions -->

   
   <h2>Barrier - Software KWM</h2>
   <div>
      <p>
         Configure the SLL certificates on both client and server using this:
      </p>
      <pre>
         See https://stackoverflow.com/a/67343805
         mkdir -p Fingerprints
         openssl req -x509 -nodes -days 365 -subj /CN=barrier -newkey rsa:4096 -keyout Barrier.pem -out Barrier.pem
         openssl x509 -fingerprint -sha1 -noout -in Barrier.pem > Fingerprints/Local.txt
         sed -e "s/.*=//" -i Fingerprints/Local.txt
      </pre>
      <p>
         The configure server with exact name of client to allow client to connect.
      </p>
      <p>
         Note, at the time of writing, Dec 2022, Barrier does <b>not support the Wayland display server</b>. To use it you must use Ubuntu with X11.
      </p>
   </div>
   
   
   </div> <!-- END H1 padding div -->
   </div>
</body>
</html>



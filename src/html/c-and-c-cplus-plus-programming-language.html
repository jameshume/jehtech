<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>The C and C++ Programming Languages | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
	<div id="header">
		-- This is JEHTech --
	</div>

	<div id="sidebar">
		<h1 class="title">Links...</h1>
		<div id="includedContent"></div>
	</div>

	<div id="content">
	<h1 class="title">The C and C++ Programming Languages</h1>
    <p>
        Page presents notes on various C and C++ features, for example C++11 rvalue references, using
        the C preprocessor for stringization etc etc...
    </p>
	<div style="padding-right:10px;">
		<h2>Page Contents</h2>
		<div id="page_contents">
		</div>

		<h2>References</h2>
		<div>
			<ol>
				<li><a href="http://sourceforge.net/p/predef/wiki/Home/"
					target="_blank">Well Known Pre-Define Compiler Macros</a>.
				</li>
				<li>
					<a href="http://gcc.godbolt.org/" target="_blank">
					Compiler Explorer</a>
				</li>
				<li>
					<a href="http://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/"
						target="_blank">Introducing the Move Constructor</a>, by Smart Bear Software.
				</li>
				<li>
					<a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/"
						target="_blank">C++11 Biggest Changes</a>, by Smart Bear Software.
				</li>
                <li>
                    <a href="http://books.goalkicker.com/CPlusPlusBook/CPlusPlusNotesForProfessionals.pdf"
                        target="_blank">C++ Notes for Professionals Book</a>, GoalKicker.com.
                </li>
				<li>
					Distcc - Distributed Compiling
					<ul>
						<li><a href="https://github.com/distcc/distcc" target="_blank">distcc -- a free distributed C/C++ compiler system</a>.
						</li>
						<li><a href="http://www.linuxjournal.com/article/9814" target="_blank">Distributed Compiling with distcc</a> - Linux Journal.
						</li>
					</ul>
				</li>
			</ol>
		</div> <!-- END H2: References -->

		<h2>Todo/To Read</h2>
		<div>
			<ul>
				<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#More%20on%20A&&" target="_blank">A Proposal to Add Move Semantics Support to the C++ Language</a></li>
				<li><a href="http://www.drdobbs.com/move-constructors/184403855" target="_blank">Move Constructors</a></li>
				<li><a href="http://erdani.com/publications/traits.html" target="_blank">Traits: The else-if-then of Types</a></li>
				<li><a href="http://erdani.com/publications/xp2000.pdf" target="_blank">The Design Is In The Code</a></li>
				<li><a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758" target="_blank">Generic: Change the Way You Write Exception-Safe Code — Forever</a></li>
				<li><a href="https://smartbear.com/blog/develop/the-biggest-changes-in-c11-and-why-you-should-care/" target="_blank">The Biggest Changes in C++11 (and Why You Should Care)</a></li>
				<li><a href="https://lhcb.github.io/developkit-lessons/first-development-steps/05a-cpp11.html" target="_blank">New features in C++11 for LHCb Physicists</a></li>
				<li><a href="https://www.stroustrup.com/C++11FAQ.html#language" target="_blank">C++11 - the new ISO C++ standard</a></li>
				<li>Good sockets tutorial - http://beej.us/guide/bgnet/html/single/bgnet.html</li>
                <li>http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html</li>
                <li>http://www.alexonlinux.com/signal-handling-in-linux</li>
                <li>http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html</li>
                <li>http://www.informit.com/articles/article.aspx?p=397655&amp;seqNum=6</li>
                <li>https://computing.llnl.gov/tutorials/pthreads/</li>
                <li>http://stackoverflow.com/questions/17954432/creating-a-daemon-in-linux</li>
                <li>https://www.freedesktop.org/software/systemd/man/daemon.html</li>
                <li>http://advancedlinuxprogramming.com/alp-folder/</li>
                <li>https://linux.die.net/man/3/daemon</li>
                <li>http://stackoverflow.com/questions/22409780/flock-vs-lockf-on-linux</li>
                <li>https://balau82.wordpress.com/2010/10/06/trace-and-profile-function-calls-with-gcc/</li>
                <li>https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html</li>
                <li>https://en.wikipedia.org/wiki/Restrict</li>
                <li>http://www.inf.ed.ac.uk/teaching/courses/copt/</li>
                <li>http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html</li>
                <li>std::find and std::remove to delete from vector (http://stackoverflow.com/questions/39912/how-do-i-remove-an-item-from-a-stl-vector-with-a-certain-value)</li>
                <li>http://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords</li>
                <li>Casts and inheritance static vs dynamic -- http://ideone.com/J7hUIw</li>
                <li>Access specifier on inheritance - https://ideone.com/gg19T4</li>
                <li>https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/</li>
                <li>http://stackoverflow.com/questions/2784262/does-a-const-reference-prolong-the-life-of-a-temporary</li>
                <li>http://ideone.com/0Ff84V</li>
                <li>http://stackoverflow.com/questions/4908539/a-way-in-c-to-hide-a-specific-function</li>
                <li>https://en.wikipedia.org/wiki/Double_dispatch</li>
                <li>https://en.wikipedia.org/wiki/Virtual_method_table</li>
                <li>http://stackoverflow.com/questions/1872220/is-it-possible-to-iterate-over-arguments-in-variadic-macros</li>
                <li>https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-</li>
                <li>https://github.com/isocpp/CppCoreGuidelines</li>
                <li>http://stackoverflow.com/questions/9599807/how-to-add-indention-to-the-stream-operator</li>
                <li>http://stackoverflow.com/questions/411103/function-with-same-name-but-different-signature-in-derived-class<br>and my test http://ideone.com/BPeDtm</li>
                <li>https://vimeo.com/97337253</li>
                <li>https://vimeo.com/97337258</li>
                <li>https://vimeo.com/97329153</li>
                <li>https://vimeo.com/97318797</li>
                <li>https://vimeo.com/97315939</li>
                <li>https://vimeo.com/68390510</li>
                <li>https://vimeo.com/68390509</li>
                <li>https://vimeo.com/68390478</li>
                <li>https://github.com/Kitware/KWStyle</li>
                <li>http://www.suodenjoki.dk/us/archive/2010/cpp-checkstyle.htm</li>
                <li>https://stackoverflow.com/questions/5195990/using-boostaccumulators-how-can-i-reset-a-rolling-window-size-does-it-keep-e</li>
                <li>https://eli.thegreenplace.net/2014/variadic-templates-in-c/</li>
                <li>https://stackoverflow.com/questions/24371868/why-must-a-short-be-converted-to-an-int-before-arithmetic-operations-in-c-and-c</li>
                <li>https://stackoverflow.com/questions/490773/how-is-the-c-exception-handling-runtime-implemented</li>
                <li>https://www.jjj.de/fxt/ - FXT: a library of algorithms</li>
                <li>https://secure-media.collegeboard.org/apc/ap01.pdf.lr_7928.pdf</li>
                <li>https://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html</li>
                <li>http://www.hboehm.info/gc/ - garbage collected for c/c++??</li>
                <li>ftp://ftp.sas.com/techsup/download/SASC/share5958-59/S5958v2.pdf</li>
                <li>http://www.eecs.umich.edu/courses/eecs489/w07/LectureSlides/socketProgramming.pdf</li>
                <li>http://tldp.org/LDP/lpg/node11.html</li>
                <li>https://blog.smartbear.com/codereviewer/c11-a-new-c-standard-aiming-at-safer-programming/</li>
                <li>http://fileadmin.cs.lth.se/cs/education/EDAN25/F06.pdf</li>
                <li>http://www.drdobbs.com/cpp/c-finally-gets-a-new-standard/232800444</li>
                <li>http://www.drdobbs.com/cpp/the-new-c-standard-explored/232901670?pgno=2</li>
                <li>http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1516.pdf</li>
                <li>https://stackoverflow.com/questions/1393443/setjmp-longjmp-and-local-variables</li>
                <li>https://hackerboss.com/overriding-system-functions-for-fun-and-profit/</li>
                <li>https://github.com/angrave/SystemProgramming/wiki/Signals,-Part-2:-Pending-Signals-and-Signal-Masks</li>
                <li>https://www.gnu.org/software/global/</li>
                <li>https://github.com/jsfaint/gen_tags.vim</li>
                <li>https://github.com/universal-ctags/ctags</li>
                <li>https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule</li>
                <li>https://opensourceforu.com/2015/03/be-cautious-while-using-bit-fields-for-programming/</li>
			</ul>
		</div>

		<h2>Online Work Pads (Compilers and Code Analysers)</h2>
		<p>
			The following are quite good online &quot;work pads&quot; for testing out snippets of code and
			investigating the behaviour of a bit of code across several compilers (or at least versions of).
		</p>
		<ul>
			<li><a href="http://ideone.com" target="_blank">http://ideone.com</a></li>
			<li><a href="http://coliru.stacked-crooked.com" target="_blank">http://coliru.stacked-crooked.com</a></li>
			<li><a href="http://webcompiler.cloudapp.net" target="_blank">http://webcompiler.cloudapp.net</a> - for microsoft VC only</li>
			<li><a href="http://rextester.com/runcode" target="_blank">http://rextester.com/runcode</a></li>
			<li><a href="http://www.onlinegdb.com" target="_blank">http://www.onlinegdb.com</a></li>
			<li><a href="https://wandbox.org" target="_blank">https://wandbox.org</a></li>
            <li><a href="http://cpp.sh/" target="_blank">cpp.sh</a></li>
            <li><a href="http://quick-bench.com/" target="_blank">CPP Code Benchmarking</a>.</li>
			<li><a href="https://cppinsights.io/" target="_blank">C++ Insights:</a> See your source code with the eyes of a compiler!</li>
		</ul>
		<p>
			To compare compilers and view the output assembler try there:
		</p>
		<ul>
			<li><a href="https://godbolt.org" target="_blank">https://godbolt.org</a></li>
		</ul>

        <h2>Compilation Flags (GCC)</h2>
        <div>
            <p>
                Useful flags, mostly warning-enablers, to add to builds...
            </p>
            <table class="jehtable">
                <thead>
                    <tr>
                        <td>Option</td><td>Meaning</td>
                    </tr>
                </thead>
                <tr><td><code>-D</code></td>                        <td>Define macro on the command line.</td></tr>
                <tr><td><code>-E</code></td>                        <td>Produces only the preprocessor output.</td></tr>
                <tr><td><code>-fcheck-pointer-bounds</code></td>    <td>Enable Pointer Bounds Checker instrumentation. Each memory reference is instrumented with checks of the pointer used for memory access against bounds associated with that pointer. </td></tr>
                <tr><td><code>-fPIC</code></td>                     <td>For shared libraries produce position independent code.</td></tr>
                <tr><td><code>-g</code></td>                        <td>For debug information.</td></tr>
                <tr><td><code>-O[s0-?]</code></td>                  <td>Optimize for space or speed.</td></tr>
                <tr><td><code>-pedantic-errors</code></td>          <td>Turns -pedantic warnings into errors.</td></tr>
                <tr><td><code>-pedantic</code></td>                 <td>Issue all the warnings demanded by strict ISO C.</td></tr>
                <tr><td><code>-pedantic</code></td>                 <td>Requires Strict ISO C[++] and reject forbidden language extensions.</td></tr>
                <tr><td><code>-rdynamic</code></td>                 <td></td></tr>
                <tr><td><code>-S</code></td>                        <td>Produces only the assembly code. Combine this with <code>-fverbose-asm</code> to add informative comments to the assembly output.</td></tr>
                <tr><td><code>-Wall</code></td>                     <td>Enable all the warnings about constructions that some users consider questionable, and that are easy to avoid etc. (See GCC docs for list).</td></tr>
                <tr><td><code>-Wcast-align=strict</code></td>       <td>Warn whenever a pointer is cast such that the required alignment of the target is increased regardless of the target machine.</td></tr>
                <tr><td><code>-Wcast-qual</code></td>               <td>Warn whenever a pointer is cast so as to remove a type qualifier from the target type.</td></tr>
                <tr><td><code>-Wconversion</code></td>              <td>Warn for implicit conversions that may alter a value.</td></tr>
                <tr><td><code>-Wdouble-promotion</code></td>        <td>Give a warning when a value of type float is implicitly promoted to double.</td></tr>
                <tr><td><code>-Wduplicated-branches</code></td>     <td>Warn when an if-else has identical branches.</td></tr>
                <tr><td><code>-Wduplicated-cond</code></td>         <td>Warn about duplicated conditions in an if-else-if chain.</td></tr>
                <tr><td><code>-Werror</code></td>                   <td>Make all warnings into errors.</td></tr>
                <tr><td><code>-Wextra</code></td>                   <td>Enable some extra warning flags not enabled by -Wall. (See GCC docs for list).</td></tr>
                <tr><td><code>-Wfloat-conversion</code></td>        <td>Warn for implicit conversions that reduce the precision of a real value.</td></tr>
                <tr><td><code>-Wfloat-equal</code></td>             <td>Warn if floating-point values are used in equality comparisons. .</td></tr>
                <tr><td><code>-Wmisleading-indentation</code></td>  <td>Warn when the indentation of the code does not reflect the block structure.</td></tr>
                <tr><td><code>-Wno-long-long</code></td>            <td>Do NOT warn if long long type is used.</td></tr>
                <tr><td><code>-Wpointer-arith</code></td>           <td>Warn about anything that depends on the “size of” a function type or of void.</td></tr>
                <tr><td><code>-Wshadow</code></td>                  <td>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member etc.</td></tr>
                <tr><td><code>-Wsign-conversion</code></td>         <td>Warn for implicit conversions that may change the sign of an integer value.</td></tr>
                <tr><td><code>-Wswitch-default</code></td>          <td>Warn whenever a switch statement does not have a default case.</td></tr>
                <tr><td><code>-Wuninitialized</code></td>           <td></td></tr>
                <tr><td><code>-Wunused-macros</code></td>           <td>Warn about macros defined in the main file that are unused.</td></tr>
                <tr><td><code>-Wwrite-strings</code></td>           <td>When compiling C, give string constants the type const char[length] so that copying the address of one into a non-const char * pointer produces a warning.</td></tr>
            </table>
            <p></p>
        </div>

		<h2>Debugging</h2>
		<div>
			<h3>Instrumenting Functions</h3>
			<p>Use GCC compiler option &quot;<code>-finstrument-functions</code>&quot; and implement these functions:</p>
			<pre>void __cyg_profile_func_enter (void *, void *) __attribute__((no_instrument_function));
void __cyg_profile_func_exit (void *, void *) __attribute__((no_instrument_function));</pre>
			<p>For Windows see this <a href="https://stackoverflow.com/a/24416858/1517244" target="_blank">SO thread</a>. It shows how to use
				the <code>/Gh</code> and <code>/GH</code> penter/pexit hooks.
			</p>
			<h3>Valgrind</h3>
			<pre>valgrind \
    --tool=memcheck \
    --track-origins=yes \
    --num-callers=30 \
    --leak-check=full \
    --show-reachable=yes \
    --leak-resolution=high \
    --trace-children=yes \
    -v \
    path/to/binary &lt;args for binary&gt;</pre>
		</div>

        <h2>Tagging Your Source Code: GNU Global</h2>
        <div>
            <h3>References</h3>
            <ul>
                <li><a href="https://www.gnu.org/software/global/" target="_blank">GNU GLOBAL Source Code Tagging System</a>, Offical GNU Global Page.</li>
            </ul>


            <h3>Install</h3>
            <p>
                Check for the most recent version and use commands like this:
            </p>
            <pre>mkdir deleteme
pushd deleteme/
wget http://tamacom.com/global/global-6.6.2.tar.gz
tar xvf global-6.6.2.tar.gz
cd global-6.6.2/
./configure
make all
sudo make install
popd
rm -fr deleteme</pre>

            <h3>Cheat Sheet</h3>
            <p>All the <code>global</code> commands must be run from within your project directory structure. I.e., from the root directory or a subdirectory.</p>
            <table>
                <tr>
                  <td>Build Index:</td>
                  <td><code>gtags</code><br/>Must be run from project ROOT! Requires considerable disk space!</td>
                </tr>
                <tr>
                  <td>Find something:</td>
                  <td><code>global &quot;<i>posix regular expr</i>&quot;</code></td>
                </tr>
                <tr>
                  <td>Find references:</td>
                  <td><code>global -r ...</code></td>
                </tr>
                <tr>
                  <td>Include details:</td>
                  <td><code>global -x ...</code></td>
                </tr>
                <tr>
                  <td>Find lines matching pattern:</td>
                  <td><code>global -g &quot;<i>posix regular expr</i>&quot;</code></td>
                </tr>
                <tr>
                  <td>Only search CWD:</td>
                  <td><code>global -l ...</code></td>
                </tr>
                <tr>
                  <td>Invert match:</td>
                  <td><code>global -V ...</code></td>
                </tr>
                <tr>
                  <td>Case insensitive matches:</td>
                  <td><code>global -i ...</code> (<em>not</em> default!)</td>
                </tr>
                <tr>
                  <td>Definitions:</td>
                  <td><code>global -d ...</code></td>
                </tr>
                <tr>
                  <td>Auto complete:</td>
                  <td><code>global -c ...</code></td>
                </tr>
                <tr>
                  <td>Update tag files incrementally:</td>
                  <td><code>global -u</code> (can be done from any dir)</td>
                </tr>
                <tr>
                  <td>Update gtags for specific file:</td>
                  <td><code>gtags --file <i>file</i></code></td>
                </tr>
            </table>
            <p></p>
			<h3>Comparison to other solutions</h3>
			<p>https://github.com/oracle/opengrok/wiki/Comparison-with-Similar-Tools</p>
        </div>

        <h2>Static Analysers</h2>
        <div>
            <h3>scan-build</h3>
            <p>
            https://askubuntu.com/questions/1033808/how-can-clang-static-analyzer-scan-build-be-installed-on-ubuntu-18-04
            </p>
            <h3>CPPCheck</h3>
            <p>
                https://stackoverflow.com/questions/27552188/how-do-i-install-cppcheck-using-the-tar-file-on-linux
            </p>
            <h3>FlawFinder</h3>
            <p>
                https://dwheeler.com/essays/static-analysis-tools.html
            </p>
        </div>

        <h2>Coding Standards / Guidelines</h2>
        <div>
			<ul>
				<li><a href="https://github.com/isocpp/CppCoreGuidelines" target="_blank">CppCoreGuidelines on GitHub</a>, Bjarne Stroustrup and Herb Sutter</li>
				<li><a href="http://www.misra-c.com/Activities/MISRAC/tabid/160/Default.aspx" target="_blank">MISRA C:2012 Guidelines for the Use of the C Language in Critical Systems</a></li>
				<li><a href="https://web.eecs.umich.edu/~imarkov/10rules.pdf" target="_blank">NASA, The Power of 10: Rules for Developing Safety-Critical Code</a></li>
				<li><a href="http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf" target="_blank">JPL, Institutional Coding Standard for the C Programming Language/a></li>
				<li><a href="https://www.cesg.gov.uk/guidance/coding-requirements-and-guidance-ia-developers-note-6" target="_blank">CESG, Coding Requirements and Guidance (IA Developers' Note 6)</a></li>
				<li><a href="https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank">SEI CERT, C Coding Standard</a></li>
				<li><a href="https://cwe.mitre.org/top25/index.html" target="_blank">CWE/SANS, Top 25 Most Dangerous Software Errors</a></li>
			</ul>
        </div>

		<h2>Preprocessor Stringization</h2>
		<div>
		<h3>Stringize Parameter Tokens</h3>
		<p>
			To convert the expression passed as a macro parameter to a string use the # operator:
			<blockquote>
				<p>
					If ... a parameter is immediately preceded by a # ... both are replaced by a
					single character string literal preprocessing token that
					contains the spelling of the preprocessing token sequence for the corresponding
					argument.
				</p>
				<footer>Section 6.10.3.2, C99 standard.</footer>
			</blockquote>
		</p>
		<p>
			In fact, the standard goes on to mention other conditions such that &quot;<code>#x</code>&quot;
			is replaced with the result of the pseudo code &quot;<code>strip(escape(collapse_consequtive_whitespace(string(arg)))</code>&quot;.
			The macro argument in the replacement list is first converted to a string. Any consecutive
			whitspace sequences are converted to just one whitespace, then &quot; is espaced to \&quot;,
			then any preceeding or trailing whitespace is stripped.
		</p>

		<p>
			It is the above beviour that allows the following (contrived example) to work:
		</p>
		<pre class="prettyprint linenums">#include &lt;stdio.h&gt;

#define str(x) #x

int main(void) {
	printf(str(jehtech      says "hi" \t to you all));
	return 0;
}
/*
 * Printf preprocesses to (use -E gcc option):
 *    printf("jehtech says \"hi\" \t to you all");
 *                  ^^^    ^^
 *                  ^^^    Notice how &quot; has been replaced with \&quot;
 *                  Notice how whitespace has been collaped
 * OUTPUTS:
 *    jehtech says "hi" <i>&lt;tab-char&gt;</i> to you all
  */</pre>
		<p>
			Notice how the whitespace between &quot;jehtech&quot; and &quot;says&quot; has been
			collapsed into one space and how the &quot; has been escaped to \&quot; (must have been
			otherwise we'd get a compile error).
		</p>

		<div class="box_container">
			<div class="info">
				<p><b>#x</b> in a macro replacement list is replaced by the result of the pseudo code &quot;<b><code>strip(escape(collapse_consequtive_whitespace(string(arg)))</code></b>	&quot;</p>
			</div>
		</div>

		<p>
			For (another) example, the following defines (a rather junk, but served to illustrate) assert macro:
		</p>
		<pre class="prettyprint linenums">#include &lt;stdio.h&gt;

#define ASSERT_EQ(exp, val) \
do { \
   if ((exp) != (val)) \
      fprintf(stderr, "ASSERTION FAILURE: " #exp " != " #val); \
      exit(1); \
} while(0)

int main(void)
{
	ASSERT_EQ(4 + 5, 1);
	return 0;
}
/*
 * Outputs to STDERR:
 *    ASSERTION FAILURE: 4 + 5 != 1
 */</pre>
		<p>
			In the macro line <code>fprintf(stderr, "ASSERTION FAILURE: " #exp " != " #val)</code>,
			the parameters <code>exp</code> and <code>val</code> are preceded by a #. The preprocessor
			evaluated the macro use and replaces <code>#exp</code> with the string containing preprocessing token sequence:
			 &quot;4 + 5&quot;. Same for <code>#val</code>. Hence the output of the program.
		</p>

		<h3>Glue Parameter Tokens</h3>
		<p>
			Another very useful feature is the ability to glue tokens together using ##:
		</p>
		<p>
			<blockquote>
				<p>
					If ... a parameter is immediately preceded or followed by a ## preprocessing
					token, the parameter is replaced by the corresponding argument’s preprocessing
					token sequence ...
				</p>
				<footer>Section 6.10.3.3, C99 standard.</footer>
			</blockquote>
		</p>
		<p>
			One example of how you might &quot;glue&quot; a parameter's token sequence together
			with other tokens is shown below.
		</p>
		<pre class="prettyprint linenums">#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;

#define DEF_STRUCT_FOR_OFFSET(type) \
struct type##OffsetStruct { \
   char dummy; \
   type value; \
}

DEF_STRUCT_FOR_OFFSET(int);
DEF_STRUCT_FOR_OFFSET(long);
DEF_STRUCT_FOR_OFFSET(double);

int main(void)
{
   printf("Alignment required for int is %d bytes\n", offsetof(struct intOffsetStruct, value));
   printf("Alignment required for long is %d bytes\n", offsetof(struct longOffsetStruct, value));
   printf("Alignment required for double is %d bytes\n", offsetof(struct doubleOffsetStruct, value));
   return 0;
}
/*
 * The line &quot;DEF_STRUCT_FOR_OFFSET(int);&quot; expands to:
 *    struct intOffsetStruct { char dummy; int value; };
 *           ^^^
 *           Notice the ## glue at work
 * Same applies to the other similar lines.
 */</pre>
		<p>
			The line of interest is &quot;<code>struct type##OffsetStruct</code>. When the preprocessor
			sees a use of the macro it replaces the parameter &quot;<code>type##</code>&quot; with
			its tokens. Note, unlike a single # the tokens are <em>not</em> not converted into a string.
			They are just pasted as tokens in the program. Hence, &quot;<code>DEF_STRUCT_FOR_OFFSET(int)</code>&quot;
			declares a structure named &quot;<code>intOffsetStruct</code>&quot;. Hence the
			description of ## as &quot;glue&quot;.
		</p>
		<p>
			Note the ## tokens can surround a parameter name, so you can &quot;glue&quot; on both sides.
		</p>

		<h3>Summary Of Macro Expansion</h3>
		<p>
			<img src="##IMG_DIR##/c_proprocessing_stages.png" alt="Flow diagram describribing how c preprocessor expands macros"/>
		</p>

		<h3>Stringize The Result Of Expansion</h3>
		<p>
			If we change the example you saw for the stringize example slightly as shown below,
			we'll get a slightly unexpected outcome:
		</p>
		<pre class="prettyprint linenums">#include &lt;stdio.h&gt;

#define ASSERT_EQ(exp, val) \
do { \
   if ((exp) != (val)) \
      fprintf(stderr, "ASSERTION FAILURE: " #exp " != " #val); \
      exit(1); \
} while(0)

#define JUNK_SUM (4 + 5)

int main(void)
{
   ASSERT_EQ(JUNK_SUM, 1);
   return 0;
}
/*
 * Outputs to STDERR:
 *    ASSERTION FAILURE: JUNK_SUM != 1
 */</pre>
 		<p>
 			The output is &quot;JUNK_SUM != 1&quot;. Why was it this, and not &quot;(4 + 5) != 1&quot;?!
 		</p>
        <p>
            Let's be the preprocessor and follow the flow chart above. We find the macro invocation
            <code>ASSERT_EQ(JUNK_SUM, 1)</code> and determine that the arguments are <code>exp == JUNK_SUM</code>
            and <code>val == 1</code>. We now look through the macro's replacement token sequence.
        </p>
        <p>
            The first place in which arguments are encountered is in the line <code>if ((exp) != (val))</code>.
            Here neither argument is preceeded by a # or ##, and in the case of a ## neither is followed by a ## either.
            So, we replace the arguments in the preprocessing token sequence with the arguments fully expanded.
            Therefore <code>val</code> is replaced with <code>1</code>. As 1 is just a literal it cannot be
            expanded further. We reaplce <code>exp</code> with <code>JUNK</code>. This is another macro, so
            we fully expand that first to get <code>(4+5)</code>. This is now fully expanded (but if there
            had been any macros encountered in the expansion we would have recursively continued to expand everything).
            Thus <code>exp</code> gets replaced with <code>(4+5)</code> to yield <code>if (((4+5)) != (1))</code>.
        </p>
        <p>
            That went well. So we keep evaluating the macro's replacement token sequence. we encounter both
            <code>#exp</code> and <code>#val</code> again, except this time they are both preceeded by
            a # symbol. So now we would replace <code>#exp</code> with the result of
            <code>strip(escape(collapse_consequtive_whitespace(string(JUNK)))</code>. Ah, we just
            converted the token JUNK to the string &quot;JUNK&quot;. Ooops. Same for <code>#val</code>,
            that got expanded to the string &quot;1&quot;.
        </p>
        <p>
            Now that all the arguments in the macros replacement list have been expanded we would
            rescan for more macro names and replace, but now JUNK does not exist as a preprocessing
            token but as a plain string, so we do nothing more to it. Hence we print out &quot;ASSERTION FAILURE: JUNK_SUM != 1&quot;.
        </p>
 		<p>
 			So... in summary, the reason is that the preprocessor evaluates/strigizes <code>#exp</code> <em>before</em> expanding
 			out <code>exp</code>. Thus it gets the string &quot;JUNK_SUM&quot;. 
        </p>
        <p> BUT.... We'd like it to
 			print out &quot;(4 + 5) != 1&quot;. How can we accomplish this? The code snippet below
            shows us how...
 		</p>
 		<pre class="prettyprint linenums">#include &lt;stdio.h&gt;

<b>#define xstr(x) str(x)
#define str(x) #x</b>

#define ASSERT_EQ(exp, val) \
do { \
    if ((exp) != (val)) \
       fprintf(stderr, "ASSERTION FAILURE: " <b>xstr(exp)</b> " != " #val); \
       exit(1); \
} while(0)

#define JUNK_SUM (4 + 5)

int main(void)
{
   ASSERT_EQ(JUNK_SUM, 1);
   return 0;
}</pre>
            <p>Why does it work? In <code>xstr(exp)</code>, the argument <code>exp</code> is first
            replaced to give <code>xstr((4+5))</code>. But the expansion continues until everything is 
            fully expanded out, so now <code>xstr((4+5))</code> is expanded out to <code>#(4+5)</code>.
            Not this is expanded out to the string &quot;(4+5)&quot;. Hence we can print out 
            what was in <code>JUNK_SUM</code> instead of the string &quot;JUNK_SUM&quot;. We can
            apply to same technique for as many levels of macro as the real thing we want to stringize is
            behind :)
		</div> <!-- END H2 Preprocessor Stringization -->

		<h2>Some Play</h2>
		<div>
			<p>
				Some <a href="https://github.com/jameshume/MessingWithC/tree/master/ctest" target="_blank">little playing</a>
				in C: reading a file line by line and an enhanced strok function.
			</p>
		</div> <!-- END: H2 -->

		<h2>LValues, RValues etc </h2>
		<div>
			<h3>LValues</h3>
			<p>
				First some terminology. In C, an <b>object</b> is just a region of data storage that represents a value.
				Why does the standard talk about &quot;data storage&quot;? I think this is because we could mean RAM,
				a register, ROM or any other kind of memory. It's just a generic term; an abstraction.
			</p>
			<p>
				In the standard, an <b>expression</b> is a sequence of operators and operands that,
			</p>
			<ul>
				<li>computes a value, or</li>
				<li>results in an object (a region of data that can represent a value), or</li>
				<li>results in a function, or</li>
				<li>generates side effects, or</li>
				<li>is some combination of any of the above</li>
			</ul>
			<p>
				In C &amp; C++ an <b>lvalue</b> is defined as:
							</p>
			<blockquote>
				<p>
					An lvalue is an expression with an object type or an incomplete type other than void ...
					When an object is said to have a particular type, the type is specified by the lvalue
					used to designate the object ...
				</p>
				<p>
					... Except when it is the operand of the sizeof operator, the unary &amp; operator,
					the ++ operator, the -- operator, or the left operand of the . operator or an
					assignment operator, an lvalue that does not have array type is converted to the
					value stored in the designated object (and is no longer an lvalue) ...
				</p>
				<footer>-- ISO/IEC 9899:1999</footer>
			</blockquote>

			<p>
				What does <q>an expression with an object type</q> mean? It is just an expression
				that results in an object, i.e., an area of memory we can name (identify) in our
				program.
			</p>

			<p>
				An lvalue has to <q>designate an object</q>. This means that an lvalue has to
				be something that we can use, in our program, to locate an object. I.e. it has to
				be a name that we can use to access an area of memory that represents a value of some type:
				it is an <q>object locator</q>. It could also be thought of as <q>an address that is
					stored into</q> <a href="https://users.soe.ucsc.edu/~pohl/code/lvalue.htm" target="_blank">[Ref]</a>.
			</p>

			<p>
				Because an lvalue represents some value in data storage it can persist beyond its current expression. The lvalue
				represents a way to locate an object (region of data storage).
			</p>

			<p>
				If we assign into something, we must be assigning into an lvalue because we need to store the value in an object, i.e.,
				an area of data storage that can hold the value and that we can locate via a name in our program.
				Thus <tt>A = B</tt> requires that <tt>A</tt> be an lvalue. It must also be modifiable, so not const!
			</p>
			<p>
				So, straight away, we can tell that literals are not lvalues. For example the literal 123.321 does is not represented
				by a region of data storage. It's just a number that exists at compile time. <tt>double x = 123.321</tt> is however
				an expression that creates a region of data storage, refered to by the variable named <tt>x</tt>.
				This region of data storage represents the literal 123.321 and is therefore an lvalue.
			</p>
			<p>
				Also, lets say that a function returns a pointer to an integer, then <tt>*(some_function());</tt> must also be an lvalue
				because it yields the region of data storage that represents a value, even if we don't do anything with it.
			</p>

			<p>
				An interesting example is this:
			</p>
			<pre class="prettyprint linenums">int a = 1;
int b = 3;
a + b = 22;</pre>
			<p>
				Obviously we can't do this because we intuitively know that one cannot assign a value into
				an expression because the value <tt>a + b</tt> is just that, a temporary value. However,
				this temporary value must exist in memory, even it it is only temporarily in a register.
            </p>
            <p>
				The variables <tt>a</tt> and <tt>b</tt> are lvalues, but they may only exist in a
				register. But so would the result <code>a + b</code>, so just having some storage isn't quite enough, it would seem.
			</p>
			<p>
				The answer comes from the second paragraph in the definition: <q>an lvalue [when used as an operand] ... is converted to the
				value stored in the designated object (and is no longer an lvalue)</q>. Ah ha! In the
				expression <tt>a + b</tt>, the operands are converted to values and are no longer lvalues,
				hence the result is not an lvalue. This gives a standards-based explanation of our intuition :)
			</p>
            <p>
                The important thing to note is that the is no name (designator) that we can use to access
                the temporary value resulting from <code>a + b</code>, in this case.
            </p>
			<p>
				And to just be double sure that we're on the right track, Thomas Becker's article <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank"> C++ Rvalue References Explained</a> has this to say:
			</p>
			<blockquote>
				<p>
					An <em>lvalue</em> is an expression that refers to a memory location and allows us to take the address of that memory location via the &amp; operator.
				</p>
				<footer>-- <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank"> C++ Rvalue References Explained</a></footer>
			</blockquote>
			<p>
				C only really talks about lvalues. Rvalues are mentioned in the standard, but only once: <q>What is sometimes called rvalue is in this International Standard described
				as the value of an expression</q>. Thus rvalues are just really anything that isn't an lvalue.
			</p>
            <p>
                Scott Meyers also says a similar thing:
            </p>
            <blockquote>
                <p>
                    An lvalue is something you can typically make an assignment too, or take its address ... it <em>has a name</em> ...
                </p>
                <footer>-- <a href="https://vimeo.com/97344493" target="_blank">Scott Meyers - C++ Type Deduction and Why You Care</a></footer>
            </blockquote>
            <p>
                In <a href="https://vimeo.com/97344493" target="_blank">Scott Meyer's talk</a> 
                (admittedly about C++ but the same applies for C in the case of lvalues) he gives these
                examples:
            </p>
            <pre class="prettyprint linenums">int x = 22;
const int cx = x;</pre>
            <p>
                The variable <code>x</code> is an lvalue because it has a name, you can take its address and you can assigned to it.
            </p>
            <p>
                The variable <code>cx</code> is also an lvalue. You can't assigned to it, but it has a name and you can therefore take its address.
            </p>

			<h3>C++11: RValues, RValue References &amp; Universal References</h3>
			<p>
				First some references:
			</p>
			<ul>
				<li><a href="https://accu.org/index.php/journals/1887" target="_blank">Universal References in C++11</a>, Scott Meyers</li>
				<li><a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank">C++ Rvalue References Explained</a>, Thomas Becker</li>
			</ul>
			<p>
				C++ has quite a few more types!
			</p>

			<blockquote>
				<p>
					An <b>xvalue</b> (an eXpiring value) also refers to an object, usually near the end of its lifetime (so that its
					resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving
					rvalue references (8.3.2).
				</p>
				<p>
					A <b>glvalue</b> (generalized lvalue) is an lvalue or an xvalue.
				</p>
				<p>
					An <b>rvalue</b> ... is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated
					with an object.
				</p>
				<p>
					A <b>prvalue</b> (pure rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function
					whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is
					also a prvalue ... ]
				<p>
			</blockquote>

			<p>Oh man! Read the standards docs really isn't easy... eek!
			</p>
			<p>
				We can gleam that an rvalue is something that is <em>about to expire (its lifetime is over)</em>, 
				a temporary object (like the result of A * B, for example) or a value that is not addressable.
			</p>
			<p>
				This implies it is <em>something that is short lived</em> and won't be used or have side effects almost
				immediately after its last reference. For example, in the expression <code>a = b * c</code>,
				the result of <code>b * c</code> is a temporary object and we can't take it's address.
			</p>
			<p>
				This gives us some idea: rvalues are things we can't really access in our code in
				any meaningful way. They are transients that exist to accomplish a task. So if
				<code>b * c</code> involves two matrix classes and they both are large matricies, why
				copy the result into <code>a</code>? Why not just let <code>a</code> have the resources of the temporary result
				instead of copying the temporary into <code>a</code> and then destroying the temporary? Could save
				ourselves a huge copy operation. This is one of the key motivations for rvalue references.
			</p>

			<p>Now though, I'm going to use the referenced articles as the standard isn't something
			   that I would call a &quot;learning/teaching resource&quot;. The rest of this is just notes 
			   on the referenced, as I'm still getting to grips with the RValue and Universal references!
			</p>
            <p>
                Expanding on the previous quote by Scott Meyers:
            </p>
            <blockquote>
                <p>
                    An rvalue, generally speaking, is a <em>temporary object</em> ... Rvalues have <em>no name</em> and you <em>can’t take their address</em> ...
                </p>
                <footer>-- <a href="https://vimeo.com/97344493" target="_blank">Scott Meyers - C++ Type Deduction and Why You Care</a></footer>
            </blockquote>
            <p>
            </p>

            <h4>Continuing with Thomas Becker's article...</h4>
            <p>
                <b>Move semantics</b> means swapping resource handles between an lvalue and a temporary (rvalue).
            </p>
            <p>
                If matricies are classes with large data the code <code>matrixA = matrixB * matrixC</code>
               constructs a temporary object to represent the result of the multiplication and then copies
               that data into <code>matrixA</code>. A copy has been wasted! The temporary's resources could
               just be <em>transfered rather than copied</em>!
            </p>
            <p>
                This needs some kind of &quot;move constructor&quot;, a lot like a &quot;copy constructor&quot;,
                but which moves the resources instead of copying them. The type that allows us to do this is the
                <b>rvalue reference</b>, represented by a double ampersand (&amp;&amp;) 
                (or as Scott Meyers calls them, <b>Universal References</b> because they
                may actual refer to either an lvalue of an rvalue in some cases):
            </p>
            <pre class="prettyprint linenums">Matrix&amp; Matrix::operator=(Matrix<b>&amp;&amp;</b> rhs)
//                              ^^
//                              New type: rvalue reference
{
  // ...
  // swap this->mArrayOfValues and rhs.mArrayOfValues
  // ...
}</pre>
            <ul>
                <li>RValue references are prefered by rvalues. LValues prefer lvalue references.</li>
                <li>RValues allow a function to branch at compile time (via overload resolution) on the condition "Am I being called on an lvalue or an rvalue?"</li>
            </ul>

            <div class="box_container">
            <div class="info">
                <p>RValue references are prefered by rvalues. LValues prefer lvalue references. RValues allow a function to branch at compile time (via overload resolution) on the condition "Am I being called on an lvalue or an rvalue?"</p>
            </div>
            </div>
		</div>

		<h2>MSVC</h2>
		<div>
			<h3>C/C++ Run Time Library (RTL)</h3>
			<p>
				In MSVC projects you can either statically or dynamically link against the run time library.
				The C and C++ RTL libraries include the standard C/C++ functions that the standards
				require. So, in C, it is functions like <code>malloc()</code>, <code>memcpy()</code> etc etc,
				and in C++ it is these and the C++ STL.
			</p>
			<p>
				When using MSVC, different versions have different RTLs and for each version there
				are several variants depending on whether you are compiling for debug or release and
				whether you static vs dynamic linking. Note: there are only multi-threaded libraries
				available (there used to be single threaded but no more).
			</p>
			<p>
				To statically link against the RTL implies that the RTL code is linked into your program so
				that your program does not have any external dependencies as far as using the C/C++ standard
				library functions goes. 
			</p>
			<p>
				To dynamically link against the RTL means that your program is
				compiled without the RTL &quot;backed in&quot; and thus requires a certain
				set of DLLs, which must be present on the host when your program
				is executed. 
			</p>
			<p>
				The former has the advantage that you don't care whether your host has the 
				correct RTL installed (because your program already contains all the RTL functions it needs)
				but the disadvantage that it is slightly bigger. The latter has the
				advantage that it will be slightly smaller (and if there was a patch etc to the RTL you
				wouldn't have to redistribute your app), but it has the disandvantage that the host
				must have the correct RTL DLLs available and if it doesn't you have to distribute them.
			</p>
			<p>
				In debug libraries, the debug symbols are generated (.pdb) files and no opimization is
				used. In release libraries, symbols are stripped and code optimization is used.
			</p>
			<p>
				Your link options are <a href="https://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx" target="_blank">[Ref]</a>:
			</p>
			<ol>
				<li><code>/MD[d]</code>:Use multi-threaded dynamic RTL. No 'd' for release, 'd' for debug.</li>
				<li><code>/MT[d]</code>:Use multi-threaded static RTL. No 'd' for release, 'd' for debug.</li>
			</ol>
			<p>
				<img src="##IMG_DIR##/msvc_rtl_select.png" alt="Screenshot of MSVC++ 2015 project properties and where to find the Runtime Library settings"/>
			</p>
		</div>

		<h2>Casting in C &amp; C++</h2>
		<div>
			<h3>C v.s. C++</h3>
			<p>
				In C there is no checking done when you make a cast. You can cast from any type to another
				and the compiler will not complain. In C++, C-style casts should be avoided because the
				C++ casts offer a safer way to cast.
			</p>

			<h3>Casts Are More Than Treating One Type As Another!</h3>
			<p>
				Interestingly a cast may do more than just &quot;switching&quot; types. The compiler
				may have to <em>generate extra code</em> to achieve this!
			</p>
			<p>
				<blockquote>
					<p>
						Many programmers believe that casts do nothing but tell compilers to
						treat  one  type  as  another,  but  this  is  mistaken.  Type  conversions  of
						any kind (either explicit via casts or implicit by compilers) often <b>lead to
						code that is executed at runtime</b>.
					</p>
					<footer>--<a href="http://www.aristeia.com/EC3E/3E_item27.pdf" target="_blank">Effective  C++,  Third  Edition</a>, Scott Meyers.</footer>
				</blockquote>
			</p>
            <p>
                The referenced chapter is particularly illuminating. It explains why <code>dynamic_cast</code>s
                can be &quot;expensive&quot; - many compilers will do string compares on class names
                to perform the RTTI. I guess they might store a type variable behind the scenes
                that the compiler generate code to check against. (Need to reed up on this lol)
            </p>
            <p>
                For example, let's use <a href="godbolt.org">godbolt.org</a> to examine what happens when we cast from
                an integer to a double:
            </p>
            <p>
                <img src="##IMG_DIR##/godbolt_screenshot_cast_int_to_double.png" alt="A screenshot of godbold.org to look at csasting an integer to a double"/>
            </p>
            <p>
                Although we have turned off optimizations (we have to otherwise the entire bit of code in the example gets optimized away)
                we can see what the compiler has had to do to cast the <code>int</code> to a <code>double</code>: it has had to
                emit the instructions <code>vmov</code> and <code>vcvt.f64.s32</code> to accomplish the cast. The latter
                command is what converts between an integer and a double and the former puts the integer in an appropriate register.
                Thus our cast has resulted in extra machine instructions.
            </p>

			<h3>Static &amp; Reinterpret Casts</h3>
			<p>
				A static cast converts betwen <b>related types</b>, but will not allow you
				to convert between unrelated types. For example, a static cast
				will not cast away constness or volatility.
			</p>
			<p>
				When you <code>static_cast</code> you're basically saying to the compiler that
				you guarantee that the type is what you say it is. This means, especially for
				down-casts from base classes to child classes, the compiler won't emmit code to
				do run time checks. Thus <code>static_cast</code> is less safe. It may still
				emmit code to do the cast, just not the type checking code.
			</p>
			<p>
				Reinterpret casts are even more unsafe and let you convert between unrelated types...
			</p>
			<blockquote>
				<p>
					Unlike static_cast, but like const_cast, the reinterpret_cast expression does
					not compile to any CPU instructions. It is purely a compiler directive which
					instructs the compiler to treat the sequence of bits (object representation)
					of expression as if it had the [new type].
				</p>
				<footer>-- cppreference.com</footer>
			</blockquote>
			<p>Stroustrup explains this in more detail
                <a href="http://www.stroustrup.com/bs_faq2.html#static-cast" target="_blank">here</a>.
                He says that the <q>idea is that conversions allowed by static_cast are somewhat
                less likely to lead to errors than those that require reinterpret_cast</q>, and
                gives the following example:
            </p>
            <pre class="prettyprint linenums">int a = 7;
double* p1 = (double*) &amp;a;                  // ok (but a is not a double)
double* p2 = static_cast&lt;double*&gt;(&amp;a);      // error
double* p2 = reinterpret_cast&lt;double*&gt;(&amp;a); // ok: I really mean it</pre>
            <p>Todo:</p>
            <pre>https://stackoverflow.com/questions/14623266/why-cant-i-reinterpret-cast-uint-to-int</pre>
            <p></p>
		</div>

        <!-- *********************************************************************************** -->
		<h2>IOStreams</h2>
		<div>
			<h3>Output Stream Manipulators</h3>
			<p>
				<b>Manipulators</b> are objects known to IOStream that allows a stream to be changed. Include
				<code>&lt;iomanip&gt;</code>. Mostly, states are persistent.
			</p>
			<table>
			<tr>
				<td><code>cout.put(c)</code></td><td>Write char c to stdout.</td>
			</tr>
			<tr>
				<td><code>std::endl</code></td><td>Writes a newline (&quot;\n&quot;) then calls <code>cout.flush()</code>. Note this is <em>not</em> a cross platform newline which is sometimes a confusion. It just outputs &quot;\n&quot;, not &quot;\r\n&quot; or anything else.</td>
			</tr>
			<tr>
				<td><code>std::flush</code></td><td>Calls <code>cout.flush()</code>.</td>
			</tr>
			<tr>
				<td><code>std::ends</code></td><td>Prints NULL character to cout.</td>
			</tr>
			<tr>
				<td><code>setw(c)</code></td><td>Sets c as the stream's fill character.</td>
			</tr>
            <tr>
                <td><code>setfill()</code></td><td>Sets field width. Default is right aligned.</td>
            </tr>
			<tr>
				<td><code>cout.setf(flag-to-set, flag-to-clear)</code></td><td><code>flag-to-clear</code>, the second parameter clears all flags before setting <code>flag-to-set</code>.</td>
			</tr>
			<tr>
				<td><code>cout.unsetf(flag-to-clear)</code></td><td>Clear a flag.</td>
			</tr>
			<tr>
				<td><code>ios::hex ios::oct ios::dec</code></td><td>For integer output.</td>
			</tr>
			<tr>
				<td><code>ios::basefield</code></td><td>Mask to clear all integer output formats.</td>
			</tr>
			<tr>
				<td><code>ios::showbase</code></td><td>Puts a &quot;0x&quot; in front of hex output etc.</td>
			</tr>
			<tr>
				<td><code>ios::showpos</code></td><td>Shows the positive sign for values.</td>
			</tr>
			<tr>
				<td><code>cout.precision()</code></td><td>Sets precision of floating point output.</td>
			</tr>
			<td>
				<td><code>ios::fixed ios::scientific</code></td><td></td>
			</td>
			<tr>
				<td><code>ios:uppercase</code></td><td>Force hexadecimal alpha characters to uppercase.</td>
			</tr>
			<tr>
				<td><code>ios:left</code></td><td>Sets left alignment when field width greater than width of whats being printed.</td>
			</tr>
			<tr>
				<td><code>ios::adjustfield</code></td><td>Mask to clear all alignments.</td>
			</tr>
			<tr>
				<td><code>(void *)</code></td><td>Cast any pointer to <code>void *</code> to print the pointer</td>
			</tr>
			</table>
			<p>
			</p>
			<h3>Input Streams</h3>
			<p>
				By default input streams ignore whitespace.
			</p>
			<p>
				Usually line buffered. I.e. <code>cin >> var;</code> will not return until <code>RETURN</code> is pressed.
			</p>
			<p>
				Quietly go into a safe, do-nothing, mode upon error.
			</p>
            <h3>Read/Write Containers to Files</h3>
            <pre class="prettyprint linenums">template &lt;typename T&gt;
void VectorFromFile(const std::string &amp;filename, std::vector&lt;T&gt; &amp;v)
{
    std::copy(
        std::istream_iterator&lt;T&gt;(std::ifstream(filename.c_str())),
        std::istream_iterator&lt;T&gt;(),
        std::back_inserter(v));
}

template &lt;typename T&gt;
void VectorToFile(const std::string &amp;filename, const std::vector&lt;T&gt; &amp;v)
{
    std::copy(
        v.begin(),
        v.end(),
        std::ostream_iterator&lt;T&gt;(std::ofstream(filename.c_str()), "\n"));
}</pre>
		</div> <!-- END IOSTREAMS -->

        <!-- *********************************************************************************** -->
		<h2>Google Test (On Windows)</h2>
		<div>
			<p>
				Jeez it took ages to set this bugger up... so save yourself some time and don'try to open the existing msvc project
				files and <b>instead re-generate them using cmake!</b> I promise you it will save you the heart-ache. These are the steps:
			</p>
			<ol>
				<li>Download and install CMake and make sure you select the option to put CMake on the path</li>
				<li>Pick a root directory and clone the CMake git repo there. I'm gonna use <code>C:\Users\jehtech\googletest_msvc</code>.
				    Therefore from the git command prompt naviage to <code>/c/users/jehtech/googletest_msvc</code> and type
				    <code>git clone git@github.com:google/googletest.git</code>. This will create the subdirectory <code>googletest</code>.
				</li>
				<li><b>Absolutely ignore the existing MSVC project files in <code>C:\Users\jehtech\googletest_msvc\googletest\googletest\msvc</code>!!</b>
				</li>
				<li>From the same directory, but in your normal console, type <code>cmake -Dgtest_build_samples=ON googletest_msvc</code>. Using
				    <code>-Dgtest_build_samples=ON</code> tells CMake to generate project files that contain the Google Test examples as well.
				</li>
				<li>CMake should now generate your MSVC project files for you in the directory <code>C:\Users\jehtech\googletest_msvc</code>.
				</li>
				<li>Load the project file <code>googletest-distribution.sln</code> and build the solution for both Debug and Release. This 
				    will create the directories <code>C:\Users\James\googletest_msvc\googlemock\gtest\{Debug,Release}</code> that contain
				    the built gtest libraries.
				</li>
			</ol>
			<p>
				But annoyingly I still get the following when trying to create my own project, although the sample tests do not seem
				to have this problem for some reason.
			</p>
			<pre>
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2440	'<function-style-cast>': cannot convert from 'initializer list' to 'testing::internal::AssertHelper'	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12	
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2065	'gtest_ar': undeclared identifier	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12	
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2589	'switch': illegal token on right side of '::'	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12	
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2181	illegal else without matching if	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12</pre>
		</div> <!-- END GTEST -->

        <!-- *********************************************************************************** -->
		<h2>Smart Pointers</h2>
		<div> 
			<p> Defined in &lt;memory&gt; 
			</p>
			<h3>Shared Pointers</h3>
			<p>
				For <em>shared ownership</em> use <code>shared_ptr</code>. You can have many shared pointers pointing at the
				same object. That object is only freed when the number of pointers to the object
				reaches 0.
			</p>
			<p>
				For shared use where ownership is not required <code>weak_ptr</code> is used.
			</p>
			<pre class="prettyprint linenums">#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class Transformer 
{
protected:
   std::string mName;
public:
   Transformer(const std::string &amp;name) : mName(name) { }
   std::string GetName() { return mName; }
};

class Autobot : public Transformer 
{ 
public:
   Autobot(const std::string &amp;name) : Transformer(name) { }
   ~Autobot() { std::cout &lt;&lt; "** Deleting Autobot " &lt;&lt; mName &lt;&lt; std::endl; }
};

class Decepticon : public Transformer 
{
public:
   Decepticon(const std::string &amp;name) : Transformer(name) { }
   ~Decepticon() { std::cout &lt;&lt; "** Deleting Decepticon " &lt;&lt; mName &lt;&lt; std::endl; }
};

int main(int argc, char *argv[])
{
   // Note in C++11 No longer need space between two template endings: &gt;&gt; not &gt;space&gt;
   std::vector&lt;std::shared_ptr&lt;Transformer&gt;&gt; characters;
   std::shared_ptr&lt;Transformer&gt; pOptimusPrime(new Autobot("OptimusPrime"));
   std::shared_ptr&lt;Transformer&gt; pBumblebee(new Autobot("Bumblebee"));

   {
      std::shared_ptr&lt;Transformer&gt; pMegatron(new Decepticon("Megatron"));

      std::cout &lt;&lt; "Before vector insertion:\n" 
                   "   Optimus has " &lt;&lt; pOptimusPrime.use_count() &lt;&lt; " owners\n" 
                   "   Bumblebee has " &lt;&lt; pBumblebee.use_count() &lt;&lt; " owners\n" 
                   "   Megatron has " &lt;&lt; pMegatron.use_count() &lt;&lt; " owners\n";

      characters.push_back(pOptimusPrime);
      characters.push_back(pOptimusPrime);
      characters.push_back(pBumblebee);
      characters.push_back(pMegatron);
      characters.push_back(pOptimusPrime);
      characters.push_back(pMegatron);

      std::cout &lt;&lt; "After vector insertion:\n" 
                   "   Optimus has " &lt;&lt; pOptimusPrime.use_count() &lt;&lt; " owners\n" 
                   "   Bumblebee has " &lt;&lt; pBumblebee.use_count() &lt;&lt; " owners\n" 
                   "   Megatron has " &lt;&lt; pMegatron.use_count() &lt;&lt; " owners\n";

      std::cout &lt;&lt; "\n"
                   "Now we'll remove the evil Megatron from the list\n";
      for(auto it = characters.begin(); it != characters.end(); )
      {
         if((*it)->GetName() == "Megatron")
            it = characters.erase(it);
         else
            ++it;
      }

      std::cout &lt;&lt; "\n"
                   "Removing Megatron from the list means that..\n";

                   std::cout &lt;&lt; "Megatron has " &lt;&lt; pMegatron.use_count() &lt;&lt; " owners\n"
                                "Now only pMegatron holds a reference. As we go out\n"
                                "of scope Megatron will die!\n";
   }

   std::cout &lt;&lt; "\n"
                "Thankfully our other heros survived.";

   std::cout &lt;&lt; "\n"
                "Because our heros are in the list, we can empty the original\n"
                "smart pointers and they will continue to exist...\n";

   pOptimusPrime.reset();
   pBumblebee.reset();


   std::cout &lt;&lt; "\n"
                "Now we exit, Optimus and Megatron should also be\n"
                "destroyed (noooo, Optimus!)\n";

   return 0;
}
/*
OUTPUT IS:

Before vector insertion:
   Optimus has 1 owners
   Bumblebee has 1 owners
   Megatron has 1 owners
After vector insertion:
   Optimus has 4 owners
   Bumblebee has 2 owners
   Megatron has 3 owners

Now we'll remove the evil Megatron from the list

Removing Megatron from the list means that..
Megatron has 1 owners
Now only pMegatron holds a reference. As we go out
of scope Megatron will die!
** Deleting Decepticon Megatron

Thankfully our other heros survived.
Because our heros are in the list, we can empty the original
smart pointers and they will continue to exist...

Now we exit, Optimus and Megatron should also be
destroyed (noooo, Optimus!)
** Deleting Autobot Bumblebee
** Deleting Autobot OptimusPrime
*/</pre>
		</div> <!-- END H2 Smart Pointers -->

		<h2>Templates</h2>
		<div>
			<h3>Calling Functions In a Templated Base Class - Gotcha!</h3>
			<p>
				This one really surprised me! When you inherit from a base class that is a template
				beware calling base class functions from the derivied class. The functions names
				are not looked up as you'd expect (or at least how I'd have expected lol).
			</p>
			<p>
				<b>If in doubt, always prefix base-class function calls with &quot;<code>this-&gt;</code>&quot;!</b>
			</p>
			<pre class="prettyprint linenums">#include &lt;iostream&gt;
using namespace std;

void bar()
{
   std::cout &lt;&lt; "Gloal bar()\n";
}

template &lt;typename T&gt;
class Base
{
public:
   void bar()
   {
      std::cout &lt;&lt; "Template bar()\n";
   }
};

template &lt;typename T&gt;
class Derived : Base&lt;T&gt;
{
public:
   void foo()
   {
      <b>bar(); // WARNING! Does NOT do what you might expect!</b>
      this->bar();
      Base&lt;T&gt;::bar();
   }
};

int main()
{
   Derived&lt;int&gt; d;
   d.foo();
   return 0;
}

/* OUTPUTS:
Gloal bar()
Template bar()
Template bar()
*/</pre>
		</div> <!-- END H2 Templates -->

		##MARKDOWN:c_and_cpp/modem_c++.md##

	</div> <!-- END H1 padding div -->
	</div>
</body>
</html>


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

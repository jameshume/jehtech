<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Linux Kernel notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Linux Kernel notes</h1>
<div style="padding-right:10px;">
<p>
  How to configure and build the Linux kernel and write device drivers for it (e.g. adding device
  driver for Wii Nunchuck by going through the FreeElectons tutorials).
</p>

<h2>Page Contents</h2>
<div id="page_contents">
</div>


<h2>References / To Read</h2>
<div>
  <ol>
    <li><a href="http://free-electrons.com/doc/books/lkn.pdf"
           target="_blank">Linux Kernel In A Nutshell</a>, Greg Kroah-Hartman, O'Reilly Media (PDF of entire book release by free electrons!).
    </li>
    <li><a href="https://doc.lagout.org/operating%20system%20/linux/Essential%20Linux%20Device%20Drivers.pdf"
           target="_blank">Essential Linux Device Drivers</a>, Sreekrishnan Venkateswaran, Prentice Hall (Not sure if this is legit?)</a>
    </li>
    <li><a href="https://googleprojectzero.blogspot.co.uk/2016/06/exploiting-recursion-in-linux-kernel_20.html"
           target="_blank">Exploiting Recursion in the Linux Kernel </a>,
    </li>
    <li><a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.pdf"
           target="_blank">Linux Kernel and Driver Development Training Lab Book</a>, FreeElectrons.com.
    </li>
    <li><a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf"
           target="_blank">Linux Kernel and Driver Development Training Slides</a>, FreeElectrons.com.
    </li>
    <li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf"
           target="_blank">Linux Device Tree For Dummies</a> Thomas Petazzoni.
    </li>
    <li><a href="http://elinux.org/images/8/8e/Rutland-presentation_3.pdf"
           target="_blank">Device Tree: The Disaster so Far</a>, Mark Rutland 2013
    </li>
    <li><a href="http://elinux.org/Device_Tree_presentations_papers_articles"
           target="_blank">Device Tree presentations papers articles</a>.
    </li>
    <li><a href="https://www.gitbook.com/book/0xax/linux-insides/details"
           target="_blank">Linux Insides</a>, GitBook by @0xAX
    </li>
    <li><a href="https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"
           target="_blank">The sysfs Filesystem</a>
    </li>
    <li>http://irl.cs.ucla.edu/~yingdi/web/paperreading/smp_locking.pdf</li>
    <li>https://stackoverflow.com/questions/20301591/m-option-in-make-command-makefile</li>
    <li>https://sysplay.in/blog/linux-kernel-internals/2015/04/kernel-threads/</li>
    <li>http://www.evanjones.ca/software/threading-linus-msg.html - Linus on COE</li>
    <li>https://www.kernel.org/doc/Documentation/timers/timers-howto.txt</li>
    <li>include/linux/jiffies.h and kernel/time/jiffies.c</li>
    <li>https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-3.html</li>
    <li>http://elinux.org/Debugging_by_printing</li>
    <li>http://www.makelinux.net/ldd3/chp-11-sect-5</li>
    <li>http://www.linuxfromscratch.org/lfs/downloads/stable/LFS-BOOK-8.0.pdf</li>
    <li>http://www.linuxinternals.org/blog/2014/05/07/spinlock-implementation-in-linux-kernel/</li>
    <li>Interrupts - https://elinux.org/images/8/8c/Zyngier.pdf </li>
    <li>Scripts to build a minimal linux from scratch! - https://github.com/ivandavidov/minimal</li>
    <li>https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch07.html - Time, delays etc</li>
    <li>https://www.ibm.com/developerworks/library/l-kernel-memory-access/index.html</li>
    <li>https://stackoverflow.com/questions/442833/forcing-driver-to-device-match</li>
    <li>https://www.ibm.com/developerworks/library/l-initrd/index.html</li>
    <li>https://www.digikey.com/eewiki/display/linuxonarm/BeagleBone+Black#BeagleBoneBlack-LinuxKernel</li>
    <li>http://blog.logikonlabs.com/how-to-create-a-custom-microsd-card-image-for-the-beaglebone-black/</li>
    <li>https://www.digikey.com/eewiki/display/linuxonarm/BeagleBone+Black</li>
    <li>https://www.element14.com/community/community/designcenter/single-board-computers/next-gen_beaglebone/blog/2015/12/05/mainline-linux-kernel-on-beaglebone-black</li>
    <li>https://kernelnewbies.org/ ************</li>
    <li>https://vadl.github.io/beagleboneblack/2016/07/29/setting-up-bbb-gpio</li>
    <li>http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf - memory barries </li>
    <li>https://community.arm.com/processors/b/blog/posts/memory-access-ordering---an-introduction</li>
    <li>https://www.cs.umd.edu/~mvz/cmsc430-s07/M24risc.pdf</li>
    <li>https://www.quora.com/How-does-the-out-of-order-execution-work-in-microprocessors</li>
    <li>https://lwn.net/Articles/691882/ - SMATCH</li>
    <li>https://lwn.net/Articles/51437/ - The Zen Of KObjects</li>
    <li>https://lwn.net/Articles/54651/ - KObjects and sysfs</li>
  </ol>
</div>

<h2>Generally Useful Links</h2>
<div>
<ul>
  <li><a href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/13_14/docs/kernelAPI/" target="_blank">The Linux Kernel API</a>
  </li>
</ul>
</div>

<h2>The Kernel Development Timeline</h2>
<div>
<p>
  <img src="##IMG_DIR##/linux_timeline.png" alt="Linux kernel development timeline"/>
  <br/>[<i>Information from <a href="https://kernelnewbies.org/LinuxVersions" target="_blank">https://kernelnewbies.org/LinuxVersions.</i></a>]
</p>
</div>

<h2>Configure &amp; Build the Linux Kernel</h2>
<div>
<h3>Downloading The Kernel Source &amp; A Look At Its Structure</h3>
<p>
  To download the latest, bleeding edge, of the kernel source, do the following:
</p>
<pre>git clone (html|git)://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</pre>
<p>
  Now we can have a look at the first level of the directory structure:
  <img style="float: left;" src="##IMG_DIR##/linux_source_dir.png" alt="Picture of directories in the linux root directory with some annotation"/>
</p>
<p>
  The <code>arch</code> directory contains all of the architecture dependent code. This code is specific
  to each platform that the kernel will run on. The kernel itself is as generic as possible, but
  because at this low level it does have to be concerned with architecture specifics this is where
  you'll find the implementations.
</p>
<p>
  The <code>block</code> directory contains the Linux block I/O layer files which are used to help
  manage block devices, like your hard disk, for example.
</p>
<p>
  The <code>Documentation</code> directory is very useful! Here you can find many bits of documentation
  on the Linux kernel. The files are mostly text files, but under <code>Documentation/DocBook</code>
  you will find a set of files that can be built using <code>make</code> to produce PDF or HTML
  documentation.
</p>
<p>
  If, for example you are interested in learning about the kernel debugger, there
  is a book on that in <code>kgdb.xml</code>. If you want to compile the documentation for just
  this, for example, edit the Makefile under <code>Documentation/DocBook/Makefile</code> and change
  the variable <code>DOCBOOKS</code>. You can do this by renaming or commenting out the existing
  variable and re-defining it with just the resource you want (you might want to do this as the
  build of the complete set of books fails sometimes - or at least did for me).
</p>
<p>
  To compile your DocBook, return to the root directory of the Linux source and run <code>make pdfdocs</code>.
  The PDF will be build and stored in the DocBooks directory.
</p>
<p>
  The <code>drivers</code> directory contains a slew of device drivers organised under their type.
  So, for example, input device drivers (think keyboard, touchpad etc) are found under <code>drivers/input</code> and
  PCI device drivers under <code>drivers/pci</code>. There may be further hierarchical organisation too. For example,
  under <code>drivers/input</code> there are further subdirectories for keyboards, touch screens, mice etc.
  Other character device drivers such as <code>/dev/null</code> are found under <code>drivers/char</code>.
</p>
<p>
  The <code>fs</code> directory houses file system modules. These support a variety of file systems
  like FAT, NTFS, ext3, ext4 and more. These allow the Linux user to mount Windows file systems,
  use the Linux file systems and many more, including Mac.
</p>

<h3 style="clear:both;">Configuring The Kernel</h3>
<p>
  The Kernel... a pretty complex beast. As such there is a lot of configuration that can be done.
  Most hardware providers will have reference configurations that are used as a basis for product
  specific configurations. Some distributions will provide the configuration file used to build
  the kernel in the <code>/boot</code> directory. Or sometimes in <code>/proc/config.gz</code>,
  but this is often not configured as a build option.
</p>
<p>
  Anyway, all these configurations are found in configuration files (<code>.config</code> files), which
  are generally many thousands of lines long.
</p>
<p>
  Given that there are so many options, Linux provides utilities to help with the configuration
  processes (as well as reference configurations from various distros/manufacturers etc).
</p>
<p>
  There are three main ways to configure the Linux kernel. Each of them uses the current config and
  gives you a way to update it:
</p>
<ol>
  <li>config - this is a basic command line interface: a ton of yes/no style of questions, which you don't want to use!</li>
  <li>menuconfig - an ncurses inferface with help options etc.</li>
  <li>nconfig - a newer version of menuconfig with improved user interface, still ncurses based.</li>
  <li>xconfig - a GUI based interface.</li>
</ol>
<p>
  These targets can all be found in <code>scripts/kconfig/makefile</code>.
</p>

<p>
  The current config is stored in the root directory in the file <code>.config</code>. The default
  config file used can be taken from your system. For example, when I ran menuconfig it creates
  the configuration file from <code>/boot/config-4.4.0-78-generic</code>.
</p>
<p>
  When you are compiling your own kernel you will probably specify the architecture so you'd specify
  something like <code>make ARCH=arm menuconfig</code>, for example. But, this will still use a
  default config and probably not the one you want. Therefore the full make command will be something
  like <code>make ARCH=arm menuconfig arch/arm/configs/corgi_config</code>, if you're building for the
  ARM Corgi platform. When you do this, the old <code>.config</code> will be overwritten by your
  new configuration.
</p>
<p>
  Interestingly, but perhaps unsurprisingly, launching most of the config tools will involve a
  compilation step on the host machine. You can see the exact steps taken by running the make command
  with the extra option <code>V=1</code>. The make step is required to build the config tool being
  used.
</p>

<h4>Menuconfig</h4>
<p>
  Menuconfig presents a nice ncurses display that you
  can navigate around using the instructions at the top of the window. If you do not have ncurses
  installed, install it using:
</p>
<pre>sudo apt-get install libncurses5-dev</pre>
<p>
  You can run menu config using:
</p>
<pre>make menuconfig</pre>
<p>
  <img src="##IMG_DIR##/menuconfig.png" alt="Screen shot of kernel configuraton tool menuconfig"/>
</p>
<p>
  What you'll notice is that there are a nice set of menus and when you use the help you will
  be given some information about the item you've selected.
  For example, the help for <code>System Type &gt; MMU-based Paged Memory Management Support</code>,
  reads as follows:
</p>
<p>
  <img src="##IMG_DIR##/menuconfig_help_eg.png" alt="Screen shot of kernel configuraton tool menuconfig"/>
</p>
<p>
  Nice, but how does menuconfig know all this stuff?! When it runs it reads the main <code>Kconfig</code>
  file, found in the root directory. This will source the main Kconfig for the architecture you are compiling
  for. The variable <code>SRCARCH</code> is used as it is a slightly modified, depending on platform,
  version of <code>ARCH</code>. The main Kconfig file is taken from <code>arch/$SRCARCH/Kconfig</code>. So,
  if we're compiling for arm, the Kconfig file would be found in <code>arch/arm/Kconfig</code>. This file
  defines a lot of things but also sources a ton of other Kconfig files!
</p>
<p>
  We can look in this file to get an idea of the syntax:
</p>
<pre>...
menu "System Type"

config MMU
   bool "MMU-based Paged Memory Management Support"
   default y
   help
      Select if you want MMU-based virtualised addressing space
      support by paged memory management. If unsure, say 'Y'.
...</pre>
<p>
  We can see that a menu called &quot;System Type&quot; is being defined. If we look in the first menuconfig
  screenshot we can see that menu item highlighted. We can drill into this menu to find the menu
  item &quot;MMU-based Paged Memory Management Support&quot;. If we then select the help feature for this item, we see the second screenshot
  shown above, which matches the description we found in our main Kconfig file :)
</p>
<p>
  Not every menu item is defined in the main file however. It sources many others and will also pull in
  all Kconfig files it finds. For example there is a Kconfig file in most of the leaf directories of
  the drivers tree.
</p>

<h4>Xconfig</h4>
<p>
  Nicer GUI application that requires QT. If you no not have QT installed, you can do so by running the following command:
</p>
<pre>sudo apt-get install libqt4-dev</pre>
<p>
  Involked in the same way (following our example so far):
</p>
<pre>make ARCH=arm xconfig arch/arm/configs/corgi_config</pre>
<p>
  <img src="##IMG_DIR##/xconfig.png" alt="Screen shot of kernel configuraton tool xconfig"/>
</p>
<p>
  Xconfig has a few nice advantages like a GUI which will show you the symbols next to the
  menu descriptions and a beefed up find functionality.
</p>

<h3 style="clear:both;">Building The Kernel</h3>
<p>
  The Kernels own documentation in <a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt"
  target="_blank">Documentation/kbuild/makefiles.txt</a> is very comprehensive!
</p>
<p>
  The makefile target <code>make oldconfig</code> <q>reads the existing .config file and prompts the user for options in the current kernel source that are not found in the file. This is useful when taking an existing configuration and moving it to a new kernel</q>
  <a href="https://stackoverflow.com/questions/4178526/what-does-make-oldconfig-do-exactly-in-the-linux-kernel-makefile" target="_blank">[Ref]</a>.
  Before the command is run you would have copied an older kernel config file into the kernel
  root as <code>.config</code>. This make target &quot;refreshes&quot; it by asking questions
  for newer options not found in the config file.
</p>
<p>
https://serverfault.com/questions/568395/what-is-creating-the-generated-autoconf-h
</p>

<pre>
# From kernel README
    "make ${PLATFORM}_defconfig"
                        Create a ./.config file by using the default
                        symbol values from
                        arch/$ARCH/configs/${PLATFORM}_defconfig.
                        Use "make help" to get a list of all available
                        platforms of your architecture.

# See also scripts/kconfig/Makefile:
%_defconfig: $(obj)/conf
        $(Q)$< --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
</pre>

https://devtalk.nvidia.com/default/topic/906942/failed-to-compile-kernel-module-gcc-cannot-recognize-aarch64-option-mgeneral-regs-only-/

https://developer.android.com/ndk/guides/standalone_toolchain.html

  Aaaah cross compile for android, make sure you are using the Android prebuilt toolchains!

   export PATH=/path-to-android-src-root/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin:$PATH
   make prepare ARCH=arm64 CROSS_COMPILE=aarch64-linux-android- V=1


   https://glandium.org/blog/?p=2664 - saving my arse!

   Modules.symvers ???
</pre>
</div> <!-- End H2 -->

<h2 style="clear:both;">Unbind A Kernel Driver</h2>
<div>
<p>
  Most drivers have an entry under <code>/sys/bus/xxx/drivers/yyy</code>. For example if you
  <code>ls</code> the directory <code>/sys/bus</code> you will see somthing similar to the
  following (list snipped to shorten it):
</p>
<pre>/sys/bus
|-- i2c
|-- pci
|-- pci_express
|-- platform
|-- pnp
|-- scsi
|-- sdio
|-- serio
|-- spi
|-- usb
&lt;snip&gt;</pre>
<p>
  The different types of buses are listed. Under each bus, the following structure is seen:
</p>
<pre>/sys/bus/XXX
|-- devices
\-- drivers
</pre>
<p>
  We're interested in the <code>drivers</code> subdirectory. Let's take a look at a sample directory
  for I2C drivers:
</p>
<pre>/sys/bus/i2c/drivers
|-- 88PM860x
|-- aat2870
&lt;snip&gt;</pre>
<p>
  Under the <code>drivers</code> directory we can see (above) a list of devices for which drivers
  exist.
</p>
</div> <!-- End H2 -->

<h2>Building The Kernel</h2>
<div>
    <pre>http://newandroidbook.com/Book/Input.html
=========================================

/proc/interupts - To look at interrupt lines claimed by drivers - architecture dependent
/proc/stat      - shows interrupt count

Input driver model docs:
    Documentation/input/, and in particular input.txt

When driver registers as input device, the following is auto created:
  /dev/input/eventX (cat this to get dump of Linux input events as they happen)
As well as sysfs entries.

/proc/bus/input/devices - Where system keeps track of all devices

/sys/class/input/eventX - directory - info about device assoc. with this event
    cat /sys/class/input/eventX/uevent to get device info such as major and minor number etc

getevent and sendevent command:
    system/core/toolbox/(get|send)event.c.
For example 'getevent -l' lists the devices and their human readable names and associated "eventX"

Both tools seem to use the /dev/input/eventXX to read and write events. To write events you need
to have root access to make /dev/input/eventXX writeable!

https://wiki.ubuntu.com/DebuggingTouchpadDetection/evtest
http://stackoverflow.com/questions/16695432/input-event-structure-description-from-linux-input-h
http://www.usb.org/developers/hidpage
https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt
https://source.android.com/devices/input/touch-devices.html
   </pre>

<pre>
# kbuild supports saving output files in a separate directory.
# To locate output files in a separate directory two syntaxes are supported.
# In both cases the working directory must be the root of the kernel src.
# 1) O=
# Use "make O=dir/to/store/output/files/"
#
# 2) Set KBUILD_OUTPUT
# Set the environment variable KBUILD_OUTPUT to point to the directory
# where the output files shall be placed.
# export KBUILD_OUTPUT=dir/to/store/output/files/
# make
#
# The O= assignment takes precedence over the KBUILD_OUTPUT environment
# variable.
</pre>

<pre>
###
# External module support.
# When building external modules the kernel used as basis is considered
# read-only, and no consistency checks are made and the make
# system is not used on the basis kernel. If updates are required
# in the basis kernel ordinary make commands (without M=...) must
# be used.
#
# The following are the only valid targets when building external
# modules.
# make M=dir clean     Delete all automatically generated files
# make M=dir modules   Make all modules in specified dir
# make M=dir           Same as 'make M=dir modules'
# make M=dir modules_install
#                      Install the modules built in the module directory
#                      Assumes install directory is already created
</pre>
</div> <!-- End H2 -->

<h2>Linux Kernel and Driver Development Training Lab Book</h2>
<div>
<p>
  References:
    <ul>
      <li><a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.pdf"
       target="_blank">Linux Kernel and Driver Development Training Lab Book</a> by FreeElectrons.com.
      </li>
      <li>
        <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf" target="_blank">Linux Kernel and Driver Development Training Slides</a>, Free Electrons.
      </li>
      <li>
        <a href="https://raw.githubusercontent.com/CircuitCo/BeagleBone-Black/master/BBB_SRM.pdf" target="_blank">BeagleBone Black System Reference Manual</a>, Rev C.1.
      </li>
      <li><a href="http://www.ti.com/lit/ds/symlink/am3359.pdf" target="_blank">AM335xSitara<sup>TM</sup> Processors Datasheet</a>.
      </li>
      <li><a href="http://www.ti.com/lit/ug/spruh73p/spruh73p.pdf" target="_blank">AM335x and AMIC110 Sitara<sup>TM</sup> Processors Technical Reference Manual</a>.
      </li>
      <li><a href="https://www.digikey.com/eewiki/display/linuxonarm/BeagleBone" target="_blank">BeagleBone</a>, Robert Nelso.
      </li>
      <li><a href="https://vadl.github.io/beagleboneblack/2016/07/29/setting-up-bbb-gpio" target="_blank">Setting Up the BeagleBone Black's GPIO Pins</a>.
      </li>
      <li>
          <a href="https://github.com/beagleboard/beaglebone-black/blob/master/BBB_SCH.pdf" target="_blank">BBB Schematic</a>.
      </li>
  </ul>
</p>
<pre>
Todo read:
https://embedjournal.com/kernel-compilation-beaglebone-black/
https://embedjournal.com/custom-rfs-beaglebone-black/
https://www.elinux.org/Beagleboard:BeagleBoneBlack#Software_Resources
http://derekmolloy.ie/write-a-new-image-to-the-beaglebone-black/ -- writes to onboard eMMC
https://wiki.beyondlogic.org/index.php?title=BeagleBoneBlack_Upgrading_uBoot
https://www.twam.info/hardware/beaglebone-black/u-boot-on-beaglebone-black
http://processors.wiki.ti.com/index.php/SD/MMC_format_for_OMAP3_boot
https://www.digikey.com/eewiki/display/linuxonarm/BeagleBone+Black#BeagleBoneBlack-ARMCrossCompiler:GCC
https://elinux.org/Beagleboard:BeagleBoneBlack_Rebuilding_Software_Image
</pre>
<p>
    Notes created whilst working through
    <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.pdf"
       target="_blank">Linux Kernel and Driver Development Training Lab Book</a> by FreeElectrons.com,
    whilst consulting the <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf" target="_blank">accompanying slides</a>.
</p>
<p>
    Use the lab slides! To begin with I hadn't found them and thought the lab book was a little
    short on descriptions. When I found out they also had slides it made a lot more sense!
</p>

<h3>Setup</h3>
<p>
Note: To begin with I had a rather limited setup where I was doing this. I was compiling on a Linux
server but only had a Windows desktop PC. Setting up an NFS server from Windows or from a Virtual Box running Linux
or through Cygwin took way too much time and was getting in the way of actually learning anything
so I gave up and used a pure Linux system... I'd advise anyone reading this to do the same!!!
</p>

<h4>Download The Source</h4>
<p>
    Download the linux kernel:
</p>
<pre>git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git --depth=1</pre>
<p>
    The flag <code>--depth=1</code> means we ignore all history to make download faster.
</p>
<p>
    Use stable releases:
</p>
<pre>cd ~/linux-kernel-labs/src/linux/
git remote add stable git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
git fetch stable [--depth=1]</pre>
<p>
    Again you can use <code>--depth=1</code> to speed up the download, but note you won't have
    any log history
</p>

<p>Select a branch:</p>
<pre># list available braches
git branch -a

# Create a local branch starting from that remote branch
git checkout -b 4.9.y stable/linux-4.9.y</pre>

<h4>Setup USB to Serial</h4>
<p>Picocom is a minimal dumb-terminal emulation program. Type Ctrl+A, Ctrl+X to exit once connected.
</p>
<pre>sudo apt-get install picocom
sudo adduser $USER dialout
picocom -b 115200 /dev/ttyUSB0
</pre>

<h4>Setup TFTP Server</h4>
<pre>sudo apt-get install tftpd-hpa</pre>
<p>
    By default all files you want to be TFTP'able should be placed in <code>/var/lib/tftpboot</code>.
    In my install, the directory was owned by root and not in any group which was a pain, so
    <code>sudo chgroup YOUR_GROUP /var/lib/tftpboot</code> so you can get easier access to this
    directory. <code>YOUR_GROUP</code> should be a group you already belong to, or a new group,
    up to you. If you wanted to add a new group, say <code>tftp_users</code>, for example, you
    could run <code>sudo groupadd tftp_users</code> and then run
    <code> sudo adduser jh tftp_users </code>, to add yourself to the group and then
    <code>sudo chgroup tftp_users /var/lib/tftpboot</code> to put the directory in this same group.
    Then probably <code>sudo chmod g+w /var/lib/tftpboot</code> to give this new group write
    permissions on the directory.
</p>
<p>
  Alternatively you could change the root directory that the sever uses (see below).
</p>
<p>
  To start/stop etc the server use the following commands:
</p>
<pre>service tftpd-hpa status # Usefully also prints out logs
service tftpd-hpa stop
service tftpd-hpa start
service tftpd-hpa restart</pre>
<p>
  To edit the server configuration edit <code>/etc/default/tftpd-hpa</code>. The default when
  I installed it was this:
</p>
<pre>TFTP_USERNAME=&quot;tftp&quot;
TFTP_DIRECTORY=&quot;/var/lib/tftpboot&quot;
TFTP_ADDRESS=&quot;:69&quot;
TFTP_OPTIONS=&quot;--secure&quot;</pre>
<p>
  To the options I added <code>--verbose</code>.
</p>

<h4>Setup NFS Server</h4>
<p>The Linux Kernel, as configured for the lab book exercises, mounts the root file system over
NFS. Thus we need to setup the NFS server on our machine. Note: I tried doing this from a Windows
box and it is torture so just use a native Linux machine and save yourself heartache...</p>
<pre>sudo apt-get install nfs-kernel-server</pre>
<p>Run <code>sudo vi /etc/exports</code> to add this line, replacing &quot;&lt;user&gt;&quot;
with your username and the IP address with your board's IP address.</p>
<pre>/home/&lt;user&gt;/linux-kernel-labs/modules/nfsroot 192.168.2.100(rw,no_root_squash,no_subtree_check)</pre>
<p>Restart server:</p>
<pre>sudo /etc/init.d/nfs-kernel-server restart</pre>
<p>
  Now unpack the <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.tar.xz">lab files</a>
  so that you get the directory mentioned above:
</p>
<pre>cd /home/&lt;user&gt;
wget http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.tar.xz
tar xvf linux-kernel-labs.tar.xz</pre>
<p>
  For futher information on how to configure the NFS server and even shorted the export path
  used, see the Ubuntu community guide
  <a href="https://help.ubuntu.com/community/SettingUpNFSHowTo" target="_blank">SettingUpNFSHowTo</a>.
</p>

<h4>Setup Uboot</h4>
<p>
    The version of UBoot I had by default on my BB did not have the &quot;<code>saveenv</code>&quot;
    command :( So, for now at least, I will type the boot commands manually rather than worrying
    about creating a new UBoot image. Can do that later if this becomes a real pain.
</p>

<pre>setenv serverip 192.168.2.1
setenv ipaddr 192.168.2.100
tftp 0x81000000 test.txt
md 0x81000000</pre>
<p>
    The memory dump showed contents of <code>test.txt</code>, so we know the TFTP server is
    running correctly.
</p>
<p>
  NOTE: In UBoot, if you want to copy-past these into picocom copy the text into an editor
  and then replace newlines by &quot;&amp;&amp;&quot; to get a one-liner.
</p>


<h3>Compiling &amp; Booting The Kernel (+ DTB)</h3>
<h4>References</h4>
<ul>
    <!-- <li><a href="" target="_blank"></a></li> -->
    <li><a href="https://github.com/torvalds/linux/blob/master/Documentation/kbuild/makefiles.txt" target="_blank">Linux Kernel Makefiles</a>, Kernel Documentation.</li>
    <li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf" target="_blank">Device Tree For Dummies</a>, T Petazzoni.</li>
    <li><a href="https://www.kernel.org/doc/ols/2008/ols2008v2-pages-27-38.pdf" target="_blank">A Symphony of Flavours: Using the device tree to describe embedded hardwarw</a>, G Likely, J Boyer.</li>
</ul>

<h4>An Alternative Setup</h4>
<p>
  I needed to create a Kernel build and file system from &quot;kinda-scratch&quot; to boot off an SD card. The instructions I had to follow were slightly different and I've put some brief notes <a href="linux_bbb_build.html">here</a>.
</p>

<h4>Compiling The Kernel</h4>
<p>
    This section of the lab book was a little thin. Export the following:
</p>
<pre>sudo apt-get install gcc-arm-linux-gnueabi # Get the cross compiler tool chain
dpkg -L gcc-arm-linux-gnueabi # Find out path and name of tool chain
</pre>
<p>If the folder for the <code>gcc-arm-linux-gnueabi-</code> toolchain is not on your PATH,
add it, then export the following environment variables...</p>
<pre>export CROSS_COMPILE=arm-linux-gnueabi-
export ARCH=arm</pre>
<p>
    To configure the kernel type:
</p>
<pre>make menuconfig omap2plus_defconfig</pre>
<p>
    Note the file <code>omap2plus_defconfig</code> is found in <code>arch/arm/configs/</code>.
    Made sure config had <code>CONFIG_ROOT_NFS=y</code> set. To find this hit &quot;/&quot; and
    type CONFIG_ROOT_NFS. The search results will look like this:
</p>
<p><img src="##IMG_DIR##/linux-labs-mennuconfig1.png" alt="Screenshot of Linux menuconfig search results for CONFIG_ROOT_NFS"/></p>
<p>
    The red box highlights the information we need: how to find this configuration option
    in the menu system, which can be quite a maze. Navigate File Systems > Network File Systems and
    you should see the menu shown below:
</p>
<p><img src="##IMG_DIR##/linux-labs-mennuconfig2.png" alt="Screenshot of Linux menuconfig File Systems > Network File Systems"/></p>
<p>
    The image above shows a <code>[*]</code> next to &quot;NFS client support&quot;. This means that
    the support will be compiled into the kernel image. All of the other options with an <code>[M]</code>
    next to them are compiled as modules. They will not be included in the compiled kernel image
    but can be loaded separately as modules later. Modules marked with <code>[ ]</code> are not
    compiled at all.
</p>
<p>
    Exit and save your config. You will see the exit message:
</p>
<pre># configuration written to .config</pre>
<p>
    The config system has copied the file <code>arch/arm/configs/omap2plus_defconfig</code> to the
    root directory and merged in any changes you made manually from the menuconfig utility.
</p>
<p>
    Now set the build the kernel:
</p>
<pre># * -jX (optional) sets number of threads used for parallel build.
# * V=1 (optional) puts the build into verbose mode so that you can
#   see the toolchain commands being invoked.
make -j16 V=1</pre>
<p>
    The last build message you should see is...
</p>
<pre>Kernel: arch/arm/boot/zImage is ready</pre>
<p>
    If you list the directory <code>arch/arm/boot</code> you will see the <code>zImage</code> file
    and another file named <code>dts/am335x-boneblack.dtb</code>. This is the Linux Device Tree blob.
    It gives the entire hardware description of the board in a format the Kernel can read &amp; understand.
    <a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf"
       target="_blank">[Ref]</a>. Copy both files to TFTP home directory.
</p>

<h4>What Are The zImage and DTB Files?</h4>
<p>
    So, we have two files: <code>arch/arm/boot/zImage</code> and <code>arch/arm/boot/dts/am335x-boneblack.dtb</code>,
    but what are they?
</p>
<p>
    The <code>zImage</code> is a compressed kernel image that has a little bit of code in front of
    the compressed blob that will makes it bootable and self extracting so that the kernel proper
    can be decompressed into RAM and then run.
</p>
<p>
    The <code>am335x-boneblack.dtb</code> is a Linux Device Tree Blob. This is a binary format
    that the kernel can read and <q>contains the description of the hardware</q> <a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf" target="_blank">[Ref]</a>. This method was adopted
    to try and standardise how hardware information was passed to the kernel because in the
    embedded world there was little standardisation and systems varied considerably <a href="https://www.kernel.org/doc/ols/2008/ols2008v2-pages-27-38.pdf" target="_blank">[Ref]</a>.
</p>
<blockquote>
    <p>
        In the simplest terms, a device tree is a data structure that
        describes the hardware configuration. It includes information about the CPUs,
        memory banks, buses, and peripherals. The operating system is able to parse the data
        structure at boot time and use it to make decisions about
        how to configure the kernel and which device drivers to
        load.
    </p>
    <footer><a href="https://www.kernel.org/doc/ols/2008/ols2008v2-pages-27-38.pdf" target="_blank">
        A Symphony of Flavours: Using the device tree to describe embedded hardware, G. Likely, J Boyer</a>
    </footer>
</blockquote>
<p>
    So, this is what the <code>.dtb</code> file is. It is generated by many <code>.dts</code> files,
    which are text files containing a human readable &quot;map&quot; (tree really) of the system's
    hardware.
</p>
<p>
    Using DTB's we can somewhat decouple the kernel build from the hardware it is running on, rather
    than having to do a specific kernel build for every hardware variant out there!
</p>
<p>
    Mostly everything is moving towards using device trees. If <code>CONFIG_OF</code> is defined
    you know you are in Kernel with device tree and open firmware support enabled.
</p>

<h4>Booting The Kernel</h4>
<p>
    Now we can boot the kernel. From UBoot type:
</p>
<pre>setenv bootargs root=/dev/nfs rw ip=192.168.2.100 console=ttyO0 nfsroot=192.168.2.1:/home/&lt;user&gt;/linux-kernel-labs/modules/nfsroot
setenv serverip 192.168.2.1
setenv ipaddr 192.168.2.100
tftp 0x81000000 zImage
tftp 0x82000000 am335x-boneblack.dtb
bootz 0x81000000 - 0x82000000</pre>

<p>
    The NFS directory it booted from (you should see a message &quot;<code>VFS: Mounted root (nfs filesystem) on device 0:14</code>&quot;)
    should contain the data from the course labs <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.tar.xz">TAR file</a>.
    If it does not,  you will see a kernel panic saying &quot;<code>Kernel panic - not syncing: No working init found</code>&quot;. If you
    see this, make sure that the directory you shared as <code>/home/&lt;user&gt;/linux-kernel-labs/modules/nfsroot</code> contains the <code>modules\nfsroot</code> folder from the
    lab file.
</p>
<p>
    Based on the previous section we can understand what we have done here. We are booting a
    zImage. The first argument is the address of the zImage. The second argument is the hyphen, which specifies the address
    of the initrd in memory as non-existent, i.e., there is no ramfs, and the third argument is the address of the DTB that UBoot will pass
    to the Kernel.
</p>
<p>
    The other important environment variable set is <code>bootargs</code>. This is a string that
    is passed to the kernel. UBoot will pass this to the kernel. In this case it contains all the
    information required to tell the kernel to try and mount the root directory over NFS and boot
    from it.
</p>

<h3>Writing Modules</h3>
<h4>References</h4>
<ul>
  <li>Linux Kernel Development, Third Edition, Robert Love.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt" target="_blank">Building External Modules</a>, Linux Kernel Documentation.</li>
  <li><a href="https://glandium.org/blog/?p=2664" target="_blank">Building A Linux Kernel Module Without The Exact Kernel Headers</a>, Glandium.org.</li>
  <li><a href="https://github.com/jameshume/free-electrons-linux-kernel-labs/tree/master/hello" target="_blank">My solutions to exercises</a>.</li>
</ul>
<h4>Building and Loading</h4>
<p>
  The lab book instructions at this point really are pretty sparse. Writing the module isn't
  hard and grepping the source code for files with &quot;version&quot; in their name brought me to
  <code>&lt;linux-root&gt;/fs/proc/version.c</code>, which shows how to get the Linux version.
  My solution is
  <a href="https://github.com/jameshume/free-electrons-linux-kernel-labs/tree/master/hello" target="_blank">here on GitHub</a> and
  a snapshot is shown below:
</p>
<pre class="prettyprint linenums">static int __init hello_init(void)
{...}

static void __exit hello_exit(void)
{...}

module_init(hello_init);
module_exit(hello_exit);</pre>
<p>
  The only interesting things in the snippet are the tokens <code>__init</code> and <code>__exit</code>.
  The functions marked by <code>__init</code> can be removed after either kernel boot or module load completes
  and the functions marked by <code>__exit</code> can be removed by the compiler if the code is built
  into the kernel, as these functions would never be called.
</p>
<p>
  Navigate to the NFS file system you unpacked and exported over NFS. Change to the <code>root/hello</code>.
  In the Makefile, I have changed the value of <code>$KDIR</code> as I stashed the kernel source
  in a different location to that specified in the lab book. Run <code>make all</code> to build.
</p>
<p>
  Once built, from the board's console you can type <code>insmod /root/hello/hello_version.ko</code>
  to load the module.
</p>
<p>
  In my <a href="https://github.com/jameshume/free-electrons-linux-kernel-labs/tree/master/hello" target="_blank">GitHub area</a>,
  I've used my own external build, outside the lab directory, but doing it the lab way will also do an external build. I preffered the
  former so that I could stash everything in my GitHub repo more easily.
</p>
<h4>How Linux Verifies &amp; Loads Modules</h4>
<p>
  At this point I want to use some previous learning to talk about how the Kernel loads modules and
  why <b>you should build modules with the <i>exact</i> kernel headers used to compile your kernel</b> <a href="https://glandium.org/blog/?p=2664" target="_blank">[Ref]</a><a href="https://unix.stackexchange.com/questions/125624/unable-to-load-module-disagrees-about-version-of-symbol-module-layout" target="_blank">[Ref]</a>. In summary...
</p>
<blockquote>
  <p>...The Linux kernel contains data structures whose layout varies not only from version to version but also depending on the compilation options. As a consequence, when you compile a kernel module, you need to have not only the header files from the kernel source, but also some header files that are generated during the kernel compilation...
  </p>
  <footer>-- <a href="https://unix.stackexchange.com/questions/125624/unable-to-load-module-disagrees-about-version-of-symbol-module-layout" target="_blank">Gilles' answer</a> on SO</footer>
</blockquote>
<p>
  When you build your module you'll get a whole load of files generated in your module's
  directory.
</p>
<p>
  One file of importance is <code>Module.symvers</code>, which contains a list of all
  exported symbols from a kernel build <a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt" target="_blank">[Ref]</a>
  and their corresponding CRC (if <code>CONFIG_MODVERSIONS</code> is enabled, which it is in this lab).
</p>
<p>
  This set of exported kernel symbols is known as the <em>exported kernel interfaces</em>. Modules
  can only use these explicitly exported functions which are marked as exported in the kernel code
  by the macro <code>EXPORT_SYMBOL_[GPL]</code> (the <code>_GPL</code> suffix is option, i.e., we have 2 macros here).
</p>
<p>
  Another file of import is <code>hello_version.mod.c</code>, which is auto-generated by the build
  and compiled into the resulting <code>.ko</code> kernel object file. The file contains some information
  that is used to &quot;tag&quot; the module with the verssion of the kernel it was built against,
  so that when it is loaded, the running kernel can check that the module was compiled against the
  correct kernel headers <a href="https://glandium.org/blog/?p=2664" target="_blank">[Ref]</a>.
</p>
<p>
  In <code>hello_version.mod.c</code>, the macro <code>MODULE_INFO(vermagic, VERMAGIC_STRING)</code>
  is used (define in <a href="http://elixir.free-electrons.com/linux/latest/source/include/linux/moduleparam.h" target="_blank"><code>linux/moduleparam.h</code></a>). This macro will define a static and constant variable in the section <code>.modinfo</code>.
  The variable name is based on the tag, which in this case is &quot;vermagic&quot;. The value is defined by <code>VERMAGIC_STRING</code> which is
  based on the the kernel version and git repo status. Thus, when
  the module is loaded the kernel can scan the <code>.modinfo</code> section of the module object file
  for the &quot;vermagic&quot; symbol and check that it matches the kernel's own version magic, in
  this way checking that the module being loaded is indeed written for this version of the kernel.
</p>
<p>
  In this file we also see how the module intialisation and exit functions are found by the kernel,
  and also realise what the macros <code>module_init</code> and <code>module_exit</code> do:
</p>
<pre class="prettyprint linenums">__visible struct module __this_module
__attribute__((section(".gnu.linkonce.this_module"))) = {
    .name = KBUILD_MODNAME,
    .init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
    .exit = cleanup_module,
#endif
    .arch = MODULE_ARCH_INIT,
};</pre>
<p>
  So here we can see a structure that is stored in a specific section. When loading the module
  the kernel will be able to find this structure in this section and consult the member variables
  <code>.init</code> and <code>.exit</code> to locate the module's initialisation and exit functions.
</p>

<h4>Debugging</h4>
<p>
  Bugger! The first problem I saw was when I tried to load the module using <code>insmod</code>:
</p>
<pre>[ 7121.807971] hello_version: disagrees about version of symbol <b>module_layout</b>
insmod: can't insert 'hello_version.ko': invalid module format</pre>
<p>
  This implies a mismatch between the kernel version and the header files the module was compiled
  against! This is very strange as I must surely be building against the right kernel... I've built
  the kernel and loaded it on the BB after all!
</p>
<p>
  Refering back to the file <code>hello_version.mod.c</code>, this symbol can be found:
</p>
<pre class="prettyprint linenums">static const struct modversion_info ____versions[]
__used
__attribute__((section("__versions"))) = {
    { 0xb1dd2595, __VMLINUX_SYMBOL_STR(module_layout) },
...</pre>
<p>
This structure is declared in <code>include/linux/module.h</code> and looks like this:
</p>
<pre class="prettyprint linenums">struct modversion_info {
  unsigned long crc;
  char name[MODULE_NAME_LEN];
};</pre>
<p>
  So we can see that the <code>.mod.c</code> file is creating an array of <code>modversion_info</code>
  structs in the section named <code>__versions</code>. The symbol named &quot;module_layout&quot;
  (the macro <code>__VMLINUX_SYMBOL_STR</code> just strigifies it's argument) is given a CRC value of
  <code>0xb1dd2595</code>.
  This CRC value has been read out of <code>Module.symvers</code>.
</p>
<p>
  So, the &quot;invalid module format&quot; message is due to a mismatch between the module's
  recorded CRC for the symbol <code>module_layout</code> and the CRC the kernel expects (see
  <code>check_version()</code> in <code>kernel/module.c</code>). Question is how on earth
  has this happened?!
</p>
<p>
  Just using <code>modprobe -f &lt;module&gt;</code><a href="https://askubuntu.com/questions/14627/no-symbol-version-for-module-layout-when-trying-to-load-usbhid-ko" target="_blank">[Ref]</a> won't get
  me out of trouble here either :(
</p>
<p>
  So, now deciding to enable debug for just <code>kernel/module.c</code> so that the <code>pr_debug()</code> macros
  will become non-empty and emmit debugging information
  <a href="https://www.kernel.org/doc/local/pr_debug.txt" target="_blank">[Ref]</a>.
  When re-building the kernel I used the following:
</p>
<pre class="prettyprint linenums">make clean &amp;&amp; make -j16 CFLAGS_module.o=-DDEBUG</pre>
<p>
  If you type <code>dmesg</code> with debug enabled for <code>module.c</code>, you'll see a lot
  more information output to the system log.
</p>
<p>
  <b>Balls! Cleaning and recompiling kernel solved this issue!</b>
</p>

<h4>Adding A Parameter To The Module</h4>
<p>
  Modules can be given parameters at either boot time, if compiled into the kernel, or on module
  load. They allow some flexibility in module configuration so that, for instance, you could take
  the same binary and run it on different systems by just toggling a parameter... useful!
</p>
<p>
  Define using:
</p>
<pre class="prettyprint linenums">/* params:
 *   name - name if parameter variable you declared in your code and
 *          the name exposed to user (to use different names use
 *          module_param_named())
 *   type - paramers data type: byte | [u]short | [u]int | [u]long |
 *          charp | [inv]bool
 *   perm - octal format or by or'ing S_IRUGO | S_IWUSR etc etc
 */
... definition-of-your-variable-name ...
module_param(name, type, perm);</pre>
<p>
  So for the lab exercise, have to add:
</p>
<pre class="prettyprint linenums">static char *who_param = NULL;
module_param(who_param, charp, 0644);</pre>
<p>
  Another way of doing this would be to get the kernel to copy the string into a buffer:
</p>
<pre class="prettyprint linenums">#define MAX_WHO_SIZE 25
static char who_param_buf[MAX_WHO_SIZE];
module_param_string(who_param, who_param_buf, MAX_WHO_SIZE, 0644);</pre>
<p>
  Recompile the module and then load it by typing, for example:
</p>
<pre class="prettyprint linenums">insmod hello_version.ko who_param=JEHTech</pre>
<p>
  If you want to see the parameters with which a module was loaded you can use
  this for a list of patameters:
</p>
<pre>ls /sys/module/&lt;modul's name&gt;/parameters</pre>
<p>
  To find out what the parameter's value is, cat the file with the parameter's
  name you're interested in.
</p>
<p>
<h4>Adding Time Information</h4>
<p>
  See <code><a href="http://elixir.free-electrons.com/linux/latest/source/include/linux/timekeeping.h#L18" target="_blank">include/linux/timekeeping.h</a></code>.
</p>
<pre class="prettyprint linenums">/*** In your driver */
#include &lt;linux/time.h&gt;
void do_gettimeofday(struct timeval *tv)

/*** From include/uapi/linux/time.h */
struct timeval {
  __kernel_time_t   tv_sec;   /* seconds */
  __kernel_suseconds_t  tv_usec;  /* microseconds */
};</pre>
<p>
   So for our driver, we need to record the time when it was loaded and then record the time when
   it was removed and calculate the difference. Also note that <b>floating point operations
   should not be done in kernel code</b>, in case you were thinking of converting values to doubles
   to do the maths.
</p>
<pre class="prettyprint linenums">/*** Global variables: */
struct timeval load_time, unload_time;

/*** In the init function: */
do_gettimeofday(&amp;load_time);

/*** In the exit function */
struct timeval diff_time;
do_gettimeofday(&amp;unload_time);

diff_time.tv_sec = unload_time.tv_sec - load_time.tv_sec;
diff_time.tv_usec = unload_time.tv_usec - load_time.tv_usec;
if (diff_time.tv_usec < 0) {
   diff_time.tv_usec += 1000000;
   diff_time.tv_sec -= 1;
}

printk(KERN_ALERT "Driver loaded for %ld seconds, %ld usec\n", diff_time.tv_sec, diff_time.tv_usec);
printk(KERN_ALERT "Goodbye\n");</pre>

<h4>Follow Linux Kernel Coding Standards</h4>
<pre>~/linux-kernel-labs/src/linux/scripts/checkpatch.pl --file --no-tree hello_version.c</pre>

<h3>I2C Driver For Wii Nunchuck</h3>
<h4>References</h4>
<ul>
  <li>Essential Linux Device Drivers, S. Vankateswaran, Prentice Hall.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/i2c/instantiating-devices" target="_blank">How To Instantiate I2C Devices</a>, Linux Docs.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/i2c/writing-clients" target="_blank">Writing I2C Clients</a>, Linux Docs.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/i2c/functionality" target="_blank">Checking I2C Functionality Supported</a>, Linux Docs.</li>
  <li><a href="http://free-electrons.com/labs/doc/nunchuk.pdf" target="_blank">Free Electrons Guide To Wii Nunchuck I2C Inteface</a>.</li>
</ul>

<h4>Device Tree Setup</h4>
<p>
  Beagle Bone Black DTS file is in <code>arch/arm/boot/dts/am335x-boneblack.dts</code>. So, I need
  do two three: First, check that the pinmux puts the I2C bus on the J9 pins, second enable the second I2C bus,
  and third create a definition for the new device on that bus.
</p>
<p>
  Snapshot of P9 muxing from data sheet:
</p>
<p>
  <img src="##IMG_DIR##/BeagBlackP9.PNG" alt="Snippet of Beagle Bone Black datasheet showing I2C P9 mux settings"/>
</p>
<p>
  The ARM Cortex-A8 memory map can be found in the AM335x Tech Ref Manual<a href="http://www.ti.com/lit/ug/spruh73p/spruh73p.pdf" target="_blank">[Ref]</a> and the pad control registers (0x44E1_0000) and I2C registers (0x4802_A0000) can be found in section 9.2.2 of the same document. 
  For the register offsets see section 9.3.1. If we look in the <code>am33xx.dtsi</code> file for the
  our chip we will find that the i2c1 interface is located at that address:
</p>
<pre>i2c1: i2c@<b>4802a000</b> {
  compatible = "ti,omap4-i2c";
  ...</pre>
<p>
  This is the only place where i2c1 is defined in the Beagle Bone Black device tree files.
</p>
<p>
  What we're interested in is the MUX mode as in the image above we can see that we will want either
  mode 2 or mode 3 as these are the only two modes for which the I2C1 pins are muxed onto the P9
  connector.
</p>
<p>
  What is a little annoying is that in the above image there are a lot of <em>signal</em> &quot;names&quot;.  These
  names relfect the pin functionality when used in a particular way (i.e., the signal that will 
  be output), but there is a specific name for the actual pin. To find this out one has to
  refer to the AM335x data sheet:
</p>
<p>
  <img src="##IMG_DIR##/bbone_i2c1_pins.png" alt="Snippet of Beagle Bone Black datasheet showing I2C P9 mux settings"/>
</p>
<p>
  To investigate the I2C setup a little further we'll look back at the first I2C bus, I2C0, to see
  how it is being configured in the DTS files...
</p>
<p>
  The pin mux for the first I2C bus looks like this in <code>arch/arm/boot/dts/am335x-bone-common.dtsi</code>:
</p>
<pre>am33xx_pinmux {
  pinctrl-names = "default";
  pinctrl-0 = &lt;&amp;clkout2_pin&gt;;

...

  i2c0_pins: pinmux_i2c0_pins {
      pinctrl-single,pins = &lt;
        AM33XX_IOPAD(0x988, PIN_INPUT_PULLUP | MUX_MODE0) /* i2c0_sda.i2c0_sda */
        AM33XX_IOPAD(0x98c, PIN_INPUT_PULLUP | MUX_MODE0) /* i2c0_scl.i2c0_scl */
      &gt;;
  };</pre>
<p>
  This block of DTS script is defining the pin controller device. It uses the &quot;alternative&quot;
  binding discussed in the Linux pin control bindings doc <a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt" target="_blank">[Ref]</a>. This means that the pin binding is specified
  using a &quot;hardware based index and a number of pin configuration values&quot;, which we see
  specified in the <code>AM3XX_IOPAD()</code> macro.
</p>
<p>
  The node &quot;pinmux_i2c0_pins&quot;, annotated with the label &quot;i2c0_pins&quot; is a
  a pin configuration child node that a client device (any module whose signals are affected by pin
  configuration) can reference. So, we would expect the I2C0 config to reference this... and it does:
</p>
<pre>&amp;i2c0 {
  pinctrl-names = "default";
  pinctrl-0 = &lt;&amp;i2c0_pins&gt;;</pre>
<p>
  Now some vocabulary: a <b>client device</b> is <q>any module whose signals are affected by pin configuration</q>
  <a href="https://www.kernel.org/doc/Documentation/pinctrl.txt" target="_blank">[Ref]</a>. The node
  i2c0 shown above is a client device as it's signals are affected by how the pinmux controller is
  configured.
</p>
<p>
  Each client device can have one or more &quot;pin states&quot;, which are assigned contiguous 
  numbers, starting from zero. So, this client device only has the one &quot;state&quot;.
</p>
<p>
  The field &quot;pinctrl-0&quot; is state number 0. It specifies a list of <em>phandles</em> pointing at pin config nodes,
  which must be (grand)children of the pin controller device.
</p>
<p>
  The field &quot;pinctrl-names&quot; gives a textual name to this particular state
  that can be used. Where there &quot;pinctrl-1&quot;...&quot;pintctrl-N&quot; states, the names list
  would have N+1 members and the first name would name &quot;pinctrl-0&quot;, the second
  &quot;pinctrl-1&quot; and so on. In this case there is only one state named &quot;default&quot;.
</p>
<p>
  Back to the node labelled &quot;i2c0_pins&quot; in the pin controller device... what does the child node &quot;pinctrl-single,pins&quot;
  mean? Well, <q>the contents of each of those ... child nodes is defined entirely by the binding for the 
  individual pin controller device. There exists no common standard for this content&quot; 
  <a href= "https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt"
     target="_blank">[Ref]</a>. There is some clue however... it seems that there does seem to be
  some kind of, at least de-facto, naming convention. Where we see &quot;pinctrl-single,pins&quot;,
  the part before the comma generally is the driver name. So we know (also helps that the lab book
  tells us) that the pinctrl-single driver is being used and a quick search leads us to 
  <a href="http://elixir.free-electrons.com/linux/latest/source/drivers/pinctrl/pinctrl-single.c"
     target="_blank"><code>drivers/pinctrl/pinctrl-single.c</code></a>. 
</p>
<p>
  If we look at the driver we can see that it is described as a <q>one-register-per-pin type device tree based pinctrl driver</q>,
  and that in the function <code>pcs_parse_one_pinctrl_entry()</code> it parses the device tree 
  looking for device nodes with the name &quot;pinctrl-single,pins&quot;. The telling part of the
  function is:
</p>
<pre>/* Index plus one value cell */
offset = pinctrl_spec.args[0];
vals[found].reg = pcs->base + offset;
vals[found].val = pinctrl_spec.args[1];</pre>
<p>
  The &quot;pinctrl-single,pins&quot; property is a list of offsets and value &quot;tuples&quot;,
  which agrees with what we noted about the pin binding being specified
  using a &quot;hardware based index and a number of pin configuration values&quot;.
</p>
<p>
  In the AM335x, each configurable pin has its own configuration register for pull-up/down control and for the 
  assignment to a given module: okay good, matches the pinctrol-single driver's description.  
  Section 9.3 of the TRM, table 9-10, lists the memory-mapped registers for the control module. From this we can see that
  registers 0x988 and 0x98C are labelled conf_i2c0_sda and conf_i2c0_scl respectively, which is
  what we would expect for the I2C0 interface.
</p>
<p>
  Great, i2c0 looks good, which gives us confidence to construct something for i2c1. We have already
  looked up the pin names for i2c1: &quot;spi0_cs0&quot; and &quot;spi0_d1&quot; (we're using mode 2), 
  so we need to look these up in the same table. The table gives us the respective offsets 0x95C and 0x958, so we can 
  construct our addition to the DTSI file...
</p>
<p>
  The pin controller and i2c bus/devices ar defined in <code>am335x-bone-common.dtsi</code> and <code>am335x-boneblack.dts</code>. 
  So, as the lab book instructs I will put my definitions in a new <code>am335x-customboneblack.dts</code> file where I can define the extension
  to the pin controller and a new i2c1 bus node and its nunchuck device node:
</p>
<pre>am33xx_pinmux {
  i2c1_pins: pinmux_i2c1_pins {
      pinctrl-single,pins = &lt;
        AM33XX_IOPAD(0x958, PIN_INPUT_PULLUP | MUX_MODE2) /* i2c1_sda */
        AM33XX_IOPAD(0x95c, PIN_INPUT_PULLUP | MUX_MODE2) /* i2c1_scl */
      &gt;;
  };
};

&amp;i2c1 {
  pinctrl-names = "default";
  pinctrl-0 = &lt;&amp;i2c1_pins&gt;;

  status=&quot;okay&quot;;
  clock-frequency = &lt;100000&gt;;

  wii_nunchuck {
    compatible = "nintendo,nunchuk";
    reg = &lt;0x52&gt;;
  };
};</pre>
<p>
  One last question is where does the make system get information about what DTB to construct for
  our target. The file <code>arch/arm/boot/dts/Makefile</code> lists which DTBs should be
  generated at build time <a href="http://free-electrons.com/pub/conferences/2013/elce/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf" target="_blank">[Ref]</a>. In this file we can see the
  Linux make target <code>dtb-$(CONFIG_SOC_AM33XX)</code>, which lists <code>am335x-boneblack.dtb</code>
  as a target. This is a classic kbuild definition. If <code>CONFIG_SOC_AM33XX</code> is defined then
  this target will be built, otherwise it is ignored.
  Once build the precise build command used are saved in <code>arch/arm/boot/dts/.am335x-boneblack.dtb.cmd</code>.
</p>
<p>
  I'm copying <code>am335x-boneblack.dts</code> to <code>am335x-boneblack-wiinunchuck.dts</code> and
  adding its DTB as a dependency for the <code>dtb-$(CONFIG_SOC_AM33XX)</code> target.
</p>
<p>
  Can build it using:
</p>
<pre>make dtbs</pre>
<p>
  This outputs the file <code>arch/arm/boot/dts/am335x-boneblack-wiinunchuck.dtb</code>. This needs 
  to be copied to the tftp directory on the host and the UBoot boot command changed to download this
  rather than the &quot;stock&quot; DTB file.
</p>


<p>
	Urg... working on another BBB kernel compilation and have created the following, which explains how pinctrl driver is found... 
</p>
<p>
	<img src="##IMG_DIR##/linux_pinmux_bbb.png" alt="pinmux controller and pinmux client in Linux example"/>
</p>
<p>
	This still left me with the question, how does the device that requests a certain pin-muxing, get that pin-muxing? After all, in most
	devices I see requesting a pin-muxing in the device-tree, the doesn't appear to be anything to read the pin-muxing in their <code>probe()</code> function.
	The reason is this (kinda - see paragraphs after the quote too!):
</p>
<blockquote>
	<p>
		When a device driver is about to probe, the <b>device core will automatically attempt to issue pinctrl_get_select_default() on these devices</b>. This way driver writers do not need to add any of the boilerplate code ...

		... So if you just want to put the pins for a certain device into the default state and be done with it, there is nothing you need to do besides providing the proper mapping table. The device core will take care of the rest.
	</p>
	<footer>
		-- <a href="https://01.org/linuxgraphics/gfx-docs/drm/driver-api/pinctl.html#pin-control-requests-from-drivers" target="_blank">Pin control requests from drivers</a>, The Linux driver implementers API guide. (Emphasis mine)
	</footer>
</blockquote>
<p>
	Err... is this true? I've had a little search through the 4.4 kernel and the references I find to <code>pinctrl_get_select_default()</code> are pretty
	minimal. They seem to occur in some device specific files and then ones that look more generic like <code>gpio-of-helper.c::gpio_of_helper_probe()</code>. But even that seems like it is a specific driver, which probably does the pinctrl &quot;boilerplace&quot;, but would need to be compiled into the kernel, and
	in any case only would apparently work for GPIOs.
</p>
<p>
	A search for the device manager and where it might probe devices revealed <code>dd.c::really_probe()</code>, part of the attempt to bind a device with a driver, which calls <code>pinctrl_bind_pins()</code> before probing the device. The comment for <code>pinctrl_bind_pins()</code> says <q>...called by the device core before probe...</q>, which gives us the answer for this kernel. And, in fact, it calls <code>pinctrl_set_state()</code> for the default state. What I also found is that there is an &quot;&init&quot; state too that will superceed the default state at initialisation. The above quote is either inaccurate or for another kernel version.
</p>

<h4>The Linux I2C Core</h4>
<p>
  The I<sup>2</sup>C core is a set of convenience functions for driver developers that &quot;hook&quot;
  into the Linux driver infrastructure...
</p>
<blockquote>
  <p>
    The I<sup>2</sup>C core is a code base consisting of routines and data structures available to
    host adapter drivers and client drivers. Common code in the core makes the driver developer's
    job easier.
  </p>
  <footer>Chapter 8, Essential Linux Device Drivers</footer>
</blockquote>
<p></p>

</div> <!-- End H2 -->

<h2>The Linux Device Tree</h2>
<div>
  <p>
    References:
  </p>
  <ul>
    <li><a href="http://elinux/Device_Tree_Usage" target="_blank">Device Tree Usage</a>, ELinux.org</li>
    <li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf"
           target="_blank">Linux Device Tree For Dummies</a> Thomas Petazzoni.</li>
    <li><a href="https://www.kernel.org/doc/ols/2008/ols2008v2-pages-27-38.pdf" target="_blank">
        A Symphony of Flavours: Using the device tree to describe embedded hardware</a>, G. Likely, J Boyer</li>
    <li><a href="http://elinux.org/Device_Tree_presentations_papers_articles"
           target="_blank">Device Tree presentations papers articles</a>.
    </li>
    <li><a href="https://git.kernel.org/pub/scm/utils/dtc/dtc.git/plain/Documentation/manual.txt?id=HEAD"
           target="_blank">Device Tree Compiler Manual</a>.
    </li>
    <li><a href="https://www.lynxbee.com/how-to-compile-and-install-device-tree-compiler-on-ubuntu/" target="_blank">How To Compile And Install The Device Tree Compiler On Ununtu</a>.</li>
  </ul>
  <p>
    Linux uses device trees to avoid having to recompile the kernel for every single variation
    of a board, for example. So, on one architecture, say for example 64-bit Arm, we don't have
    to recompile the kernel for every possible combination of 64-bit Arm chip and its peripherals.
    Instead, a device tree is stored somewhere, for example an EPROM, and can be passed to the
    kernel at boot time so that the same binary kernel image can run on multiple platforms and
    the platforms themselves tell the kernel binary what they &quot;look&quot; like.
  </p>
  <p>
    The following is a good explanation of what a device tree is:
  </p>
  <blockquote>
    <p>
        In the simplest terms, a device tree is a data structure that
        describes the hardware configuration. It includes information about the CPUs, memory banks, buses,
        and peripherals. The operating system is able to parse the data
        structure at boot time and use it to make decisions about
        how to configure the kernel and which device drivers to
        load.
    </p>
    <footer><a href="https://www.kernel.org/doc/ols/2008/ols2008v2-pages-27-38.pdf" target="_blank">
        A Symphony of Flavours: Using the device tree to describe embedded hardware, G. Likely, J Boyer</a>
    </footer>
</blockquote>
  <p>
    The following image gives a basic, high-level introduction to the device tree file syntax...
  </p>
  <p>
    <img src="##IMG_DIR##/linux_dts_file_format.png" alt="Picture descibing file format of Linux Device Tree"/>
  </p>
  <p>
    Device tree files can also import other device tree files and also C header files so that it is
    easy and less error prone to share named quantities between kernel code and the device tree.
  </p>
  <p>
    The device tree is exposed in Linux under the <code>/proc/device-tree/</code> directory. The directories are paths in the device tree
    and the nodes can all be <code>cat</code>'ed. If you have the device tree compiler on your system, which is contained in the <code>device-tree-compiler</code> package, you can use <code>dtc -I fs /sys/firmware/devicetree/base</code> [<a href="https://unix.stackexchange.com/questions/289563/how-to-list-the-kernel-device-tree" target="_blank">Ref</a>].
  </p>

  <h3>Building DTC From Scratch</h3>
  <p>
    I wanted to run <code>dtc</code> natively on my target to double check that the DTB blobs it was using were correct. To cross build the DTC itself:
  </p>
  <pre>git clone git://git.kernel.org/pub/scm/utils/dtc/dtc.git
cd dtc
export CROSS_COMPILE=arm-linux-gnueabihf-
export ARCH=arm
make V=1 NO_PYTHON=1 # NO_PYTHON stops it trying to build Python library/bindings</pre>

  <h3>Linux DTB Accessor Functions Source</h3>
  <p>
    The device tree access functions are found under the directory <a href="https://elixir.bootlin.com/linux/v3.2/source/drivers/of" target="_blank"><code>drivers/of</code></a>:
  </p>
  <ul>
    <li><a href="https://elixir.bootlin.com/linux/v3.2/source/drivers/of/base.c" target="blank">Base DTB functions</a>
    </li>
    <li><a href="https://elixir.bootlin.com/linux/v3.2/source/drivers/of/irq.c" target="_blank">Interrupt related DTB functions</a>
    </li>
  </ul>

  <h3>Interrupts</h3>
  <div>
    <p>References:</p>
    <ul>
      <li><a href="http://billauer.co.il/blog/2012/08/irq-zynq-dts-cortex-a9/" target="_blank">Interrupt definitions in DTS (device tree) files for Xilinx Zynq-7000 / ARM</a>, Eli Billauer's Tech Blog.
      </li>
      <li>https://saurabhsengarblog.wordpress.com/2015/11/28/device-tree-tutorial-arm/
      </li>
      <li>https://github.com/devicetree-org/devicetree-specification/blob/master/source/devicetree-basics.rst</li>
      <li>https://elinux.org/Device_Tree_Usage</li>
      <li>http://invo-tronics.com/linux-kernel-irq-domain/</li>
    </ul>
    <p>
      In the above image we saw the part of the DTS file that read <code>interrupts = &lt;intr-specifiers&gt;</code>. The interrupt specifiers are an n-tuple, the meaning of which seems specific to the interrupt controller. For example, PCI interrupt numbers only use one cell, whereas the system interrupt controller uses 2 cells for the irq number and falgs. When it is a 3-tuple, it looks like it is likely to mean the following:
    </p>
    <ol>
      <li>
        SPI flag - 0 means device is <i>not</i> using a <u>S</u>hared <u>P</u>eripheral <u>I</u>nterrupt (SPI), anything else means that it is a shared interrupt.
      </li>
      <li>
        Interrupt line number. This is the hardware interrupt number. It is a peripheral interrupt identifier in the actual hardware interrupt controller.
      </li>
      <li>
        Interrupt type - edge, level triggered etc. This can be an ORed combination of some of the flags in <code>irq.h</code>. For example, it could be <code>IRQ_TYPE_LEVEL_HIGH</code> or <code>IRQ_TYPE_EDGE_RISING</code>.
      </li>
    </ol>

    <h4>TODO</h4>
    <pre>  interrupt number loose all kind of correspondence to hardware interrupt numbers:

 mechanism to separate controller-local interrupt numbers, called hardware irqs, from Linux IRQ number: irq_alloc_desc*() and irq_free_desc*() APIs provide allocation of irq numbers

#address-cells
    property indicate how many cells (i.e 32 bits values) are needed to form the base address part in the reg property

#interrupt-cells
    indicates the number of cells in the interrupts property for the interrupts managed by the selected interrupt controller
    #interrupt-cells property is used by the root of an interrupt domain to define the number of &lt;u32&gt; values needed to encode an interrupt specifier. 

    https://github.com/devicetree-org/devicetree-specification/blob/master/source/devicetree-basics.rst


include/linux/of.h:struct device_node {
    const char *name;
    const char *type;
    phandle phandle;
    char    *full_name;

    struct  property *properties;
    struct  property *deadprops;    /* removed properties */
    struct  device_node *parent;
    struct  device_node *child;
    struct  device_node *sibling;
    struct  device_node *next;  /* next device of same type */
    struct  device_node *allnext;   /* next in list of all nodes */
    struct  proc_dir_entry *pde;    /* this node's proc directory */
    struct  kref kref;
    unsigned long _flags;
    void    *data;
#if defined(CONFIG_SPARC)
    char    *path_component_name;
    unsigned int unique_id;
    struct of_irq_controller *irq_trans;
#endif
};

struct property {
    char    *name;
    int length;
    void    *value;
    struct property *next;
    unsigned long _flags;
    unsigned int unique_id;
};

include/linux/of_irq.h: struct of_irq {
    struct device_node *controller; /* Interrupt controller node */
    u32 size;                       /* Specifier size */
    u32 specifier[OF_MAX_IRQ_SPEC]; /* Specifier copy */
};

irq_of_parse_and_map()
  |
  | (and then irq_create_of_mapping():kernel/irq/irqdomain.c)
  v
In of_irq_map_on()
    Get interrupts property - returns an array of u32s
    Get reg property - returns a device_node struct pointer
    interrupt cells
    Get the parent interrupt controller

    Call of_irq_map_raw(p, intspec + index * intsize, intsize, addr, out_irq:of_irq);
                        ^  ^                          ^        ^     ^
                        ^  ^                          ^        ^     stuct filled
                        ^  ^                          ^        reg property
                        ^  ^                          number of values in intr property
                        ^  pointer to first interrupt property in the list
                        ^  + index of the interrupt to resolve
                        ^  * intsize - the #cells in an interrupt property
                        The parent controller

        Search up the interrupt tree to find the first #interrupt-cells property.
        Then search there and further up to find the interrupt-controller and then
        split out the intspec into the out_irq struct's specifier[] array.



irq_create_of_mapping - translate a device tree interrupt specifier to a valid linux irq number.

LOOK IN LOGS FOR: pr_debug("%s: mapped hwirq=%i to irq=%i, flags=%x\n",
         controller->full_name, (int)hwirq, irq, type);</pre>
  </div>


</div>

<h2>Linux Device Drivers</h2>
<div>
<h3>References</h3>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/driver-model/overview.txt"
       target="_blank">Linux Device Driver Model Overview</a>, Linux Docs.
</li>
<li><a href="https://www.kernel.org/doc/Documentation/driver-model/driver.txt"
       target="_blank">Device Drivers, Linux Kernel Docs</a>.
</li>
<li><a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf"
       target="_blank">Linux Kernel and Driver Development Training Slides</a>, FreeElectrons.com.
</li>
</ul>

<h3>Intro</h3>
<p>
  The slides do a fantastic job of describing the Linux driver infrastructure. The following image is
  an annotated rehash of their diagrams with some extra added in from the Linux docs...
</p>
<p>
  <img src="##IMG_DIR##/driver_model.png" alt="Diagram of Linux device driver model. bus_type, device_driver, device."/>
</p>
<p>
  <img src="##IMG_DIR##/linux_device_core_structs.png" alt="Class/struct diagram of core Linux device driver structures."/>
</p>
<p>
  So what is the Linux device driver core? It is a central &quot;repository&quot; that tracks all
  the device busses in the system and their types, all the available drivers and all the devices and
  marries drivers with devices when they are detected.
</p>
<p>
  <b>Bus types</b> define, surprisingly, a type of bus, for example PCI or I2C. The physical hardware that
  manages access to a physical instance of the bus type is called an &quot;<b>adapter driver</b>&quot;. The
  <b>device</b> structure represents physical devices that are attached to am adapter driver and <b>device_driver</b>s
  are bound to devices when a device is detected by the system. All devices have a <b>class</b>
  so that the user can generalise devices by their use.
</p>
<p>
  Having looked through the driver core's code a little it looks like devices will be detected,
  except hot pluggable devices which must have another route to driver binding, like this. The
  driver will register the device(s) for which it caters either at system start-up or dynamically
  (when <code>insmod</code> is called to load a driver). This will eventually result in a call
  to the driver cores <code>device_add()</code>, which will do things like creating the sysfs entries
  for the device, adding the device to the <code>bus_type</code> via <code>bus_add_devices()</code>,
  and finally calling <code>bus_probe_device()</code> which will eventually via either the <code>bus_type</code>
  or directly, call the drivers <code>probe()</code> method. Buses that support hot-plug devices,
  such as USB for example, must have another way to alert the core that a device has become
  available. For now, I'm ending my learning-via-code-base as its probably a bit more depth than I
  need right now.
</p>

<h3>Which Drivers</h3>
<p>
  You can see which drivers are statically compiled into the kernel using the following command <a href="https://superuser.com/questions/577307/how-to-get-a-list-of-active-drivers-that-are-statically-built-into-the-linux-ker" target="_blank">[Ref]</a>.
</p>
<pre class="prettyprint linenums">
cat /lib/modules/$(uname -r)/modules.builtin
</pre>
<p>
  You can see which drivers are loaded as modules using the following:
</p>
<pre class="prettyprint linenums">
cat /proc/modules
# Or to pretty print it...
lsmod
</pre>

<h3>Device Attributes</h3>
<p>
References:
</p>
<ul>
  <li>
    <a href="https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt"
       target="_blank">Sysfs - The file system for exporting kernel objects,</a> Linux Kernel documentation.
  </li>
</ul>
<p>
  Attributes can be represented in the sysfs file system for kobjects, which is useful from a
  device point of view because it allows the driver to intercept read and writes of these attributes
  in order to control a device. For example, the Atmel MaxTouch device driver creates several
  attributes, such as &quot;pause&quot;, which when written to can be used to pause the touch screen
  device being driven. Or, for example, it could export an attribute that would let the user
  configure touch sensitivity for example.
</p>
<p>
  Attributes are defined via the <code>device_attribute</code> structure:
</p>
<pre class="prettyprint linenums">struct device_attribute {
   struct attribute attr;
   ssize_t (*show)(struct device *dev, struct_device_attribute *attr, char *buf);
   ssize_t (*store)(struct device *dev, struct_device_attribute *attr, char *buf, size_t count);
};</pre>
<p>
  You'd make one of these for each attribute you want to create and then register it using:
</p>
<pre>int device_create_file(struct device *, const struct device_attribute *);</pre>
<p>
  To make defining these structures easier use:
</p>
<pre class="prettyprint linenums">DEVICE_ATTR(myname, mode, showFunc, storeFunc)
                          ^^^^^^^^^^^^^^^^^^^
                          Normally you always have a read but may not
                          want to allow a write, in which case
                          storeFunc can be NULL.
</pre>
<p>
  It will create and initialise a <code>device_attribute</code> struct for you and give it the name
  <code>dev_attr_myname</code>, which you can then pass to <code>device_create_file</code>.
</p>
<p>
  The MaxTouch driver has quite a few attributes so stores them in an array of <code>struct attribute</code>,
  which it then embeds in a <code>struct attribute_group</code>, which can be passed in bulk to
  <code>sysfs_create_group()</code>:
</p>
<pre class="prettyprint linenums">static DEVICE_ATTR(myname1, mode1, showFunc1, storeFunc1);
...
static DEVICE_ATTR(mynameN, modeN, showFuncN, storeFuncN);

static struct attribute *mxt_attrs[] = {
   &amp;dev_attr_myName1.attr,
   ...
   &amp;dev_attr_myNameN.attr };

static const struct attribute_group mxt_attr_group = {
  .attrs = mxt_attrs,
};

...

// Later during initialisation...
error = sysfs_create_group(&amp;dev.kobj, &amp;mxt_attr_group);</pre>


<h3>Pin Multiplexing</h3>
<p>
  References:
    <ul>
      <li>
        <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf" target="_blank">Linux Kernel and Driver Development Training Slides</a>, Free Electrons.
      </li>
      <li><a href="https://www.kernel.org/doc/Documentation/pinctrl.txt" target="_blank">PINCTRL (PIN CONTROL) subsystem</a>, Linux Docs.
      </li>
      <li>
        <a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt" target="_blank">Pin Control Bindings</a>, Linux Docs.
      </li>
      <li>
        <a href="https://raw.githubusercontent.com/CircuitCo/BeagleBone-Black/master/BBB_SRM.pdf" target="_blank">BeagleBone Black System Reference Manual</a>, Rev C.1.
      </li>
      <li>
         <a href="http://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/" target="_blank">GPIOs on the Beaglebone Black using the Device Tree Overlays</a>, Derek Molloy.
      </li>
    </ul>

</p>
<p>
  Introduced in v3.2:
</p>
<blockquote>
  <p>Hardware modules that control pin multiplexing or configuration parameters
such as pull-up/down, tri-state, drive-strength etc are designated as pin
controllers. Each pin controller must be represented as a node in device tree,
just like any other hardware module.</p>
<footer><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt" target="_blank">Pin Control Bindings</a>, Linux Docs.</footer>
</blockquote>
<p></p>
<blockquote>
  <p>The pinmux core takes care of preventing conflicts on pins and calling
the pin controller driver to execute different settings.</p>
  <footer><a href="https://www.kernel.org/doc/Documentation/pinctrl.txt" target="_blank">PINCTRL (PIN CONTROL) subsystem</a>, Linux Docs.</footer>
</blockquote>

<p>
  For example, the Beagle Bone Black has a limited number of output pins and you can choose what gets output via the P9 header. For example, P9 pin 17 can be used by either the SPI, I2C, UART or PWM components of the SoC <a href="https://raw.githubusercontent.com/CircuitCo/BeagleBone-Black/master/BBB_SRM.pdf" target="_blank">[Ref]</a>.
</p>

<p>
  A list of a load of pin control device-tree bindings can be found in the Linux source tree documentation folder under <a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/" target="_blank">devicetree/bindings/pinctrl</a>.
</p>

<p>
  From a driver's point of view, it must request a certain pin muxing from the pin control sub system,
  although <q>generally it is discouraged to let individual drivers get and enable pin
  control</q>. So, for example, in the Free Electrons Lab book we would assume that out Wii Nunchuck
  is permanently connected to the system and so our BeagleBone configuration would always be
  setup to enable the I2C muxing on the P9 connector.
</p>

<p>
  To see a list of the claimed pin muxes (and the GPIOS) you can type the following: <code>cat /sys/kernel/debug/pinctrl/44e10800.pinmux/pinmux-pins</code>. Just remember these are the pins of the chip, not just, for example, the GPIO pins!!
</p>

</div> <!-- End H2 -->

<h2>Wait Queues</h2>
<div>
<p>
  References:
</p>
<ul>
  <li><a href="https://lwn.net/Articles/22913/" target="_blank">Driver porting: sleeping and waking up</a>, Corbet on LWN.net.</li>
  <li><a href="https://stackoverflow.com/a/13116914/1517244" target="_blank">Wait queues vs semaphores in Linux</a>, answer StackOverflow by user Anirudh Ramanathan</li>.
  <li><a href="https://github.com/jameshume/MessingWithLinux/blob/master/kernel_timers/kernel_timers_play.c"
         target="_blank">My little toy example</a>. Wait queues and timers.</li>
</ul>
<p>
  The wait queue is a mechanism that lets the kernel keep track of kernel threads that are waiting for
  some event. The event is programmer defined, so each bit of code can declare its own wake queues,
  add kthreads to this queue when they should block waiting on a condition and then signal all kthreads
  waiting on that condition when it is met. The queue, accessed through the wait-queue API, is always
  accessed atomically so many threads can use the same queue to wait on the same condition(s).
</p>
<p>
  <img src="##IMG_DIR##/linux_wait_queues.png" alt="Diagram of Linux Wait Queue structures"/>
</p>
<p>
  <img src="##IMG_DIR##/linux_wait_queues_adding_sequence.png" alt="Diagram of Linux Wait Queue structures, what happens when you initialise them and then add to the wait queue."/>
</p>
<p>
  The basic code structure for waiting on a condition (ripped verbatim, comments added, from the reference) is:
</p>
<pre class="prettyprint linenums">// Define the root of the list of kthreads that wish to
// sleep on whatever condition this queue represents
DECLARE_WAIT_QUEUE_HEAD(queue);

// The wait_queue_t structure that we will add to the above list. This
// struct will hold our task details so we can be woken up later on
// when the condition is met
DECLARE_WAITQUEUE(wait, current);

while(true) {
   // Add this task to the wait queue
   add_wait_queue(&amp;queue, &amp;wait);

   // Tell the scheduler to take us off the runnable queue.
   set_current_state(TASK_INTERRUPTIBLE);

   // The conditions wasn't met so allow scheduler to put someone
   // else on the CPU (won't be use because we've said we dont
   // want to be on the read queue by setting out state above)
   schedule();

   // Check for the condition that is set somewhere else...
   if (condition)
      break;

   // We're awake again which means we either got a signal or
   // the condition has been met
   remove_wait_queue(&amp;queue, &amp;wait);
   if (signal_pending(current))
      return -ERESTARTSYS;
}
set_current_state(TASK_RUNNING);</pre>
<p>
  There's one small thing to note in the above example vs the reference... I had to move where the
  condition was checked. I think their logic was a little wrong because if you don't check after
  the schedule, you'll always do one more wait that you need to!
</p>
<p>
  One thing that I wondered was why would I use a waitqueue over a semaphore or vice versa. Luckily
  just typing it int good led me to this answer:
</p>
<p>
  One or two examples I came across use something called <code>interruptable_sleep_on()</code>, but
  apparently this is deprecated since 2.6 because it is prone to race conditions 
  <a href="http://nixforums.org/about101771.html" target="_blank">[Ref]</a>.
</p>
<blockquote>
  <p>
    A semaphore is more of a concept, rather than a specific implementation ... The Linux semaphore data structure implementation uses a wait-queue. Without a wait queue, you wouldn't know which process demanded the resource first, which could lead to very large wait times for some. The wait-queue <em>ensures fairness</em>, and abates the <em>resource starvation</em> problem.
  </p>
  <footer><a href="https://stackoverflow.com/a/13116914/1517244" target="_blank">Wait queues vs semaphores in Linux</a>, Anirudh Ramanathan</footer>
</blockquote>

<p>Or, instead of using macros to initialisee static variables, you can use:</p>
<pre>init_waitqueue_head(&amp;waitq_head);
init_waitqueue_entry(&amp;waitq_entry, current);</pre>
</div> <!-- End H2 -->


<h2>Work Queues</h2>
<div>
<p>
  Work queues allow you to request that code be run at some point in the future...
</p>
<p>
  <img src="##IMG_DIR##/lin_kern_delayed_work.png" alt="Image of Linux kernel Work Queue structure and construction"/>
</p>
</div> <!-- End H2 -->

<a name="How-Drivers-Request-Firmware"></a>
<h2>How Drivers Request Firmware</h2>
<div>
<p>Snippets from kernel v3.18.20 so possibly already quite out of date :(.</p>
</p>
  <p>
    Drivers for devices that require firmware may want to provide a facility
    by which the firmware can be updated. To do this the driver will call
    the kernel function <code>requst_firmware()</code>:
  </p>
  <pre class="prettyprint linenums">requst_firmware(const struct firmware **firmware_p,
                const char *name,
                struct device *device)</pre>
  <p>Where <code>firmware_p</code> is used to return the firmware image
     identified by the name for the specified device.
  </p>
  <p>Following the code one can see that there are various ways that the
     firmware can be located.
  </p>
  <p>The first location to be searched is the &quot;built-in&quot; location,
     i.e., in the kernel image itself. A special section of the kernel image,
     called <code>.builtin_fw</code>, is created to hold the name and data
     associated with firmware images and is searched as follows:
  </p>
  <pre class="prettyprint linenums"># include/linux/firmware.h
struct builtin_fw {
        char *name;
        void *data;
        unsigned long size;
};

# drivers/base/firware_class.c
extern struct builtin_fw __start_builtin_fw[];
extern struct builtin_fw __end_builtin_fw[];

static bool fw_get_builtin_firmware(struct firmware *fw, const char *name)
{
  struct builtin_fw *b_fw;

  for (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {
    if (strcmp(name, b_fw->name) == 0) {
      fw->size = b_fw->size;
      fw->data = b_fw->data;
      return true;
    }
  }

  return false;
}</pre>
  <p>But how do these files make it into the firmware image in the first place?
     The answer comes for the Makefile <code>firmware/Makefile</code>, a
     snippet of which appears below. Note that the kernel
     must have been built with <code>CONFIG_FIRMWARE_IN_KERNEL=y</code>.
  </p>
<pre class="prettyprint linenums">#./firmware/Makefile
cmd_fwbin = FWNAME="$(patsubst firmware/%.gen.S,%,$@)";                \
            FWSTR="$(subst /,_,$(subst .,_,$(subst -,_,$(patsubst      \
                          firmware/%.gen.S,%,$@))))";                  \
            <i>&lt;snip&gt;</i>
            echo "/* Generated by firmware/Makefile */"           > $@;\
            echo "    .section .rodata"                           >>$@;\
            echo "    .p2align $${ASM_ALIGN}"                     >>$@;\ <b>
            echo "_fw_$${FWSTR}_bin:"                             >>$@;\
            echo "    .incbin \"$(2)\""                           >>$@;\ ## The binary firmware data inserted here
            echo "_fw_end:"                                       >>$@;\ </b>
            echo "   .section .rodata.str,\"aMS\",$${PROGBITS},1" >>$@;\
            echo "    .p2align $${ASM_ALIGN}"                     >>$@;\
            echo "_fw_$${FWSTR}_name:"                            >>$@;\
            echo "    .string \"$$FWNAME\""                       >>$@;\<b>
            echo "    .section .builtin_fw,\"a\",$${PROGBITS}"    >>$@;\ ## Section identified by symbol __start_builtin_fw in gcc
            echo "    .p2align $${ASM_ALIGN}"                     >>$@;\
            echo "    $${ASM_WORD} _fw_$${FWSTR}_name"            >>$@;\ ## struct builtin_fw->name
            echo "    $${ASM_WORD} _fw_$${FWSTR}_bin"             >>$@;\ ## struct builtin_fw->data
            echo "    $${ASM_WORD} _fw_end - _fw_$${FWSTR}_bin"   >>$@;  ## struct builtin_fw->size</b>

<i>&lt;snip&gt;</i>
$(patsubst %,$(obj)/%.gen.S, $(fw-shipped-y)): %: $(wordsize_deps)
    $(call cmd,fwbin,$(patsubst %.gen.S,%,$@))</pre>

<p>
  The <code>patsubst</code> macro finds all white-space seperated words in
  <code>$fw-shipped-y</code> and replaces them with
  <code>$(obj)/&lt;word&gt;.gen.S</code> to create a list of targets for this
  command.
</p>
<p>For each of those targets the command <code>cmd_fwbin</code> is called to
   create the target by echoing the linker section asm commands into an asm
   file (the <code>.incbin</code> puts the image into the section so that
   the firware becomes part of the compiled kernel image). Thus once the
   asm files are created, built and linked into the kernel image, the kernel
   includes these bits of firmware in its final binary.
</p>
<p><code>$fw-shipped-y</code> is part of the KBuild sytax:
</p>
<pre>fw-shipped-$(CONFIG_DRIVER_NAME) += ...</pre>
<p>When a driver defines this variable it will, via the KBuild magic, get
   included in <code>$fw-shipped-y</code> assuming that the kernel was build
   using the <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> config option.
</p>
<p>
  If the image is not found in the built-ins, the next port of call is to
  engage a user-mode helper to grab the contents of the firmware from a file
  and &quot;pipe&quot; it into a driver buffer.
</p>
<p>
  How do we know where on the file system to look? The answer is found in
  <code>drivers/base/firmware_class.c</code>:
</p>
<pre class="prettyprint linenums">/* direct firmware loading support */
static char fw_path_para[256];
static const char * const fw_path[] = {
  fw_path_para,
  "/lib/firmware/updates/" UTS_RELEASE,
  "/lib/firmware/updates",
  "/lib/firmware/" UTS_RELEASE,
  "/lib/firmware",
  "/firmware/image"
};</pre>
<p>
  Where <code>fw_path_para</code> is a string that can be passed to the kernel
  via the command line to allow boot time configuration of where firmware files
  can be looked for.
</p>
</div>

<h2>Debugging</h2>
<div>
	<h3>FTrace</h3>
	<p>
		References:
	</p>
	<ul>
		<li><a href="https://lwn.net/Articles/365835/" target="_blank">Debugging the kernel using Ftrace - part 1</a>.</li>
		<li><a href="https://lwn.net/Articles/366796/" target="_blank">Debugging the kernel using Ftrace - part 2</a>.</li>
		<li><a href="https://lwn.net/Articles/410200/" target="_blank">trace-cmd: A front-end for Ftrace</a>.</li>
		<li><a href="https://lwn.net/Articles/370423/" target="_blank">Secrets of the Ftrace function tracer</a>.</li>
		<li>https://opensource.com/article/17/7/dynamic-tracing-linux-user-and-kernel-space</li>
    <li>https://events.static.linuxfound.org/sites/events/files/slides/linuxconjapan-ftrace-2014.pdf</li>
	</ul>
	<p>
		The above are two really useful references on how to use ftrace to see what is going on inside the kernel using files
		found in <code>/sys/kernel/debug/tracing</code>.
	</p>
	<p>Use the article &quot;Secrets of the Ftrace function tracer&quot; to see
		how to limit the increasible amount of information that can be thrown at you through the trace.
	</p>
	<p>
		To get a nicer interface to the above take a lookg at <code>trace-cmd</code>.
	</p>
</div>

<h2>TO DO</h2>
<h3>Firmware</h3>
<pre>http://www.makelinux.net/ldd3/chp-14-sect-8</pre>
<h3>Jiffies</h3>
<pre>
Defined in http://elixir.free-electrons.com/linux/latest/source/include/linux/jiffies.h
See functions like  time_after(a,b) or time_in_rance(a,b,c) to deal with timer wrapping.
</pre>

<h3>Other time</h3>
<pre>const u64 now = ktime_to_ns(ktime_get());
const u64 end = ktime_to_ns(ktime_get()) + 10; /* 10ns */</pre>

<h3>Sleeping</h3>
<pre>
https://www.kernel.org/doc/Documentation/timers/timers-howto.txt
</pre>

<h3>Kernel Threads</h3>
<pre>
See: http://elixir.free-electrons.com/linux/v4.8/source/kernel/kthread.c

struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char *namefmt, ...);
struct task_struct *kthread_run(int (*threadfn)(void *data), void *data, const char *namefmt, ...);
int kthread_stop(struct task_struct *thread);
/**
 * kthread_stop - stop a thread created by kthread_create().
 * @k: thread created by kthread_create().
 *
 * Sets kthread_should_stop() for @k to return true, wakes it, and
 * waits for it to exit. This can also be called after kthread_create()
 * instead of calling wake_up_process(): the thread will exit without
 * calling threadfn().
 *
 * If threadfn() may call do_exit() itself, the caller must ensure
 * task_struct can't go away.
 *
 * Returns the result of threadfn(), or %-EINTR if wake_up_process()
 * was never called.
 */
 </pre>

<h3>Kernel Semaphores</h3>
<pre>http://cs.unc.edu/~blate/courses/comp530H_F14/pdf/Sync_Schedulie.pdf
http://www.makelinux.net/ldd3/chp-5-sect-3
    if (down_interruptible(&amp;dev->sem))
        return -ERESTARTSYS;

Quote verbatim:
Note the check on the return value of down_interruptible; if it returns nonzero, the operation was interrupted. The usual thing to do in this situation is to return -ERESTARTSYS. Upon seeing this return code, the higher layers of the kernel will either restart the call from the beginning or return the error to the user. If you return -ERESTARTSYS, you must first undo any user-visible changes that might have been made, so that the right thing happens when the system call is retried. If you cannot undo things in this manner, you should return -EINTR instead.

#include &lt;linux/semaphore.h&gt;

</pre>

<h3>Kernel Times</h3>
<p>To schedule a recurring short task that executes in <b>interrupt context</b> and on the CPU
that create the timer.</p>
<pre>
Refernce: http://www.makelinux.net/ldd3/chp-7-sect-4

void timed_function(unsigned long tmrdata)
{
    struct my_data *data = (struct my_data *)tmrdata;
    /* Code to generate the key press */
    /* Atomically access the direction */
    if (I should still be running)
    {
        /* Atomically access configured delay */
        timer.expires += + msecs_to_jiffies(10);
        add_timer(&amp;data->something.timer);
    }
}

struct timer_list timer;
init_timer(&amp;timer);
timer.data = (unsigned long)&amp;mxt_data;
timer.function = volume_key_press_generator_thread;
timer.expires = jiffies + msecs_to_jiffies(10);

-------
See also del_timer() to remove timer from queue and del_timer_sync()
-------

https://github.com/jameshume/MessingWithLinux/blob/master/kernel_timers/kernel_timers_play.c
</pre>

<h3>Build On Ubuntu</h3>
<p>ref: https://www.cyberciti.biz/tips/build-linux-kernel-module-against-installed-kernel-source-tree.html</p>

<p>Wanted this to quickly test and play with some driver stuff that didn't require any actual
hardware... just get familiar with some API</p>
<pre>$ uname -r
4.4.0-83-generic
</pre>
</div>

<pre>
= Misc Notes
== Building Kernel and Drivers
You need to know exactly the confiuration of the kernel on which your modules will be loaded, which means you must compile your kernel before compiling your modules so that you have what is needed to compile your module.

More and more of linux func is modules
1. Reduce size of kernel
2. Speedup the boot time

The kernel build makefile is very complex and needs at least two options to cross compile it - ARCH and CROSS_COMPILE. Default ARCH is the architecture of the host machine, not x86 necessarily.

GCC is the only compiler that can compile the linux kernel. Linux kernel is not a C compliant program because it uses features of GCC that are not specified by the language. But these features are needed to make a kernel, which made the kernel specific to the compiler on which it was tested as these are undefined features of the C language.

Use the "O" option to cmompile out of source so that you can use same source for different build variants.

Never modify .config manually because
1. Tools can check this automatically - use them to detect dependencies between options etc. Avoids incorrect configs.
2. The C compiler cannot read this file. It reads .h files that procide the same options. The config tools generate the .h files in an autogenerated location in the build tree that will duplicate the configuration options provided in the .config file. The source is .config and the output is the .h.

There are 1000s of config options so start with a default config for your board [my_board_or_soc]_defconfig. Used to be board specific but is now SoC specific. The device tree is the BSP. THe kernel tends to be generic for all boards made from one given SoC or even SoCs of a given family and the device tree provides the customisations due to constraints on the system designed using the SoC, e.g. PCB layout.

Build outputs is zImage, uImage. UBoot traditionally use uImage, an image packaged for uBoot, but now uBoot doesn't need this anymore and use, usually, a zImage or a plain image. Images generally include a checksum of some form.

Can avoid mix-and-match attacks when ram disk and kernel version and device tree are not what expected. Built into the new images - FITs. That is why new image isn't used any more. FIT has the same syntax as a device tree with options that can specify how to boot the kernel. FIT = flattened image tree. [See https://elinux.org/images/f/f4/Elc2013_Fernandes.pdf].

zImage not always favoured as decompression works without the MMU, without caches so it is faster to read a non-compressed image. Also before uncompressing itself it has to relocate itself, otherwise it is doing decompression in place which doesnt work. So on 64 bit systems (ARM) normally boot with plain image but 32 bit use zImage.

vmlinux is the ELF file that corresponds to the linux kernel as it will be loaded in virtual memory for execution. Exactly the same format as a linux application. not always ubootable. 

INSTALL_PATH and INSTALL_MOD_PATH are useful and used in installation makefile targets.

Modules are generated througout the build tree so theser have to be grouped to a known location on your ram disk - so use 'make modules_install'. Once here must use 'depmod -a' to create the files needed for Linux device module to work correctly.

When compiling out-of-source render the src tree read-only - it is good practice so that you don't screw up your source tree and need to start using make commands such as 'distclean' etc. (chmod a=rX)

= Linux Modules
init_module and cleanup_module should have a module specific name. Good practice to print loading and unloading message for module load and unload event. But use short messages because prink() disables interrupts whilst using busy-waiting to poll for characters - eek! Don't use printk() elsewhere for this reason - there are new and better debug options!


</pre>

</div>
</body>
</html>
 
 
 
 
 
 
 
 
 

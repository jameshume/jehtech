<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
    <meta charset="UTF-8">                                              <!-- HTML 5 -->
    <title>CMake | JEHTech</title>
    <!-- META_INSERT -->
    <!-- CSS_INSERT -->
    <!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
    -- This is JEHTech --
</div>

<div id="sidebar">
    <h1 class="title">Links...</h1>
    <div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">CMake</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References / useful Links</h2>
<div>
<ul>
    <li>https://github.com/onqtam/awesome-cmake</li>
    <li>https://www.jetbrains.com/help/clion/quick-cmake-tutorial.html</li>
    <li>https://cgold.readthedocs.io/en/latest/overview.html</li>
    <li>https://github.com/toeb/moderncmake/blob/master/Modern%20CMake.pdf</li>
    <li>https://stackoverflow.com/questions/8934295/add-source-in-a-subdirectory-to-a-cmake-project</li>
    <li>https://stackoverflow.com/questions/17653738/recursive-cmake-search-for-header-and-source-files</li>
    <li>https://github.com/ruslo/sugar/wiki/Collecting-sources</li>
    <li>https://crascit.com/2015/02/02/cmake-target-dependencies/</li>
    <li>http://floooh.github.io/2016/01/12/cmake-dependency-juggling.html</li>
    <li>http://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/</li>
    <li>https://cmake.org/pipermail/cmake/2016-May/063400.html</li>
</ul>
<pre>
http://derekmolloy.ie/hello-world-introductions-to-cmake/
https://mirkokiefer.com/cmake-by-example-f95eb47d45b1
https://www.udemy.com/introduction-to-cmake/
https://cgold.readthedocs.io/en/latest/overview/cmake-can.html
https://crascit.com/professional-cmake/
https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/
</pre>
</div> <!-- END References / useful Links -->

<h2>Install From Source</h2>
<div>
    <p></p>
    <pre>sudo apt install build-essential checkinstall zlib1g-dev libssl-dev
wget https://github.com/Kitware/CMake/archive/refs/tags/v3.28.0-rc4.tar.gz
tar -zxvf v3.28.0-rc4.tar.gz
( cd CMake-3.28.0-rc4
    ./bootstrap && make && sudo make install
)
rm -fr CMake-3.28.0-rc4 </pre>
    <p></p>
</div>

<h2>Embedded C Project Template</h2>
<div>
    <pre>
# Project Configuration
cmake_minimum_required(VERSION 3.16)

# Note, project type set to 'NONE' deliberately so that CMake does not search for C compiler before the toolchain
# is configured.
project(my-project-name NONE)

set(CMAKE_VERBOSE_MAKEFILE ON)

# Toolchain
set(CMAKE_SYSTEM_NAME      "Generic")
set(CMAKE_SYSTEM_PROCESSOR "arm")
set(CMAKE_CROSSCOMPILING   true)

# Skip link step during toolchain validation.
set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

set(TOOLCHAIN_TUPLE "arm-none-eabi")
find_program(CMAKE_C_COMPILER   "${TOOLCHAIN_TUPLE}-gcc")
find_program(CMAKE_ASM_COMPILER "${CMAKE_C_COMPILER}")
find_program(CMAKE_OBJCOPY      "${TOOLCHAIN_TUPLE}-objcopy")
find_program(CMAKE_OBJDUMP      "${TOOLCHAIN_TUPLE}-objdump")
find_program(CMAKE_SIZE         "${TOOLCHAIN_TUPLE}-size")

# Search only under *target* paths.
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# Programming Languages - C and Assembly
enable_language(C ASM)

# Target Parameters
set(TARGET_MCU       "STM32F042G6")
set(TARGET_FAMILY    "STM32F0xx")

# Target Compiler/Linker Flags
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Debug")
    message(STATUS "Build type not specified, defaulting to 'Debug'")
endif()

# Compiler Warning Flags
set(TARGET_WARNING_FLAGS  "-Werror"
                            "-Wall"
                            "-Wextra"
                            "-Wshadow"
                            "-Wcast-align"
                            "-Wpointer-arith"
                            "-Wmisleading-indentation"
                            "-Wuninitialized"
                            "-pedantic"
                            "-Wconversion"
                            "-Wsign-conversion"
)
if ("${DEBUG_OUTPUT_METHOD}" STREQUAL "RTT")
    # The RTT libraries generate the following warning: supress it when using RTT.
    list(APPEND TARGET_WARNING_FLAGS -Wno-cast-align)
endif()
STRING(REPLACE ";" " " TARGET_WARNING_FLAGS "${TARGET_WARNING_FLAGS}")

# Common flags and defines - things like "-mcpu=xxx", "-mlittle-endian", "-mthumb" etc
set(TARGET_COMMON_FLAGS   ...flags appropriate to your target...
)
STRING(REPLACE ";" " " TARGET_COMMON_FLAGS "${TARGET_COMMON_FLAGS}")

set(TARGET_DEFINITIONS    "-DCORE_CM0"
                            "-D${TARGET_FAMILY}"
                            "-DEVAL_BOARD"
)
STRING(REPLACE ";" " " TARGET_DEFINITIONS "${TARGET_DEFINITIONS}")

# Segger RTT
# Add `-DDEBUG_OUTPUT_METHOD=RTT` to CMake options in CMake profile to use.
if ("${DEBUG_OUTPUT_METHOD}" STREQUAL "RTT")
    message(STATUS "Using SEGGER RTT protocol for debug output")
    include_directories("${CMAKE_SOURCE_DIR}/path-to-segger-rtt-source-files")
endif ()

set(TARGET_COMPILER_FLAGS "-ffunction-sections -fdata-sections")
set(TARGET_C_FLAGS "-std=c11")
set(TARGET_LD_FLAGS "-Wl,--gc-sections")

set(CMAKE_C_FLAGS "${TARGET_WARNING_FLAGS} ${TARGET_COMMON_FLAGS} ${TARGET_DEFINITIONS} ${TARGET_COMPILER_FLAGS} ${TARGET_C_FLAGS}")
set(CMAKE_EXE_LINKER_FLAGS "${TARGET_COMMON_FLAGS} ${TARGET_LD_FLAGS}")

set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS} -DTARGET_DEBUG  -DAPP_DEBUG -Og -ggdb")
set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${TARGET_COMMON_FLAGS} ${TARGET_LD_FLAGS}")

set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS} -Os -DNDEBUG")
set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${TARGET_COMMON_FLAGS} ${TARGET_LD_FLAGS}")

# Project Layout
set(CMAKE_INCLUDE_CURRENT_DIR true)
set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")

include_directories("${CMAKE_SOURCE_DIR}/...your include dirs ...")

set (CMAKE_EXECUTABLE_SUFFIX ".elf")

SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR})

add_executable(application
    // List c files
)

if ("${DEBUG_OUTPUT_METHOD}" STREQUAL "RTT")
    target_sources(application
            PUBLIC "${CMAKE_SOURCE_DIR}/path-to-segger/SEGGER_RTT.c"
    )
endif ()

set_target_properties(application PROPERTIES LINK_FLAGS "-T'${CMAKE_CURRENT_SOURCE_DIR}/path-to-linker-file.ld'")
    </pre>
    <p></p>

    <h3><code>TARGET_COMMON_FLAGS</code> For Cortex M0</h3>
    <div>
        <pre>
# The target is an ARM Cortex-M0, which implies the thumb instruction set. It is little endian and has no
# hardware FP support.
set(TARGET_COMMON_FLAGS   "-mlittle-endian"
                            "-mcpu=cortex-m0"
                            "-mthumb"
                            "-mfloat-abi=soft"
)
STRING(REPLACE ";" " " TARGET_COMMON_FLAGS "${TARGET_COMMON_FLAGS}")    
        </pre>
        <p></p>
    </div>

    <h3><code>-nostdlib</code> and <code>-ffreestanding</code></h3>
    <div>
        <p>
            For really space constrained firmware you might not want to link against the standard library and will want
            to stop GCC from assuming it can optimise certain functions based on the behaviour of the standard C library.
            For this you need the <code>-nostdlib</code> and <code>-ffreestanding</code>
            directives <a href="https://cs107e.github.io/guides/gcc/" target="_blank">[Ref]</a>.
        </p>
        <pre>
# In addition this project will not link against the standard C library (-nostdlib and -ffreestanding)
#		-nostdlib      controls which libraries to link against
# 		-ffreestanding controls if you are compiling freestanding C (which is part of the C standard).
# 		 			   CAUTION: Even though freestanding is used it seems GCC still requires the freestanding
#                               environment provide memcpy, memmove, memset and memcmp
#                               [https://gcc.gnu.org/onlinedocs/gcc/Standards.html]
set(TARGET_COMMON_FLAGS ...)
list(APPEND TARGET_COMMON_FLAGS "-nostdlib" "-ffreestanding")
STRING(REPLACE ";" " " TARGET_COMMON_FLAGS "${TARGET_COMMON_FLAGS}")
        </pre>
    </div>
</div>

<h2>Include CPPCheck In Your Projects</h2>
<div>
    <pre>
if (${USE_CPPCHECK})
    find_program(CMAKE_CXX_CPPCHECK NAMES cppcheck)
    if (CMAKE_CXX_CPPCHECK)
        MESSAGE(STATUS "Found CPPCheck: `${CMAKE_CXX_CPPCHECK}`")

        get_target_property(CPPCHECK_SOURCES ${PROJECT_NAME}${CMAKE_EXECUTABLE_SUFFIX} SOURCES)

        # Filter the source set if you need too.
        list(FILTER CPP_SOURCES INCLUDE REGEX ...)

        # CPP Check needs the include directories and the compile definitions that the
        # project uses. To get these use a generator expression:
        #     Generator expressions are evaluated during build system generation to produce
        #     information specific to each build configuration.
        set(CPPCHECK_INCS "$&lt;TARGET_PROPERTY:${PROJECT_NAME}.elf,INCLUDE_DIRECTORIES&gt;")
        set(CPPCHECK_DEFS "$&lt;TARGET_PROPERTY:${PROJECT_NAME}.elf,COMPILE_DEFINITIONS&gt;")

        # When using add_custom_command() or add_custom_target(), use the VERBATIM and 
        # COMMAND_EXPAND_LISTS options to obtain robust argument splitting and quoting.
        add_custom_target(
                ${PROJECT_NAME}_cppcheck
                ALL #&lt; Adds to default target, remove to require distinct target to be made
                COMMAND ${CMAKE_CXX_CPPCHECK}
                ${CPPCHECK_SOURCES}
                "-I;$&lt;JOIN:${CPPCHECK_INCS},;-I;&gt;" #&lt; Must be quoted so it is recognised as a generator expression
                "-D$&lt;JOIN:${CPPCHECK_DEFS},;-D&gt;"   #&lt; Must be quoted so it is recognised as a generator expression
                --force
                --enable=all
                --suppress=missingIncludeSystem
                COMMAND_EXPAND_LISTS                     #&lt; Lists in COMMAND arguments will be expanded, including those created with generator expressions
                VERBATIM                                 #&lt; All arguments to the commands will be escaped properly for the build tool 
                USES_TERMINAL
            )
        
            # Or, apparently could use the following, which looks better:
            # "$&lt;LIST:TRANSFORM,$&lt;TARGET_PROPERTY:tgt,INCLUDE_DIRECTORIES&gt;,PREPEND,-I&gt;"
    else()
        MESSAGE(WARNING "Could not find CPPCHECK")
    endif()
endif()
</pre>
</div>

<h2>Include DoxyGen In Your Projects</h2>
<div>
    <pre>
if (${USE_DOXYGEN})
    find_package(Doxygen)
    if (${DOXYGEN_FOUND})
        MESSAGE(STATUS "Doxygen found.")

        set(DOXYGEN_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/...choose a dir name...")
        set(DOXYGEN_IMAGE_PATH "${PROJECT_SOURCE_DIR}/...insert paths here...")
        set(DOXYGEN_RECURSIVE "YES")
        set(DOXY_INPUT "${PROJECT_SOURCE_DIR}/...list dirs here...")
        set(DOXYGEN_FILE_PATTERNS "*.c" "*.h" ...)
        set(DOXYGEN_EXCLUDE_PATTERNS ...anything you'd like to ignore...)
        doxygen_add_docs(
                ${PROJECT_NAME}_doxygen
                ALL #&lt; Adds to default target, remove to require distinct target to be made
                ${DOXY_INPUT}
                COMMENT "Generate Doxygen content"
        )
    else ()
        MESSAGE(WARNING "Doxygen not found. Doxygen output will not be created.")
    endif ()
endif()
    </pre>
</div>

<h2>Misc</h2>
<div>
    <p>
        See search path used: if you want to see which directories CMake is search in your case just call
    </p>
    <pre>cmake -D CMAKE_FIND_DEBUG_MODE=ON</pre>
<p>
    Dump out all variables and their values:
</p>
<pre>get_cmake_property(_variableNames VARIABLES)
foreach (_variableName ${_variableNames})
    message(STATUS "${_variableName}=${${_variableName}}")
endforeach()</pre>
</div> <!-- End Misc -->

</div> <!-- END H1 padding div -->
</div>
</body>
</html>


 

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>wxPython Notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
	<script> 
		$(function(){
			AddLinkToTeleTypeText({
			});
		});
	</script>
</head>

<body>
	<div id="header">
		-- This is JEHTech --
	</div>

	<div id="sidebar">
		<h1 class="title">Links...</h1>
		<div id="includedContent"></div>
	</div>

	<div id="content">
		<h1 class="title">wxPython Notes</h1>
		<div style="padding-right:10px;">
			<h2>Page Contents</h2>
			<div id="page_contents">
			</div>
			
			<h2>References</h2>
			<div>
				<ol>
					<li>
						<a href="http://wiki.wxpython.org/AnotherTutorial"
						   target="_blank">The wxPython Linux Tutorial</a> by Jan Bodnar
					</li>
					<li><a href="http://wxpython.org/Phoenix/docs/html/events_overview.html"
						   target="_blank">Events and Event Handling</a> in wxPython docs.
					</li>
					<li><a href="http://www.blog.pythonlibrary.org/2011/09/20/wxpython-binding-multiple-widgets-to-the-same-handler/"
						   target="_blank">Binding Multiple Widgets to the Same Handler</a> from the Python Library Blog.
					<li>The article &quot;<a href="http://wiki.wxpython.org/self.Bind%20vs.%20self.button.Bind"
						target="_blank">self.Bind vs. self.button.Bind</a>&quot; from wxPyWiki.
					</li>
					<li><a href="https://wiki.wxwidgets.org/WxListCtrl" target="_blank">wxListCtrl</a> on wxWiki.
					</li>
					<li><a href="http://stackoverflow.com/questions/5495053/use-arbitrary-wx-objects-as-a-column-in-a-wx-listctrl"
						target="_blank">Use Arbitrary WX Objects As A Column In A wx.ListCtrl</a> on StackOverflow.
					</li>
					<li><a href="http://stackoverflow.com/questions/10403205/wxpython-error-in-openning-files-in-ubuntu"
						target="_blank">wx.FileDialog And &quot;Recently Opened Files&quot; On Ubuntu</a> on StackOverflow.
					</li>
					<li><a href="http://wiki.wxpython.org/ModelViewPresenter/" 
						target="_blank">Model View Presenter in wxPython Tutorial</a> on wxPyWiki.
					</li>
					<li><a href="http://wxglade.sourceforge.net/tutorial.php"
						target="_blank">wxGlade: a GUI builder for wxWidgets</a>.
					</li>
				</ol>
			</div>

			<h2>Install</h2>
			<div>
				<pre>sudo apt install -y python3 python3-pip python3-dev build-essential libgtk-3-dev libwebkit2gtk-4.0-dev

sudo apt install -y libjpeg-dev libtiff-dev libsdl2-dev libgstreamer-plugins-base1.0-dev \
   libnotify-dev freeglut3-dev libsm-dev libgtk2.0-dev \
   libgtk-3-dev libwebkit2gtk-4.0-dev libgl1-mesa-dev libglu1-mesa-dev \
   libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev 


pip3 install pyext
pip3 install wxPython

# Test 
python3 -c "import wx; app = wx.App(); frame = wx.Frame(None, title='Hello World'); frame.Show(); app.MainLoop()"

# Or if that doesn't work coz its a PITA use...
pip install -U wxPython --find-links https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ubuntu-22.04
</pre>

			</div>

			<h2>The Basic wxPython App</h2>
			<div>
				<h3>The Start</h3>
				<p>
					wxPython is the Python binding to the C++ multi-platform GUI
					library wxWidgets.
				</p>
				<p>
					The most basic Python app looks like this:
				</p>
				<pre class="prettyprint linenums">import wx 

class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)
      #...
      self.Show()

app = wx.App(False)
frame = MyDummyWindow(None, "A Stupid Example")
app.MainLoop()
</pre>
				<p>
					Inherit from <tt>wx.Frame</tt>. In the frame constructor you
					create all the components that are going to go onto the window.
					Give it a <tt>NULL</tt> parent to make it the main window.
				</p>


				<h3>Add Buttons</h3>
				<p>
					Add a button by adding the following into your <tt>Frame</tt>/
					<tt>Panel</tt> (<b>Note: really you should add everything to a panel
					or some other container and not directly to the Frame to render 
					correctly on all platforms...</b> but for
					the sake of brevity in the examples I do).
				</p>
				<pre class="prettyprint linenums">import wx 

class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)<b>
      self._btn1 = wx.Button(self, wx.ID_ANY, "Click me")
      self._btn2 = wx.Button(self, wx.ID_ANY, "Click you")</b>
      self.Show()

app = wx.App(False)
frame = MyDummyWindow(None, "A Stupid Example")
app.MainLoop()
</pre>

				<p>
					The <tt>wx.ID_ANY (-1)</tt> is the component ID... this is a special ID that
					means wxWidgets assigns a unique ID to it... saves us the effort, otherwise
					we have to supply a <em>unique</em> ID ourselves :)
				</p>
				
				<p>
					<b>Eek!</b> There is a problem... the Python script has rendered 
					all the buttons on
					top of eachother. We could place them using absolute coordinates
					manually, but it is much easier to get wxWidgets to organise
					them for us. 
				</p>

				<h3>Basic Sizers</h3>
				<h4>Layout Elements Statically</h4>
				<p>
					To get Python's wxWidgets to automatically position and size our components
					we use sizers. These come in many flavours, the simplest of which
					is the <tt>BoxSizer</tt>:
				</p>

				<pre class="prettyprint linenums">class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)
      self._btn1 = wx.Button(self, wx.ID_ANY, "Click me")
      self._btn2 = wx.Button(self, wx.ID_ANY, "Click you")
<b>
      sizer = wx.BoxSizer(wx.HORIZONTAL)
      sizer.Add(self._btn1)
      sizer.Add(self._btn2)
      self.SetSizerAndFit(sizer)</b>

      self.Show()</pre>

				<p>
					Now, at least, our buttons are not on top of each other: they
					are properly rendered and
					have a reasonable size. As each button is <tt><b>Add()</b></tt>'ed to 
					the sizer it is placed horizontally to the right of the last
					added component. This is because we specified <tt><b>wx.HORIZONTAL</b></tt>.
					The other layout option is <tt><b>wx.VERTICAL</b></tt>.
				</p>
				<p>
					<img src="##IMG_DIR##/python/wxBoxSizerBasic.PNG" alt="Image of wxPython window using a basic wx.BoxSizer to align two wx.Button objects">
				</p>
				<p>
					The image above shows a Python wxWidgets (pyWidgets) window that 
					has been expanded a little.
					What we see is that the buttons stay in the same location and
					do not scale with our window, which may be exactly what we want.
					But what if we'd like then to fill the window?
				</p>
				<h4>Grow Elements With Their Container</h4>
				<p>
					When we <tt>Add()</tt> an element to a sizer we can tell the 
					sizer to automatically size the element to fill up the space
					available using the <b><tt>wx.EXPAND</tt></b> flag.
				</p>
				<p>
					In the case of a <tt>wx.BoxSizer</tt>, the sizer will expand as
					far as possible in all directions. It will then give you the
					option as to which directions the contained elements are 
					expanded.
				</p>
				<p>
					The next parameter to <tt>Add()</tt> is the proportion of the
					space in the <tt>wx.HORIZONTAL</tt> or <tt>wx.VERTICAL</tt>
					direction you wish the element to expand. 
					The proportion is an integer number. Zero means don't resize and
					any other number is the proportion as a fraction of the total
					proportions of all elements in the sizer, that the element size
					will be.
				</p>
				<p>
					For example, if you add two
					components, A and B, with proportions 1 and 2 respectively,
					element A will take up 1/3 of the space and element B will take
					up 2/3 of the space in the sizer's direction.
				</p>
				<p>
					So, let's start with a simple example by changing our
					<tt>Add()</tt> calls from the previous example to the following:
				</p>
				<pre class="prettyprint linenums">sizer = wx.BoxSizer(wx.HORIZONTAL)
sizer.Add(self._btn1<b>, 1</b>) #&lt;&lt; Note the extra parameter
sizer.Add(self._btn2<b>, 2</b>) #&lt;&lt; Note the extra parameter</pre>
				<p>
					Now when the window is expanded we will see the following. As
					you would expect, the buttons expand horizontally to fill the
					space available and the first button takes up 1/3 of the space 
					and the second button 2/3.
				<p>
					<img src="##IMG_DIR##/python/wxBoxSizerProportionsWithoutExpandFlag.PNG" alt="Image of wxPython window using a basic wx.BoxSizer to align two wx.Button objects and expand them horizontally into the available space in the wx.Frame">
				</p>
				<p>
					If we changed our example to use a <tt>wx.BoxSizer(wx.VERTICAL)</tt> 
					we would see the opposite. The elements will fill the vertical
					direction and keep a constant size in the horizontal direction?
				</p>
				<p>
					<img src="##IMG_DIR##/python/wxBoxSizerProportionsVerticallyWithoutExpandFlag.PNG" alt="Image of wxPython window using a basic wx.BoxSizer to align two wx.Button objects and expand them vertically into the available space in the wx.Frame">
				</p>
				<p>
					So, that's great, but what if I want the buttons to take up the
					space in the other direction to the box sizer? I.e, if we 
					take the vertical box sizer example, how do I get the buttons
					not only to expand in the vertical direction but also take up
					the available horizontal space? The answer is a third parameter
					to the <tt>Add()</tt> function... namely <tt><b>wx.EXPAND</b></tt>.
					This flag tells the sizer to take up all the available space and
					size elements to take up all the available space. Again, lets
					modify our code a little bit:
				</p>
				<pre class="prettyprint linenums">sizer = wx.BoxSizer(wx.HORIZONTAL)
sizer.Add(self._btn1, 1<b>, wx.EXPAND</b>) #&lt;&lt; Note the extra parameter
sizer.Add(self._btn2, 1<b>, wx.EXPAND</b>) #&lt;&lt; Note the extra parameter</pre>
				<p>
					Using the above, as we expand the window, we will now see that
					the buttons expand in both the horizontal and vertical directions.
				</p>
				<p>
					<img src="##IMG_DIR##/python/wxBoxSizerProportionsWithExpandFlag.PNG" alt="Image of wxPython window using a basic wx.BoxSizer to align two wx.Button objects and expand them both horizontally and vertically into the available space in the wx.Frame">
				</p>
				<p>
					So, the <tt>wx.EXPAND</tt> tag tells a sizer to expand its 
					components in all directions. To size with a horizontal box sizer
					we get automatic horizontal expansion. To fill the remaining space
					we then need to use the <tt>wx.EXPAND</tt> flag. The same applies for a
					vertical box sizer. We get the vertical expansion &quot;for
					free&quot; and use the expand flag for the rest of the space.
				</p>
				<h4>Space Out</h4>
				<p>
					So, we've seen statically placed buttons that don't move when
					the window expands and buttons that expand with the window. But
					what if we want a bit of padding between the buttons. There are
					two things we can do.
				</p>
				<ol>
					<li>Add in a static amount of space around the object. This 
						space is static because it will not change with the window
						size.
					</li>
					<li>Add in a spacing element that will resize in the same way
						that an object would and therefore is proportional to
						window size.
						</li>
				</ol>
				<p>
					We'll start with the latter. Let's say I want to keep the
					buttons in the center of the window and at a constant size.
					The solution is to add two spaces on the left and right of the
					buttons which will expand to fill the space available. We do 
					this by modifying our last example with the additions in bold:
				</p>
				<pre class="prettyprint linenums"><b>sizer.AddStretchSpacer(1)</b>
sizer.Add(self._btn1, 0)
sizer.Add(self._btn2, 0)
<b>sizer.AddStretchSpacer(1)</b></pre>
				<p>
					What this has done is to add what acts like an invisible element
					each side of the two buttons. The buttons will not grow as the
					window expands because they have a zero proportion. The invisible
					elements each have an equal proportion so once the space for
					the buttons has been accounted for the spacers will take up
					the remaining window space, which effectively centres the buttons:
				</p>
				<p>
					<img src="##IMG_DIR##/python/boxsizerspacers.png" alt="Image of wxPython window using a basic wx.BoxSizer to align two wx.Button objects in the centre of the window using two stretch spacers - AddStretchSpacer()">
				</p>
				<p>
					If you wanted a spacer of a fixed width or height in pixels
					you could also investigate <tt><b>sizer.AddSpacer(size)</b></tt>.
					This spacer will not expand relative to window size: it will keep
					a constant size.
				</p>
				<h4>More</h4>
				<p>
					The parameters we used can be more explicitly stated:
				</p>
				<pre class="prettyprint linenums"><a href="http://www.wxpython.org/docs/api/wx.Sizer-class.html#Add" target="_blank">sizer.Add</a>(self._btn1, proportion=, flag=, border=, ...)</pre>
				<p>
					Border is the border of padding that is to be applied to the
					component. Which of the top, botton, left and right borders are
					used, or padded, is dictated by the <tt>flag</tt> option.
				</p>
				<p>
					Flag is used, as said, partly to specify which borders will have
					the padding added to them and which will be left alone. This
					is done using the following flags: <tt>wx.TOP</tt>, <tt>wx.BOTTOM</tt>, 
					<tt>wx.LEFT</tt>, <tt>wx.RIGHT</tt>, <tt>wx.ALL</tt>.
				</p>
				<p>
					Flag also is used to dicate how the element is aligned in 
					it's box: <tt>wx.ALIGN_CENTER</tt>, 
					<tt>wx.ALIGN_LEFT</tt>, <tt>wx.ALIGN_RIGHT</tt>, 
					<tt>wx.ALIGN_TOP</tt>, <tt>wx.ALIGN_BOTTOM</tt>.
				</p>

				<h3>Basic Event Handling</h3>
				<p>We've got a few buttons, now we need to do something when the
					user clicks 'em... enter events...
				</p>
				<pre class="prettyprint linenums">class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)
      self._btn1 = wx.Button(self, wx.ID_ANY, "Click me")
      self._btn2 = wx.Button(self, wx.ID_ANY, "Click you")
<b>
      self._btn1.Bind(wx.EVT_BUTTON, self.OnBtnClick)
      self._btn2.Bind(wx.EVT_BUTTON, self.OnBtnClick)
</b>
      sizer = wx.BoxSizer(wx.HORIZONTAL)
      sizer.Add(self._btn1, 1, wx.EXPAND)
      sizer.Add(self._btn2, 2, wx.EXPAND)
      self.SetSizerAndFit(sizer)

      self.Show()
<b>
   def OnBtnClick(self, event):
      ctrl_id = event.GetEventObject().GetId()
      if ctrl_id == self._btn1.GetId():
         wx.MessageBox("You pressed the first button")
      else:
         wx.MessageBox("You pressed the second button")</b></pre>

				<p>
					The function <tt>OnBtnClick()</tt> has been created to handle
					button clicks. It receives two objects. The first is the
					standard <tt>self</tt> reference to this class instance. The
					second is the <tt>event</tt> object which describes the event.
				</p>
				<p>
					The <tt>event</tt> object can be used to get the control that
					fired the event using <tt><b>GetEventObject()</b></tt>. Once 
					you have the wxWidget that fired the event, you can call it's
					function <tt><b>GetId()</b></tt> to get the control's ID. This
					can then be used to compare the event-source ID against all 
					the possible widget IDs you are handling.
				</p>
				<p>
					To handle the click event you must register either the button
					or one of its parent windows as a handler for the <tt>EVT_BUTTON</tt>
					type of event. The line <tt><b>self._btn1.Bind(...)</b></tt> in the above
					example registers the button &quot;window&quot; as handling
					this event. When the event fires, the <tt>OnBtnClick()</tt> function
					will be called.
				</p>
				<h4>Event Bubbling</h4>
				<p>
				See the <a href="http://wiki.wxpython.org/self.Bind%20vs.%20self.button.Bind" target="_blank">referenced article [4]</a> for a deeper look at this...
				<p>
				When an object generates a <em>command</em> event, the object or the closest 
					containing window to the event source handles the event first. By 
					default this would be it... the event ends here. However, the
					event can be &quot;bubbled&quot; upwards so that the next closest
					containing window moving up from parent to parent can also get
					a shot at responding to the event:
				</p>
				<pre class="prettyprint linenums">class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)
      self._btn1 = wx.Button(self, wx.ID_ANY, "Click me")
      self._btn2 = wx.Button(self, wx.ID_ANY, "Click you")

      self._btn1.Bind(wx.EVT_BUTTON, self.OnBtnClick)
      self._btn2.Bind(wx.EVT_BUTTON, self.OnBtnClick)
<b>
      self.Bind(wx.EVT_BUTTON, self.OnBtnClick2)
      self.Bind(wx.EVT_BUTTON, self.OnBtnClick2)
</b>
      sizer = wx.BoxSizer(wx.HORIZONTAL)
      sizer.Add(self._btn1, 1, wx.EXPAND)
      sizer.Add(self._btn2, 2, wx.EXPAND)
      self.SetSizerAndFit(sizer)

      self.Show()
<b>
   def OnBtnClick2(self, event):
      wx.MessageBox("Button intercepted")
      # If you uncomment the line below, first the btn handler and then the
      # frame handler respond to this event, otherwise only the btn handler will
      #event.Skip()
</b>
   def OnBtnClick(self, event):
      ctrl_id = event.GetEventObject().GetId()
      if ctrl_id == self._btn1.GetId():
         wx.MessageBox("You pressed the first button")
      else:
         wx.MessageBox("You pressed the second button")</pre>
				<p>
					In the above example an event handler is registered for the
					button and for the frame (the button's parent container).
				</p>
				<p>
					If the <tt><b>event.Skip()</b></tt> function is left commented
					out, when you click the button, only the message box reading
					&quot;Button intercepted&quot; will display. If you uncomment
					the command you will see first the &quot;Button intercepted&quot;
					message box and then the &quot;You pressed...&quot; message box.
				</p>
			</div> <!-- END H2 DIV -->

			<h2>The More Common wxPython Controls</h2>
			<div>
				<h3>Plain Buttons</h3>
				<p>
					Pretty simple control. You can get or set the label, specify the label alignment, decide which
					button in the containing window has focus by default (<code>wx.Button.SetDefault()</code>),
					and enable and disable them:
				</p>
				<pre class="prettyprint linenums">import wx 

class MyDummyWindow(wx.Frame):
   _DISABLE_STR = "Disable"
   _ENABLE_STR  = "Enable"
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)

      self.mainPanelSzr  = wx.BoxSizer(wx.VERTICAL)
      self.mainPanel     = wx.Panel(self)

      self.toggleBtn     = wx.Button( self.mainPanel
                                    , wx.ID_ANY, self._DISABLE_STR)
      self.defaultBtn    = wx.Button( self.mainPanel
                                    , wx.ID_ANY, "Does nothing")
      self.leftAlignBtn  = wx.Button( self.mainPanel
                                    , wx.ID_ANY, "Left", style=wx.BU_LEFT)
      self.rightAlignBtn = wx.Button( self.mainPanel
                                    , wx.ID_ANY, "Right", style=wx.BU_RIGHT)

      self.mainPanelSzr.Add(self.toggleBtn, 1, wx.EXPAND)
      self.mainPanelSzr.Add(self.defaultBtn, 1, wx.EXPAND)
      self.mainPanelSzr.Add(self.leftAlignBtn, 1, wx.EXPAND)
      self.mainPanelSzr.Add(self.rightAlignBtn, 1, wx.EXPAND)

      self.defaultBtn.SetDefault()
      self.toggleBtn.Bind(wx.EVT_BUTTON, self._OnToggleClick)

      self.mainPanel.SetSizerAndFit(self.mainPanelSzr)
      self.winSizer = wx.BoxSizer(wx.HORIZONTAL)
      self.winSizer.Add(self.mainPanel, 1, flag=wx.ALL | wx.EXPAND)
      self.SetSizerAndFit(self.winSizer)
      self.Show()

   def _OnToggleClick(self, event):
      if self.toggleBtn.GetLabel() == self._DISABLE_STR:
         self.toggleBtn.SetLabel(self._ENABLE_STR)
         self.defaultBtn.Enable(False)
      else:
         self.toggleBtn.SetLabel(self._DISABLE_STR)
         self.defaultBtn.Enable(True)

app = wx.App(False)
frame = MyDummyWindow(None, "Static GridBagSizer Example")
app.MainLoop()</pre>

				<h3 class="prettyprint linenums">Image Buttons</h3>
				<p>
					Can have image or image and text.
				</p>
				<pre class="prettyprint linenums">wx.BitmapButton(&lt;owner&gt;, wx.ID_ANY, wx.Bitmap(&lt;path to image&gt;))</pre>

				<h3>A Text Entry Box</h3>
				<p>
					For text entry you can use a <tt><b>wx.TextCtrl</b></tt> widget.
				</p>
				<ul>
					<li><code>GetValue()/SetValue()</code>.
					</li>
					<li><code>SetEditable(&lt;bool&gt;)</code>.
					</li>
				</ul>

			<h3>Build Your Own Progress Dialog</h3>
			<p>
				The standard <code>wx.ProgressDialog</code> is really good and I 
				only learnt about it after building my own. I wanted to present
				messages in my progress dialog so this was my own little effort at constructing
				one. It is a pubsub aware dialog that receives progress and
				termination messages (the thread <em>must</em> send at least
				the latter).
			</p>
			<pre class="prettyprint linenums">import sys
import os
import threading
import time
import wx
from wx.lib.pubsub import setupkwargs #&lt; Put pubsub into "newer" mode
from wx.lib.pubsub import pub

class MyLongRunningThread(threading.Thread):
   def __init__(self, pubNameProgress, pubNameFinished, simulateErrorAtStep=-1):
      super(MyLongRunningThread, self).__init__()
      self._numSteps = 15
      self._pubNameProgress = pubNameProgress
      self._pubNameFinished = pubNameFinished
      self._simulateErrorAtStep = simulateErrorAtStep
      self._errMsg = None
      self._isCanceled = threading.Event()
      self.start()

   def Cancel(self):
      self._isCanceled.set()

   def GetErrorMessage(self):
      return self._errMsg

   def run(self):
      msg = "Error"
      try:
         pub.sendMessage(self._pubNameProgress, percent=0.0, msg="Calculating time...")
         time.sleep(1) # Emulate some pause before progress starts

         for step in range(self._numSteps):
            if self._isCanceled.is_set():
               msg = "Canceled"; break
            time.sleep(1) # Emulate some processes, may raise exception
            pub.sendMessage(self._pubNameProgress, percent=float(step)/self._numSteps*100.0, msg="Something {}".format(step))

            if self._simulateErrorAtStep &gt;= 0 and self._simulateErrorAtStep == step:
               raise Exception("Oops a simulated error occurred")

         if step == self._numSteps - 1:
            msg = "Completed"
      except Exception as e:
         self._errMsg = str(e)
      except:
         self._errMsg = "Unknown error"
      finally:
         pub.sendMessage(self._pubNameFinished, msg=msg)

class MyProgressDialog(wx.Dialog):
   def __init__(self, parent, pubNameProgress, pubNameFinished, workerThread):
       wx.Dialog.__init__(self, parent)

       self._workerThread    = workerThread
       self._pubNameProgress = pubNameProgress
       self._pubNameFinished = pubNameFinished

       self._progress = wx.Gauge(self, range=100)
       pub.subscribe(self._MyThreadProgress, self._pubNameProgress)
       pub.subscribe(self._MyThreadFinished, self._pubNameFinished)

       self.Bind(wx.EVT_CLOSE, self._OnClose)

       self._msg = wx.TextCtrl(self, style=wx.TE_READONLY)
       self._msg.SetValue("Waiting to start...")
       sizer = wx.BoxSizer(wx.VERTICAL)
       sizer.Add(
             wx.StaticText(
                 self, 
                 label="Performing results extraction summarisation:"), 
                 0, 
                 wx.EXPAND | wx.ALL, 5)
       sizer.Add(self._progress, 0, wx.EXPAND | wx.ALL, 5)
       sizer.Add(self._msg, 0, wx.EXPAND | wx.ALL, 5)
       self.SetSizerAndFit(sizer)

       self.SetSize((550,-1)) 
       self.SetMinSize((550,-1)) 

   def _OnClose(self, event):
      event.Veto(True)
      self._msg.SetValue("Please wait whilst operation is canceled...")
      self._workerThread.Cancel()

   def _MyThreadProgress(self, percent, msg):
      def inner():
         if msg is not None: 
            self._msg.SetValue(msg)
         self._progress.SetValue(percent if percent &lt;= 100 else 100)
      wx.CallAfter(inner)

   def _MyThreadFinished(self, msg):
      def inner():
         code = wx.ID_ABORT
         if msg == "Completed":  code = wx.ID_OK
         elif msg == "Canceled": code = wx.ID_CANCEL
         self.EndModal(code)
      wx.CallAfter(inner)

class MyDummyWindow(wx.Frame):
   GO_STR = "Go!"
   UPDATE_STR = "MyDummy.Update"
   FINISH_STR = "MyDummy.Finish"

   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)

      self.workingThread = None
      self.workingDlg    = None
      self.mainPanelSzr  = wx.BoxSizer(wx.VERTICAL)
      self.mainPanel     = wx.Panel(self)
      self.errorChk      = wx.CheckBox(self.mainPanel, wx.ID_ANY, "Sim error?")
      self.goBtn         = wx.Button( self.mainPanel, wx.ID_ANY, self.GO_STR)
      self.goBtn.Bind(wx.EVT_BUTTON, self._OnToggleClick)

      self.mainPanelSzr.Add(self.goBtn, 1, wx.EXPAND)
      self.mainPanelSzr.Add(self.errorChk, 0, wx.EXPAND)
      self.mainPanel.SetSizerAndFit(self.mainPanelSzr)

      self.winSizer = wx.BoxSizer(wx.HORIZONTAL)
      self.winSizer.Add(self.mainPanel, 1, flag=wx.ALL | wx.EXPAND)
      self.SetSizerAndFit(self.winSizer)
      self.Show()

   def _OnToggleClick(self, event):
      if self.goBtn.GetLabel() == self.GO_STR:
         assert(self.workingThread is None)
         self.goBtn.SetLabel("Wait...")
         self.goBtn.Enable(False)

         stepErr = 3  if self.errorChk.IsChecked() else -1
         self.workingThread = MyLongRunningThread( self.UPDATE_STR
                                                 , self.FINISH_STR
                                                 , simulateErrorAtStep = stepErr)
         self.workingDlg = MyProgressDialog( self
                                           , self.UPDATE_STR
                                           , self.FINISH_STR
                                           , self.workingThread)

         result = self.workingDlg.ShowModal()
         if result == wx.ID_ABORT:
            wx.MessageBox(self.workingThread.GetErrorMessage())
         elif result == wx.ID_CANCEL:
            wx.MessageBox("User cancelled")
         else:
            wx.MessageBox("All OKAY!")

         self.goBtn.SetLabel(self.GO_STR)
         self.goBtn.Enable(True)
         self.workingThread = None

app = wx.App(False)
frame = MyDummyWindow(None, "Static GridBagSizer Example")
app.MainLoop()</pre>
			</div> <!-- END H2 DIV -->


			<h2>More wxPython Sizers</h2>
			<div>
				<h3>GridBagSizer</h3>
				<ul>
					<li>Allows you to layout elements in a grid or table-like fashion,</li>
					<li>Each column sized to the largest element in that column (can be modified re &quot;merged&quot; cells which span more than one column),</li>
					<li>Each row sized to the largest element in that row (can be modified re &quot;merged&quot; cells which span more than one row),</li>
					<li>Any set of columns can be made &quot;growable&quot; in seperate proportions: <code>AddGrowableRow(&lt;row-num&gt;, proportion=&lt;number&gt;)</code>. By default columns will not resize,</li>
					<li>Any set of rows can be made &quot;growable&quot; in seperate proportions: <code>AddGrowableCol(&lt;col-num&gt;, proportion=&lt;number&gt;)</code>. By default rows will not resize,</li>
					<li>Cells can be seperated with margins (<code>wx.GridBagSizer(hgap=5, vgap=5)</code>) and can have padding (<code>GridBagSizer.Add(..., border=&lt;number&gt;)</code>).</li>
				</ul>
				<pre class="prettyprint linenums">import wx 

class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)

      self.mainPanelSzr = wx.GridBagSizer(hgap=5, vgap=5)
      self.mainPanel    = wx.Panel(self)
      for idx in range(2):
         self.mainPanelSzr.AddGrowableRow(idx, proportion=idx+1)
         self.mainPanelSzr.AddGrowableCol(idx, proportion=idx+1)

         self.mainPanelSzr.Add( wx.Button( self.mainPanel
                                         , wx.ID_ANY, "B {}".format(idx)
                                         )
                              , pos=(idx,idx) # Cell: row,col
                              , span=(1, 1)   # Cell spans rows,cols
                              , flag=wx.ALL | wx.EXPAND
                              , border=2
                              )
      self.mainPanelSzr.Add( wx.Button( self.mainPanel
                                      , wx.ID_ANY, "A".format(idx)
                                      )
                           , pos=(2,0)   # Cell: row,col
                           , span=(1, 2) # Cell spans rows,cols
                           , flag=wx.ALL | wx.EXPAND
                           , border=2
                           )

      self.mainPanel.SetSizerAndFit(self.mainPanelSzr)

      self.winSizer = wx.BoxSizer(wx.VERTICAL)
      self.winSizer.Add(self.mainPanel, 1, flag=wx.ALL | wx.EXPAND)
      self.SetSizerAndFit(self.winSizer)
      self.Show()

app = wx.App(False)
frame = MyDummyWindow(None, "Static GridBagSizer Example")
app.MainLoop()</pre>
				<p>
					The above example produces the following (annotation in green added):
				</p>
				<p>
				<img src="##IMG_DIR##/python/gridbagsizer.png" alt="Example of wxPython GridBagSizer"/>
				</p>
			</div>

			<h2>wxPython Dialogs</h2>
			<div>
				<h3>Message Boxes</h3>
				<p>
					Easy to show and can be yes/no, ok/cancel kinds. 
				</p>
				<pre class="prettyprint linenums">result = wx.MessageBox( "Do you want to do something?", 
                         "Hello", 
                         style=wx.YES_NO)
if result != wx.YES:
   ## Do something ##</pre>
				<p>
					Unlike the other dialogs below where you check the result
					against <tt>wx.ID_xxx</tt> for the <tt>MessageBox</tt> you
					check agsint <tt>wx.xxx</tt> where xxx is the button name.
					For example, to check <tt>result</tt> for the <tt>wx.OK</tt> button
					you check against <tt>wx.OK</tt> and not <tt>wx.ID_OK</tt>
				</p>

				<p>
					The following styles determine what buttons you get:
				</p>
				<div style="float:left; width:350px;">
					<tt>wx.MessageBox("Example", "Example", wx.YES_NO)</tt><br/>
					<img src="##IMG_DIR##/msgbox_yesno.png" alt="Screenshot of wxPython MessageBox with wx.YES_NO styles"/>
				</div>

				<div style="float:left; width:350px;">
					<tt>wx.MessageBox("Example", "Example", wx.YES_NO | wx.CANCEL)</tt><br/>
					<img src="##IMG_DIR##/msgbox_yesno_cancel.png" alt="Screenshot of wxPython MessageBox with wx.YES_NO and wx.CANCEL styles"/>
				</div>

				<div style="float:left; width:350px;">
					<tt>wx.MessageBox("Example", "Example", wx.OK)</tt><br/>
					<img src="##IMG_DIR##/msgbox_ok.png" alt="Screenshot of wxPython MessageBox with wx.OK styles"/>
				</div>

				<div style="float:left; width:350px;">
					<tt>wx.MessageBox("Example", "Example", wx.OK | wx.CANCEL)</tt><br/>
					<img src="##IMG_DIR##/msgbox_ok_cancel.png" alt="Screenshot of wxPython MessageBox with wx.OK and wx.CANCEL styles"/>
				</div>

				<p style="clear:both;">
					You can determine which button has the initial, default, focus
					by or'ing the the styles <tt>wx.OK_DEFAULT</tt>, <tt>wx.CANCEL_DEFAULT</tt>, 
					<tt>wx.NO_DEFAULT</tt> or <tt>wx.YES_DEFAULT</tt>.
				</p>
				<p>
					You can change the icon displayed in the message box using the following
					styles: <tt>wx.ICON_EXCLAMATION</tt>, 
					<tt>wx.ICON_ERROR</tt>, <tt>wx.ICON_HAND</tt>, <tt>wx.ICON_QUESTION</tt>, or
					<tt>wx.ICON_INFORMATION</tt> (or <tt>wx.ICON_AUTH_NEEDED</tt> (on later versions of wxPython)).
				</p>

				<h3>Open/Load/Save File Dialog</h3>
				<p>
					Very easy to create:
				</p>
					<pre class="prettyprint linenums">dlg = wx.FileDialog(self, 
                    "Open a file", 
                    default_directory, 
                    default_file, 
                    semi_colon_separated_wildcard_string, 
                    wx.FD_OPEN)
if dlg.ShowModal() == <b>wx.ID_OK</b>:
   <b>selectedFile = dlg.GetPath() # Do not use GetFilename()/GetDirectory()</b>
   # do stuff...</pre>
				<p>
					One thing I often want to do is make the dialog remember where
					you last were if you re-open it. It is important do use the 
					dialog method <b><tt>GetPath()</tt></b>, which returns the full
					path to the selected file, and not a combination of 
					<tt>GetFilename()</tt> and <tt>GetDirectory()</tt>. 
					<a href="http://stackoverflow.com/questions/10403205/wxpython-error-in-openning-files-in-ubuntu" 
					   target="_blank">These no longer work, especially on Ubuntu!</a>
				</p>
				<p>
					In the window that is opening the dialog, I usually have a
					&quot;protected&quot; instance variable <tt>_dirNameChache</tt>,
					initialised to the empty string, that is updated everytime the 
					dialog selects a new file. 
				</p>
				<pre class="prettyprint linenums">dlg = wx.FileDialog(self, 
                    "Open file", 
                    self._dirnameCache, 
                    "", 
                    "My files (*.my)|*.my",
                    wx.FD_OPEN)

if dlg.ShowModal() == wx.ID_OK:
   path = dlg.GetPath() 
   <b>self._dirnameCache = os.path.split(path)[0]</b>
   # do more stuff...</pre>
				<p>
					There are more window styles other than <tt>wx.FD_OPEN</tt>. The
					ones I most commonly use are <tt>wx.FD_SAVE</tt>, which will make
					it a save not a load dialog. <tt>wx.FD_OVERWRITE_PROMPT</tt> for 
					save dialog only. It will make the dialog prompt for a confirmation 
					if a file will be overwritten. <tt>FD_FILE_MUST_EXIST</tt> to make
					the load dialog ensure the file exists when it is selected by the user.
				</p>

				<h3>Directory Dialog</h3>
				<pre class="prettyprint linenums">dlg = wx.DirDialog(self, 
                   "Choose directory", 
                   "", 
                   wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST)
if dlg.ShowModal() == wx.ID_OK:
    print dlg.GetPath()</pre>

				<h3>DIY Dialogs</h3>
				<p>
					When trying to force a close of your DIY dialog use the
					<code>EndModal(&lt;exit code&gt;)</code> function. Don't destroy
					the dialog.
				</p>

			</div> <!-- END H2 dialogs -->

			<h2>Publish/Subscribe with wxPython</h2>
			<div>
				<p>
					See the 
					<a href="http://wiki.wxpython.org/WxLibPubSub" 
					   target="_blank">wxPython Pub Sub wiki entry</a>.
				</p>
				<p>
					Import the <tt>pubsub</tt> libraries as follows. The first import
					puts the module API into the &quot;newer&quot; mode.
				</p>
				<pre class="prettyprint linenums">from wx.lib.pubsub import setupkwargs #&lt; Put pubsub into "newer" mode
from wx.lib.pubsub import pub</pre>
				<p>
					<b>Note:</b> If you are receiving pub/sub events from another thread and
					want to update widgets remember to use the <a href="http://wiki.wxpython.org/CallAfter" target="_blank"><tt>wx.CallAfter(<i>func</i>, <i>*args</i>)</tt></a>
					function: <q>...wx.CallAfter takes a function and its arguments, and calls the function when the current event handler has exited. It is a safe way of requesting action of a Window from another thread...</q>.
				</p>
				<p>
					To <b>publish</b> a message do the following:
				</p>
				<pre class="prettyprint linenums">pub.sendMessage(<i>&quot;unique string identifying event&quot;</i>, key1=value1, key2=value2, ...)</pre>
				<p>
					The key/value pairs are passed to any subscriber-functions as named parameters.
				</p>
				<p>
					To <b>subscribe</b> to a message do the following:
				</p>
				<pre class="prettyprint linenums">pub.subscribe(<i>function</i>, <i>&quot;unique string identifying event&quot;</i>)
... &lt;snip&gt; ...
def SubscriberFunction(key1, key2, ...):
   ... &lt;snip&gt; ...</pre>
			</div>
			<p>
				The following is an example using Pub/Sub to create a progress
				dialog that listens for &quot;progress events&quot; and updates
				its progress bar and status message when the event is received.
			</p>
			<pre class="prettyprint linenums">WORKER_PROGRESS="some string identifier you like"

class MyProgressDialog(wx.Dialog):
    def __init__(self, parent):
        wx.Dialog.__init__(self, parent)

        self._progress = wx.Gauge(self, range=100)
        pub.subscribe(self._MyThreadProgress, WORKER_PROGRESS)

        self._msg = wx.TextCtrl(self, style=wx.TE_READONLY)
        self._msg.SetValue("Waiting to start...")
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(wx.StaticText(self, label="This is my demo progress:"), 0, wx.EXPAND | wx.ALL, 5)
        sizer.Add(self._progress, 0, wx.EXPAND | wx.ALL, 5)
        sizer.Add(self._msg, 0, wx.EXPAND | wx.ALL, 5)
        self.SetSizerAndFit(sizer)

        self.SetSize((550,-1)) 
        self.SetMinSize((550,-1)) 

    def _MyThreadProgress(self, percent, msg):
       def inner():
          if msg is not None: self._msg.SetValue(msg)
          self._progress.SetValue(percent if percent &lt;= 100 else 100)
       wx.CallAfter(inner)</pre>
			<p>
				Whilst the dialog is being shown you could for example start a
				worker thread that periodically published progress events. For
				example...
			</p>
			<pre class="prettyprint linenums">pub.sendMessage(WORKER_PROGRESS, percent=int(amountDone*100/totalAmount), msg="Some descriptive message")</pre>

			<h2>Making wxPython Widgets Drop Targets</h2>
			<div>
				<p>
					Want the ability to drop a file or directory on a control and
					receive the path to that file or directory? This is how. Based
					entirely on 
					<a href="http://wiki.wxpython.org/DragAndDrop" 
					   target="_blank">this wxPython wiki entry</a>, 
					which does into far more detail.
				</p>
				<p>
					The snippet was made to allow a <tt>wx.TextCtrl</tt> to receive
					a single file/directory and have the path to it entered in as its
					text value...
				</p>
				<pre class="prettyprint linenums">class FileDropTarget(wx.FileDropTarget):
   def __init__(self, obj):
      wx.FileDropTarget.__init__(self)
      self._obj = obj

   def OnDropFiles(self, x, y, filenames):
      self._obj.SetInsertionPointEnd()
      if len(filenames) &gt; 0:
         self._obj.Clear()
         self._obj.WriteText(filenames[0])

... &lt;snip&gt; ...

class MyPanel(wx.Panel):
   def __init__(self, *args, **kwargs):
      super(MyPanel, self).__init__(*args, **kwargs)

      ... &lt;snip&gt; ...

      self._myTxtCtrl = wx.TextCtrl(self, wx.ID_ANY)
      self._myTxtDT = FileDropTarget(self._myTxtCtrl)
      self._myTxtCtrl.SetDropTarget(self._myTxtDT)

      ... &lt;snip&gt; ...</pre>
			</div> <!-- End H2: Making drop targets -->

			<h2>Draw To A Device Context And Scrollable Windows In wxPython</h2>
			<div>
				<p>
					Based on 
					<a href="https://www.daniweb.com/programming/software-development/threads/73283/scrolles-canvas-in-wxpython" 
					   target="_blank">this example</a>.
				</p>
				<p>
					It appears that to reset the scrollable region you should use
					<tt>SetVirtualSize()</tt> instead of <tt>SetScrollBars()</tt> as the latter will always
					reset the window location, so at very least, couldn't be called
					on a repaint anyway. The former worked for me. <tt>SetScrollBars()</tt> creates them
					but then to resize the what the window thinks is the scrollable region you 	<tt>SetVirtualSize()</tt>.
				</p>
				<pre class="prettyprint linenums">import wx 
 
class MyCanvas(wx.ScrolledWindow):
    def __init__(self, *args, **kwargs):
        super(MyCanvas, self).__init__(*args, **kwargs)
        self.EnableScrolling(True, True)
        self.SetScrollbars(20, 20, 20, 20)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        
    def my_draw(self,dc):
        dc.BeginDrawing()
        lines=[(50,50,507,507)]
        dc.DrawLineList(lines)
        print dc.CanGetTextExtent()
        txtSize = dc.GetFullTextExtent("JEHTech")
        # text, x, y
        print txtSize
        for i in range(200):
           dc.DrawRectangle(10*i,10*i, txtSize[0], txtSize[1])
           dc.DrawRotatedText("JEHTech", 10*i, 10*i, 0)

        dc.EndDrawing()
        return 200*10+txtSize[0]+ txtSize[1]
        
    def OnPaint(self, evt):
        dc = wx.PaintDC(self)
        self.PrepareDC(dc)   
        n = self.my_draw(dc) 
        self.SetVirtualSize((n,n))

class MyDummyWindow(wx.Frame):
   def __init__(self, parent, title):
      wx.Frame.__init__(self, parent, title=title)
      mainSzr = wx.BoxSizer(wx.VERTICAL)
      p = MyCanvas(self, -1)
      mainSzr.Add(p, 1, wx.EXPAND)
      self.SetSizerAndFit(mainSzr)
      self.Show()
 
app = wx.App(False)
frame = MyDummyWindow(None, "A Stupid Example")
app.MainLoop()</pre>
			
				 <p>
				 <a href="http://www.programcreek.com/python/example/14733/wx.GraphicsContext" target="_blank">Also this on wx.GraphicsContext</a>.
				 </p>
			</div>


			<h2>PyCairo And wxPython</h2>
			<div>
				<p>
					TODO wxPython and 
					<a href="https://www.cairographics.org"
						target="_blank">Cairo</a> with <a href="https://www.cairographics.org/pycairo/tutorial/" target="_blank">PyCairo</a>... look 
					<a href="http://wiki.wxpython.org/UsingCairoWithWxPython"
					 target="_blank">at this Wiki guide</a>.
				 </p>
				 <p>
				 	From
				</p>
				<blockquote>
					<p>
						On Windows you can get a Cairo DLL from here:
					</p><p style="margin-left:12pt;">
						<a href="http://www.gtk.org/download-windows.html" target="_blank">http://www.gtk.org/download-windows.html</a>
					</p><p>
						You'll also want to get the zlib and libpng binaries from the same
						page.  Once you get those files extract the DLLs from each of the zip
						files and copy them to some place on your PATH.  Finally, there is an
						installer for the pycairo pacakge here:
					</p><p style="margin-left:12pt;">
						<a href="http://wxpython.org/cairo/" target="_blank">http://wxpython.org/cairo/</a>
					</p>
					<footer>--<a href="https://stuff.mit.edu/afs/athena/system/amd64_deb50/os/usr/share/pyshared/wx-2.8-gtk2-unicode/wx/lib/wxcairo.py" target="_blank">wx.lib.wxcairo</a></footer>
				</blockquote>
				<p>
					Need to try this out as the wxPython 3.x.x demo has a pyCairo
					section to it!
				</p>

			</div> <!-- END H2 PyCairo -->
		</div>
	</div>
</body>
</html>


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

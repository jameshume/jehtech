<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Python notes</title>
	<meta  name="description=" content="Python programming language notes: code quality assurance using PyLint and Flake8, installing modules and more.">
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
	<script>
		$(function(){
			/* Turn all tt elements with functon names in them into the text with a link to the manual */
			$("tt").each(function() {
					if( $(this).html() == "__getattr__()" ) {
						$(this).html('<a href="https://docs.python.org/2/reference/datamodel.html#object.__getattr__" target="_blank">__getattr__()</a>')
					} else if( $(this).html() == "__setattr__()") {
						$(this).html('<a href="https://docs.python.org/2/reference/datamodel.html#object.__setattr__" target="_blank">__setattr__()</a>')
					} else if( $(this).html() == "__setitem__()") {
						$(this).html('<a href="https://docs.python.org/2/reference/datamodel.html#object.__setitem__" target="_blank">__setitem__()</a>')
					}
			});
		});
	</script>
</head>

<body>
	<div id="header">
		-- This is JEHTech --
	</div>

	<div id="sidebar">
		<h1 class="title">Links...</h1>
		<div id="includedContent"></div>
	</div>

	<div id="content">
		<h1 class="title">Python Notes...</h1>
		<h2>Page Contents</h2>
		<div id="page_contents">
		</div>

<h2>To Read</h2>
<div>
	<ul>
		<li>https://docs.python.org/3/library/enum.html</li>
		<li>http://stackoverflow.com/questions/24481852/serialising-an-enum-member-to-json</li>
		<li>https://docs.djangoproject.com/en/1.10/topics/serialization/</li>
		<li>http://stackoverflow.com/questions/2872512/python-truncate-a-long-string</li>
		<li>https://github.com/django/django/blob/master/django/utils/text.py#L66</li>
		<li>http://stackoverflow.com/questions/6567831/how-to-perform-or-condition-in-django-queryset</li>
		<li>https://docs.djangoproject.com/en/1.10/topics/db/sql/</li>
		<li>http://stackoverflow.com/questions/20138428/how-to-create-a-temporary-table-and-not-lose-the-orm-in-django</li>
		<li>http://blog.roseman.org.uk/2010/04/13/temporary-models-django/</li>
		<li>http://stackoverflow.com/questions/34768732/temporary-models-in-django-1-9</li>
		<li>https://code.djangoproject.com/wiki/DynamicModels</li>
		<li>http://stackoverflow.com/questions/1074212/how-to-show-the-sql-django-is-running</li>
		<li>https://mattrobenolt.com/the-django-orm-and-subqueries/</li>
		<li>https://www.caktusgroup.com/blog/2009/09/28/custom-joins-with-djangos-queryjoin/</li>
		<li>http://stackoverflow.com/questions/10598940/django-rename-items-in-values - the second answer not the accepted one</li>
		<li>http://stackoverflow.com/questions/5466571/using-a-settings-file-other-than-settings-py-in-django</li>
		<li>djcelery is tinstalled by running 'pip install django-celery' </li>
		<li>https://pypi.python.org/pypi/django-solo</li>
		<li>https://www.python.org/dev/peps/pep-3333/</li>
		<li>https://docs.python.org/2/library/shlex.html</li>
		<li>https://pymotw.com/2/shlex/</li>
		<li>REST tutorial - http://slides.com/fiznool/no-rest-for-the-whippet#/</li>
		<li>https://docs.python.org/2/library/atexit.html</li>
		<li>https://julien.danjou.info/blog/2015/python-and-timezones</li>
		<li>http://agiliq.com/blog/2009/02/understanding-datetime-tzinfo-timedelta-amp-timezo/</li>
		<li>http://www.saltycrane.com/blog/2009/05/converting-time-zones-datetime-objects-python/</li>
		<li>http://stackoverflow.com/questions/3862310/how-can-i-find-all-subclasses-of-a-class-given-its-name</li>
		<li>https://nedbatchelder.com/text/names.html</li>
		<li>http://louistiao.me/posts/notebooks/embedding-matplotlib-animations-in-jupyter-notebooks/</li>
		<li>https://bit.ly/wtfpython - Python Gotchas</li>
		<li>https://swtch.com/~rsc/regexp/regexp1.html - SLOW REGEX ENGINE</li>
	</ul>
</div>

<h2>Useful Python Related Sites</h2>
<div>
	<ul>
		<li><a href="http://planetpython.org/titles_only.html" target="_blank">Planet Python</a> - A blog aggregating list that lets you keep up with what's new and fresh in the Python world.
		</li>
		<li><a href="http://www.pythontutor.com/" target="_blank">Python Tutor</a> - An awesome site that <i>visually</i> lets you understanding what happens as the computer runs each line of source code! Very cool!
		</li>
	</ul>
</div>

<h2>Python Debugger: Winpdb</h2>
<div>
	<p>A really quite cute Python debugger, easy to use and GUI driver, is <a href="http://winpdb.org/download/" target="_blank">Winpdb</a>:
	</p>
	<p>
	<q>Winpdb is a platform independent GPL Python debugger with support for multiple threads, namespace modification, embedded debugging, encrypted communication and is up to 20 times faster than pdb. Winpdb is being developed by Nir Aides since 2005.</q>
	</p>
</div>

<h2>PyLint: Linting Python Code</h2>
<div>
		<h3>Run PyLint</h3>
		<p>
			Generally you can run pylint on a directory. But note that directory and subdirectories
			you want to check must have the <tt>__init__.py</tt> file in them, even if it is just
			empty.
		</p>
		<p>
			To just run pylint individually on all your python files do this...
		</p>
		<pre  class="prettyprint linenums">find . -name '*.py' | xargs pylint --rcfile=pylint_config_filename</pre>
		<p>
			Use the <code>-rn</code> option to suppress the summary tables at the end of the pylint output.
		</p>
		<p>
			Usefully you can also use PyLint with PyEnchant to add spell checking to your
			comments, which can be pretty useful. To configure the dictionary to use
			just look up the <code>[SPELLING]</code> section in the PyLint RC file!
		</p>

		<h3>Message Format</h3>
		<p>
			The messages have the following format:
		</p>
		<pre class="prettyprint">MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE</pre>
		<p>
			The message type can be one of the following:
			<table style="border: 0px">
				<tr><td><tt>[R]</tt></td> <td>means refactoring is recommended,</td></tr>
				<tr><td><tt>[C]</tt></td> <td>means there was a code style violation,</td></tr>
				<tr><td><tt>[W]</tt></td> <td>for warning about a minor issue,</td></tr>
				<tr><td><tt>[E]</tt></td> <td>for error or potential bug,</td></tr>
				<tr><td><tt>[F]</tt></td> <td>indicates that a fatal error occurred, blocking further analysis.</td></tr>
			</table>
		</p>

		<h3>Configuring Pylint</h3>
		<p>
			If you want to apply blanket settings across many files use the <code>--rcfile=&lt;filename&gt;</code>
			switch. In the rcfile you can specify things like messages to supress at a global level, for example. This
			is much easier than trying to list everything you want to supress on the command line each time
			your run pyline.
		</p>
		<p>
			To generate a template pylint rcfile use:
		</p>
		<pre class="prettyprint linenums">pylint --generate-rcfile</pre>
		<p>
			The default file name that PyLint looks for is either <code>pylintrc</code> or 
			<code>.pylintrc</code>, but you can save it to any filename and then use the 
			<code>--rcfile=</code> option if you like.
		</p>

		<p>
			Inside the generated rcfile there are a few things that can be interesting. The
			most interesting is the <tt>init-hook</tt> which you can set, for example, to
			update the <tt>PYTHONPATH</tt> so that pylint can find all the imported modules:
		</p>
		<pre class="prettyprint linenums">[MASTER]
init-hook='import sys; sys.path.append(...);'</pre>
		<p>
			Note that the string is a one-liner python script.
		</p>

		<h3>Explain An Error Message</h3>
		<p>
			In an error message you will get, at the end of the message a string in parenthesis.
			For example you light see something like this:
		</p>
		<pre>C:289, 4: Missing method docstring (missing-docstring)
C:293, 4: Invalid method name "im_an_error" (invalid-name)</pre>
		<p>To get help on either of these errors, type:</p>
		<pre>pylint --help-msg=missing-docstring</pre>
		<p>
			Or...
		</p>
		<pre class="prettyprint linenums">pylint --help-msg=invalid-name</pre>

		<h3>Suppressing Error Messages</h3>
		<p>
			To disable an error message for the entire file use <code>--disable=msg-name</code>. So, if you want to
			ignore all missing docstrings use <code>--disable=missing-docstring</code>.
		</p>
		<p>
			Find all <a href="http://pylint-messages.wikidot.com/all-codes" target="_blank">PyLint codes here</a>. Or, you can use the command line
			&quot;<b><tt>pylint --list-msgs</tt></b>&quot; to list error messages and their corresponding codes.
		</p>
		<p>
			To supress an error message for a specifc line of code, or for a block of code (put comment on first line of block start),
			use <tt>#pylint: disable=...</tt>
		</p>

		<h3>Longer/Different Allowed Function/Variable/etc Names</h3>
		<p>
			Sometimes I just want names longer than 30 characters. You could say that these names
			are too long, but then, esp. for functions, I find shortening the name makes it less
			meaningful or introduces abbreviations for things, which can make the code harder to
			read, esp. if the aabreviation isn't a standard/well-known one.
		</p>
		<p>
			In your rcfile navigate to the section <tt>[BASIC]</tt>. Here you can edit the regular
			expressions that are used to validate things like functions names. E.g., I sometimes
			change:
		</p>
		<pre>function-rgx=[a-z_][a-z0-9_]{2,30}</pre>
		<p>
			To:
		</p>
		<pre>function-rgx=[a-z_][a-z0-9_]{2,<b><u>40</u></b>}</pre>

		<h3>Supress Warnings For Unused Function Arguments</h3>
		<p>
			Often you'll be defining something like a callback or implementing an interface etc
			but won't need to use all the function arguments. By default PyLint will bitch
			about this, but to get it to ignore the variable just prefix the variable
			name with either &quot;dummy&quot; or &quot;_&quot;.
		</p>

		<h3>Use PyLint To Count LOC</h3>
		<p>
			Thanks to the author of, and comments made, for the following
			<a href="http://stackoverflow.com/questions/9076672/how-to-count-lines-of-code-in-python-the-right-way#answer-15360716" target="_blank">
				StackOverflow post</a>.
		</p>
		<p>
			Although LOC is not a good metric in the sense that many lines of bad code is still bad, to get a reasonable
			count of the lines of code (LOC) for all Python files contained in the current folder and all subfolders,
			use the following command.
		</p>
		<pre class="prettyprint linenums">find . -name '*.py' | xargs pylint 2&gt;&amp;1 | grep 'Raw metrics' -A 14</pre>
		<p>
			<tt>xargs</tt> takes the output of <tt>find</tt> and uses it to construct a parameter list that is
			passed to <tt>pylint</tt>. I.e. we get <tt>pylint</tt> to parse all files under our source tree. This output is
			passed to <tt>grep</tt> which searches for the &quot;Raw Metrics&quot; table heading and then outputs it along
			with the next 14 lines (due to the <tt>-A 14</tt> option).
		</p>

		<h3>Spell Check Your Comments</h3>
		<p>
				On Linux systems you can use the <code>enchant</code> library paired with <code>pyenchant</code> to
				add spell checking to your comments.
		</p>
		<p>
			Install dependencies:
		</p>

		<pre class="prettyprint linenums">sudo apt install enchant
sudo pip3 install pyenchant</pre>

			<p>Then you can lint using these options:
			</p>

			<pre class="prettyprint linenums">pylint3 \
	--enable spelling \
	--spelling-dict en_GB \
	--spelling-private-dict-file mt-dict.txt \
	FILENAME.py</pre>
		<p></p>

		<h3>Find Similar/Duplicate Code</h3>
		<pre class="prettyprint linenums">pylint --disable=all --enable=similarities src/</pre>
		<p></p>
</div>

<h2>Flake8</h2>
<div>
	<p>Flake8 is another static analyser / PEP8 conformace checker to python. I have found that
		sometimes it finds things that pylint doesn't and vice versa, so hey, why not use both?!
	</p>
	<p>
		To configure it with the equivalent of a pylint rcfile just create the file <tt>tox.ini</tt>
		or <tt>setup.cfg</tt> (I prefer the former as the latter is a little too generic) in the
		directory that you run flake8 from. This avoids having to use a global config file - you
		can have one per project this way. All the command line options that you would configure
		flake8 with become INI file style settings. For example, if you ran:
	</p>
	<pre class="prettyprint linenums">flake8 --ignore=E221 --max-line-length==100</pre>
	<p>
		This would become the following in the config file (note the file must have the
		header <tt>[flake8]</tt>:
	</p>
	<pre class="prettyprint linenums">[flake8]
ignore = E221
max-line-length = 100</pre>
</div>

<h2>Installing Python Libraries From Wheel Files</h2>
<div>
	<p>
		<a href="http://pythonwheels.com/" target="_blank">Python wheels</a>
		<q>are the new standard of python distribution</q>. First make sure you have wheels
		installed:
	</p>
	<pre class="prettyprint linenums">pip install wheel</pre>
	<p>
		Once you have installed wheels you can download wheel files (*.whl) to anywhere on your
		computer and run the following:
	</p>
	<pre class="prettyprint linenums">pip install /path/to/your/wheel/file.whl</pre>
	<p>
		So, for example, when I wanted to install lxml on my Windows box, I went to Christoph Gohlke's
		<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank">Unofficial Windows Binaries for Python Extension Packages</a>
		and downloaded the file <tt>lxml-3.6.4-cp27-cp27m-win_amd64.whl</tt> and typed the following:
	</p>
	<pre class="prettyprint linenums">pip install C:\Users\my_user_name\Downloads\lxml-3.6.4-cp27-cp27m-win_amd64.whl</pre>
</div> <!-- END H2 Install Python Libraries From Wheel Files -->

<h2>Windows Python Module Installers: When Python Can't Be Found</h2>
<div>
	<p>
		It seems, when I install Windows Python from scratch that some installers will give the
		following error message:
	</p>
	<pre>python version 2.7 required, which was not found in the registry</pre>
	<p>
		The answer on how to overcome this is found in this
		<a href="http://stackoverflow.com/questions/17872234/how-to-add-python-to-windows-registry" target="_blank">SO thread</a>,
		credits to the answer's author!
	</p>
	<p>
		To summarise, Windows Python Installer created <tt>[HKEY_LOCAL_MACHINE\SOFTWARE\Python]</tt>
		and all the subkeys therein, but not <tt>[HKEY_CURRENT_USER\SOFTWARE\Python]</tt>. Oops!
		Easiest way to evercome this is to load <tt>regedit.exe</tt> and natigate to the
		<tt>[HKEY_LOCAL_MACHINE\SOFTWARE\Python]</tt>. Righ click on this entry and export it to
		a file of your choosing. Then edit the file to replace all occurrences of <tt>HKEY_LOCAL_MACHINE</tt>
		with <tt>HKEY_CURRENT_USER</tt>. Save it and double click it to install the Python info
		to the current user registery keys. Now the installers will run :)
	</p>
	<p>
		For example, my registery file, after edit looked like this:
	</p>
	<pre class="prettyprint linenums">Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\SOFTWARE\Python]

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore]

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7]

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7\Help]

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7\Help\Main Python Documentation]
@="C:\\Python27\\Doc\\python2712.chm"

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7\InstallPath]
@="C:\\Python27\\"

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7\InstallPath\InstallGroup]
@="Python 2.7"

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7\Modules]

[HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore\2.7\PythonPath]
@="C:\\Python27\\Lib;C:\\Python27\\DLLs;C:\\Python27\\Lib\\lib-tk"</pre>
</div>

<h2>Running Python 2 and 3 on Windows</h2>
<div>
<p>
	See <a href="https://stackoverflow.com/questions/341184/can-i-install-python-3-x-and-2-x-on-the-same-windows-computer" target="_blank">this SO thread</a>. To summarise:
</p>
<pre>## Run scripts:
py -3 my_script.py # execute using python 3
py -2 my_script.py # execute using python 2

## Run pip:
pip3 (alias)
py -3 -m pip install ... # Python 3 pip install
py -2 -m pip install ... # Python 2 pip install</pre>
</div>

<h2>Python functions gotcha: default argument values - default value evaluated only once!</h2>
<div>
	<p>
		Ooh this one is interesting and is not at all how I intuitively imagined default values.
		I assumed that when a function parameter has a default value, that on <em>every</em>
		call to the function, the parameter is initialised with the default value. This is
		<em>not</em> the case, as I found <a href="http://docs.python-guide.org/en/latest/writing/gotchas/" target="_blank">[Ref]</a>!
		The default value is evaluated only once and acts like a static variable in a
		C function after that! The following example is taken from the
		<a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" target="_blank">Python docs on functions</a>:
	</p>
	<pre class="prettyprint linenums">def f(a, L=[]):
    # Caution! You might not expect it but this function accumulates
    # the arguments passed to it on subsequent calls
    L.append(a)
    return L

print(f(1))  # Prints [1]
print(f(2))  # Prints [1, 2], not [2] as you might expect!</pre>
	<p>
		This is summarised in the docs...
	</p>
	<blockquote>
		<p>
			The default value is evaluated only once. This makes a difference when
		 	the default is a mutable object such as a list, dictionary, or instances of most classes ...
        	[because] the default ... [will] be shared between subsequent calls ...
        </p>
        <footer>-- <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" target="_blank">Python docs</a>.</footer>
	</blockquote>
	<p></p>
</div>

<h2>Python Binding (vs C++11 Binding)</h2>
<div>
	<p>
		Python lambda's bind late (are lazily bound) <a href="https://en.wikipedia.org/wiki/Lazy_evaluation"
		target="_blank">[Ref]</a>. This means the the following code will have the output shown:
	</p>
	<pre class="prettyprint linenums">x = 1
f = lambda y: y * x
print f(2)
x = 10
print f(2)
# Outputs:
# 2
# 20</pre>
	<p>
		I.e., the value of x is looked up in the surrounding scope when the function is <em>called</em> and <em>not</em> when the expression
		creating the lambda is evaluated. This
		means that in the statement <code>f = lambda y: y * x</code>, the variable <code>x</code> is <em>not</em>
		evaluated straight away. It is delayed until <code>x</code> is actually needed. Hence the two different
		values are output when we call <code>f(2)</code> with the same parameter value.
	</p>
	<p>
		We can go to the <a href="https://docs.python.org/2/reference/executionmodel.html#naming-and-binding" target="_blank">Python docs</a>
		for further information:
	</p>
	<blockquote>
		<p>
			A block is a piece of Python program text that is executed as a unit. The following are blocks:
			<ul>
				<li>A module,</li>
				<li>A function body,</li>
				<li>A class,</li>
				<li>A script file,</li>
				<li>...</li>
			</ul>
		</p>
		<p>
			... When a name is used in a code block, it is <b>resolved using the nearest enclosing scope</b>.
			The set of all such scopes visible to a code block is called the block’s environment ...
	    </p>
	    <p>
	    	If a name is bound in a block, it is a local variable of that block.  ...
	    	If a variable is used in a code block but not defined there, it is a <b>free variable</b>.
	    </p>
	    <footer>-- <a href="https://docs.python.org/2/reference/executionmodel.html#naming-and-binding" target="_blank">Python docs</a></footer>
    </blockquote>
    <p>
    	So, we can see that in the lambda expression above, the variable <code>x</code> is a free variable.
    	So, it is resolved using the nearest enclosing scope. The nearest enclosing scope in the above example
    	happens to be the global scope.
    </p>
	<p>
		This is the same example as you find in many classic examples <a href="http://docs.python-guide.org/en/latest/writing/gotchas/"
		target="_blank">[Ref]</a>, replicated here:
	</p>
	<pre class="prettyprint linenums">def create_multipliers():
   return [lambda x : i * x for i in range(5)]

for multiplier in create_multipliers():
   print multiplier(2)

# Outputs
# 8 8 8 8 (newlines removed for brevity)</pre>
	<p>
		Why does it output 8's? Because the list comprehension creates a list of lambda functions,
		in which the variable <code>i</code> has <em>not yet</em> been evaluated. By the time
		we come to evaluate the lambda <code>i</code> is set to 4. How is <code>i</code> evaluated?
		As it is a free variable in the lambda it is &quot;resolved using the nearest enclosing scope&quot;.
		The nearest enclosing scope is the function body of <code>create_multiplies()</code> (because
		a list comprehension is not a block, so <code>i</code> is bound in <code>create_multiplies()</code>).
		By the time <code>create_multiplies()</code> exits, <code>i</code> is 4, but because the lambda
		closes this scope, every time <code>i</code> is looked up, it is 4, because the lookup of <code>i</code>
		does not occur until later, when the lambdas are actually evaluated.
	</p>
	<p>
		I.e., <code>create_multipliers()</code> is called. This creates a list of 4 lambda functions:
	</p>
	<pre class="prettyprint linenums">[lambda1, lambda2, lambda3, lambda4]</pre>
	<p>
		Each <code>lambdaX</code> has not yet been evaluated, so by the time this list has been
		create, the variable <code>i</code> has the value 4. Later, when any of the lambda functions
		are called, <code>i</code> is evaluated so Python searches down the scope chain until it
		finds the first <code>i</code>, which it does and in this case it has the value 4!
	</p>
	<p>
		Note, that this is a little different in C++. In C++ (C++11 or greater) however, you
		would have to pass x by reference to get the same result. If we transliterate the first
		example to C++ we get:
	</p>
	<pre class="prettyprint linenums">#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
	int x = 1;
	auto myLambda = [x](int y) {
		return x * y;
	};
	std::cout &lt;&lt; myLambda(2) &lt;&lt; "\n";
	x = 10;
	std::cout &lt;&lt; myLambda(2) &lt;&lt; "\n";
	return 0;
}
// Prints:
// 2
// 2 (notice here Python would print 20!</pre>
	<p>
		To get the behaviour of Python we have to do the following:
	</p>
	<pre class="prettyprint linenums">auto myLambda = [<b><u>&amp;</u></b>x](int y) {
		return x * y;
	};</pre>
	<p>
		Note the ampersand added before <code>x</code> so that the outer scope is passed
		to the lambda by reference, not value!
	</p>

</div> <!-- END Python Binding -->


<h2>Infinite recursion in <tt>__setattr__()</tt> &amp; <tt>__getattr__()</tt> in Python</h2>
<div>
		<h3>The recursion problem</h3>
		<p>In most, if not all, of the little tutorials I used to learn about
			<tt>__setattr__()</tt> and <tt>__getattr__()</tt>
			seemed either to treat them independently, in other words, the example classes had one or the other
			defined but not both, or used both but had very simple use cases. Then as I started to play with them, in
			my newbie-to-python state, I did the following (abstracted out into a test case). This also
			serves as a little Python <tt>__setattr__</tt> example and a Python <tt>__getattr__</tt> example...
		</p>
		<pre class="prettyprint linenums">class Test(object):
	def __init__(self):
		self._somePrivate = 1

	def __getattr__(self, name):
		print "# GETTING %s"  % (name)
		if self._somePrivate == 2:
			pass
		return "Test attribute"

	def __setattr__(self, name, val):
		print "# SETTING %s" % (name)
		if self._somePrivate == 2:
			pass
		super(Test, self).__setattr__(name, val)

t = Test()
print t.someAttr</pre>
		<p>Running this causes a the maximum recursion depth to be reached:</p>
		<pre class="prettyprint linenums">$ python test1.py
# SETTING _somePrivate
# GETTING _somePrivate
...&lt;snip&gt;...
# GETTING _somePrivate
Traceback (most recent call last):
  File "test1.py", line 17, in <module>
    t = Test()
  File "test1.py", line 3, in __init__
    self._somePrivate = 1
  File "test1.py", line 13, in __setattr__
    if self._somePrivate == 2:
  File "test1.py", line 7, in __getattr__
    if self._somePrivate == 2:
  ...&lt;snip&gt;...
  File "test1.py", line 7, in __getattr__
    if self._somePrivate == 2:
RuntimeError: maximum recursion depth exceeded</pre>

		<p>As I had read up on the subject it was clear that one can't set an attribute in
			<tt>__setattr__()</tt> because that would just cause <tt>__setattr__()</tt> to
			be called again resulting in infinite recursion (until the stack blows up!). The solution (in &quot;new&quot;
			style classes which derive from object) is to call the parent's <tt>__setattr__()</tt> method. As for <tt>__getattr__()</tt>, from the documentation it was also clear
			that &quot;...if the attribute is found through the normal mechanism, <tt>__getattr__()</tt> is <em>not </em> called...&quot;.</p>
		<p>So, I thought that was all my recursion problems sorted out. Also, if you delete either the <tt>__getattr__()</tt> or <tt>__setattr__()</tt>
			from the above example, it works correctly. So for example...</p>
		<pre class="prettyprint linenums">class Test2(object):
	def __init__(self):
		self._somePrivate = 1

	def __getattr__(self, name):
		print "# GETTING %s"  % (name)
		if self._somePrivate == 2:
			pass
		return "Test attribute"

t = Test2()
print t.someAttr</pre>
		<p>... the above test program works as expected and outputs the following.</p>
		<pre class="prettyprint linenums"># GETTING someAttr
Test attribute</pre>

		<p>So, what is it about the first example that causes the infinite recursion? The first problem is this little line in the constructor...</p>
		<pre class="prettyprint linenums">self._somePrivate = 1</pre>
		<p>At this point in the constructor, variable <tt>self._somePrivate</tt> does not yet exist. When <tt>__setattr__()</tt> is called
		the first thing it will does is to query <tt>self._somePrivate</tt>... </p>
		<pre class="prettyprint linenums">	def __setattr__(self, name, val):
		<b>if self._somePrivate == 2: # -- Oops --</b></pre>
		<p>This means that <tt>__getattr__()</tt> must be called to resolve <tt>self._somePrivate</tt>
			because <em>the variable does not yet exist</em> and therefore cannot be &quot;...found through the normal mechanism...&quot;.
		   And here is the flaw... my initial assumption was that this would work because <tt>__getattr__()</tt>
			is only called if the attribute can't otherwise be found, and I thought it would be found.
		</p>
		<p>
		   But of course, it cannot be found, so <tt>__getattr__()</tt> also has to be called. Then, <tt>__getattr__()</tt> tries to access the variable <tt>self._somePrivate</tt> and because it
			still does not exist, <tt>__getattr__()</tt> is called again, and again, and so on... resulting in the infinite recursion seen.
		</p>
		<p>And from this we can understand why the second example worked. Because there is no <tt>__setattr__()</tt> defined in the second test
			class, the method does not try to read the variable first (as my little example did) and so <tt>__getattr__()</tt> need never be
			called. Therefore the variable is created successful upon class initialisation and any subsequent queries on the variable
			will be found using the normal mechanism. Even if the second example had defined <tt>__setattr__()</tt>, as long as it did not
			try to read <tt>self._somePrivate</tt>, it would have been okay.
		</p>
		<p>So the moral of this little story was, if implementing either of these magic methods, be careful which
			variables you access as part of the get/set logic!
		</p>
		<p>I needed to do this however, so what can be done to resolve this. The solution is to define the constructor
			as follows, using exactly the same type of set we used in <tt>__setattr__()</tt> to avoid the recursion problem:
		</p>
		<pre class="prettyprint linenums"> class Test(object):
	def __init__(self):
		super(Test, self).__setattr__('_somePrivate', 1)</pre>
		<p>Now the example works again... yay!</p>
		<h3>Setting the value of a class instance array</h3>
		<p>Another thing I had been doing was to set an element of an array in the <tt>__setattr__()</tt> function and
			a kind chappy on StackOverflow
			<a target="_blank" href="http://stackoverflow.com/questions/28189061/why-does-setattr-not-recurse-when-setting-member-array-variable-elements/28189312#28189312">
			answered my question</a> which I'll duplicate below. In the example below the line <tt>self._someAttr = 1</tt>
			behaves as I'd have expected by getting <tt>__setattr__()</tt> to recurse, only the once, back into itself. What
			I didn't understand was why the line <tt>self._rowData[Test.tableInfo[self._tableName][name]] = val</tt> didn't
			do the same. I was thinking that to set the array we'd call <tt>__setattr__()</tt> again, but it doesn't. The
			test example is shown below.
		</p>
		<pre class="prettyprint linenums">class Test(object):
    tableInfo = { 'table1' : {'col1' : 0, 'col2':1} }

    def __init__(self, tableName):
        super(Test, self).__setattr__('_tableName', tableName) # Must be set this way to stop infinite recursion as attribute is accessed in bot set and get attr
        self._rowData = [123, 456]

    def __getattr__(self, name):
        print "# GETTING %s"  % (name)
        assert self._tableName in Test.tableInfo

        if name in Test.tableInfo[self._tableName]:
            return self._rowData[Test.tableInfo[self._tableName][name]]
        else:
            raise AttributeError()

    def __setattr__(self, name, val):
        print "# SETTING %s" % (name)
        if name in Test.tableInfo[self._tableName]:
            print "Table column name found"
            self._rowData[Test.tableInfo[self._tableName][name]] = val
            self._someAttr = 1
        else:
            super(Test, self).__setattr__(name, val)

class Table1(Test):
    def __init__(self, *args, **kwargs):
        super(Table1, self).__init__("table1", *args, **kwargs)

t = Table1()
print t.col1
print t.col2
t.col1 = 999
print t.col1</pre>
		<p>It produces the following output...</p>
		<pre class="prettyprint linenums">$ python test.py
# SETTING _rowData
# GETTING col1
123
# GETTING col2
456
# SETTING col1
Table column name found
# SETTING _someAttr
# GETTING col1
999</pre>
		<p>So, why didn't the recursion occur for <tt>self._rowData[Test.tableInfo[self._tableName][name]] = val</tt>? I had thought
			we'd have to call <tt>__setattr__()</tt> again to set this. As the SO user <a href="http://stackoverflow.com/users/542190/filmor" target="_blank">
			&quot;filmor&quot;</a> explained, the following happens:
		</p>
		<p><tt>self._rowData[bla] = val</tt> gets resolved to <tt>self.__getattr__("_rowData")[bla] = val</tt>. So we get the array (it already
			exists so is found by the normal mechanisms and not via another call to <tt>__getattr__()</tt>. But then
			to set an array value <tt>__setitem__()</tt> is used an <em>not</em> <tt>__setattr__()</tt>. So, the expression resolves to
			<tt>self.__getattribute__("_rowData").__setitem__(bla, val)</tt> and there is therefore no further <tt>__setattr__()</tt>
			called. Simples!
		</p>
</div>

<h2>Concatenating immutable sequences more quickly in Python</h2>
<div>
		<p>
			<a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" target="_blank">
			PyDoc for immutable sequences</a> says:
		<p>
		<blockquote>
			<p>
				Concatenating immutable sequences always results in a new object. This means that building up a
				sequence by repeated concatenation will have a quadratic runtime cost in the total sequence
				length. To get a linear runtime cost ... build a list and use .join()
			</p>
			<footer>
				-- <a href="https://docs.python.org/3/library/stdtypes.html" target="_blank">Python documentation: Built-in types</a> section 4.6.1 - Common Sequence Operations
			</footer>
		</blockquote>
		<p>
			Interesting... I've been building up SQL strings using concatenation. Is using a
			join really better? Lets have a look... In my simple test below I create a large list of strings and
			concatenate them using string concatenation in <tt>test1</tt> and list.join() in <tt>test2</tt>.
		</p>
		<pre class="prettyprint linenums">def test1(stringList):
	s = ""
	for i in stringList:
		s += "{}, ".format(i)

def test2(stringList):
	s = ", ".join(stringList)

if __name__ == '__main__':
	import timeit
	print(timeit.timeit("test1(map(lambda x: str(x), range(0,1000)))",
	                    setup="from __main__ import test1", number=10000))
	print(timeit.timeit("test2(map(lambda x: str(x), range(0,1000)))",
	                    setup="from __main__ import test2", number=10000))</pre>
		<p>
			All the &quot;<tt>map(lambda x: str(x), range(0,1000)</tt>&quot; expression does is to create a list of 1000
			strings to concatenate so that each test function is concatentating a list of the same strings.
		</p>
		<p>
			On my system (it will be different on yours) I get the following output from the test program.
		</p>
		<pre class="prettyprint linenums">5.61275982857
2.88877487183</pre>
		<p>So joining a list of strings is faster than concatenating strings by approximately 50%.</p>
</div>

<h2>Reading Excel Files in Python</h2>
<div>
	<p>
		Worth having a look at <a href="http://www.python-excel.org/" target="_blank">python-excel</a>...
	</p>
	<h3>Reads Excel Files Using XLRD</h2>
	<div>
		<p>
			Apparently only good for reading data and formatting information from older Excel files (ie: .xls)
			but I seem to be using it fine on xlsx files...
		</p>
		<p>
			To load the module use the following.
		</p>
		<pre class="prettyprint linenums">import xlrd</pre>
		<p>
			Open workbooks and worksheets as follows.
		</p>
		<pre class="prettyprint linenums">workbook  = xlrd.open_workbook(xlsFile)
worksheet = workbook.sheet_by_name('my-worksheet-name')</pre>
		<p>
			Iterate through rows and access columns:
		</p>
		<pre class="prettyprint linenums">for rowIdx in range(worksheet.nrows):
   row = worksheet.row(rowIdx)
   col1_value = row[1].value
   ...</pre>
		<p>
			Deal with dates using <tt>xldate_as_tuple</tt>. It will convert an Excel date into
			a tuple (year, month, day, hour, minute, nearest_second). When using this function
			remember to use the datemode <tt>workbook.datemode</tt>
			to use the correct date/time zone settings used in the spreadsheet.
		</p>
		<pre class="prettyprint linenums">dateColIdx = 1
rawdate = xlrd.xldate_as_tuple(row[dateColIdx].value, workbook.datemode)
print time.strftime('%Y-%m-%d', rawdate + (0,0,0))</pre>
	</div>

	<h3>Read Excel Files Using Pandas</h3>
	<p>
		Note that Pandas is zero indexed, whereas excel is 1 indexed.
	</p>
	<pre class="prettyprint linenums">import pandas
pandas.read_excel(xlsxFileName, worksheetName, header=excel_header_row_number)</pre>
</div> <!-- End Reading Excel Files H2 Div -->

<h2>Finding Index Of Closest Value To X In A List In Python</h2>
<div>
	<p>
		If a list is unsorted, to find the closest value one would iterate through the list.
		At each index the distance from the value at that index to the target value is
		measured and if it is less than the least distance seen so far that index is recorded.
	</p>
	<p>
		That's basically one for loop with a few tracking variables... O(n) operation. But,
		for loops aren't really very Pythonic in many ways and half to point of having a
		vectorized library like <a href="python/numpy.html">numpy</a> is that we avoid that
		tedium.
	</p>
		This is why, when I saw this solution to the problem, I though &quot;ooh that's clever&quot;...
	</p>
	<pre class="prettyprint linenums">findClosestIndex = lambda vec, val: numpy.arange(0,len(vec))[abs(vec-val)==min(abs(vec-val))][0]
closestIndex     = findClosestIndex(array_to_search, value_to_find_closest_to)</pre>
	<p>
		It's also a very terse read! So, let's break it down. The <tt>lambda</tt> expression is
		equivalent to the following.
	</p>
	<pre class="prettyprint linenums">def findClosestIndex(vec, val):
   # Pre: vec is a numpy.array, val is a numeric datatype
   vecIndicies = np.arange(len(vec))

   # produces the distance of each array value from &quot;val&quot;.
   distanceFromVal = abs(vec-val)

   # the smallest distance found.
   minDistance = min(distanceFromVal)

   # Produce a boolean index to the distance array selecting only those distances
   # that are equal to the minimum.
   vecIndiciesFilter = distanceFromVal == minDistance

   # vecIndicies[vecIndiciesFilter] is an array where each element is the index
   # of an element in vec which equals val.
   return vecIndicies[vecIndiciesFilter][0]  </pre>

	<p>
		The line <tt>vecIndicies = np.arange(len(vec))</tt> produces an array that
		is exactly the same size as the array <tt>vec</tt> where <tt>vecIndicies[i]
		== i</tt>.
	</p>
	<p>
		The line <tt>distanceFromVal = abs(vec-val)</tt> produces an array where
		<tt>distanceFromVal[i] == |vec[i] - val|</tt>. In other words, each element in
		<tt>distanceFromVal</tt> corresponds to the distance of the same element in
		<tt>vec</tt> from the value we are searching for, <tt>val</tt>.
	</p>
	<p>
		The next line...
	</p>
	<p>
		The next line produces an array <tt>vecIndiciesFilter</tt> where each
		element, <tt>vecIndiciesFilter[i]</tt>, is <tt>True</tt> if
		<tt>distanceFromVal[i] == minDistance</tt>
	</p>
	<p>
		TODO... incomplete, needs finishing with SO better method and speed comparisons.
	</p>
</div> <!-- End "Finding Closest Value To X In A List Div" -->

<h2>Drop Into The Python Interpretter</h2>
<div>
	<pre class="prettyprint linenums">import code
code.interact(local=locals())</pre>
</div>

<h2>Working With Files In Python</h2>
<div>
	<h3>Check If a File Or Directory Exists</h3>
	<pre class="prettyprint linenums">import os.path
if os.path.isfile(fname):
   print "Found the file"

if os.path.isdir(dirname):
   print "Found the directory"</pre>


	<h3>Traversing Through Directories For Files</h3>
	<p>To find all files matching a certain pattern in a selected directory
		and all of its subdirectories, using something like the following can work
		quite well...
	</p>
	<pre class="prettyprint linenums">def YieldFiles(dirToScan, mask):
   for rootDir, subDirs, files in os.walk(dirToScan):
      for fname in files:
         if fnmatch.fnmatch(fname, mask):
            yield (rootDir, fname)

# Find all .txt files under /some/dir
for dir, file in YieldFiles("/some/dir", "*.txt")
   print file</pre>
	<p>
		The above searches from parent directory to children in a recursive descent,
		i.e, top-down fashion. If you want to search bottom-up then add the
		flag <code>topdown=True</code> to the <code>os.walk()</code> function.
	</p>

	<h3>Deleting Files and Directories (Recursively)</h3>
	<p>
		The Python library <code>shutils</code> has plenty of functions for doing this.
		For example, if you want to remove a temporary directory and all files
		and subdirectories within...
	</p>
	<pre class="prettyprint linenums">if os.path.exists(cacheDir):
   shutil.rmtree(cacheDir) # Recursively delete dir and contents
   os.makedirs(cacheDir)   # Recreate dir (recursively if
                           # intermediete dirs dont exist)</pre>
	<p>
		However, you may sometimes
		<a href="http://stackoverflow.com/questions/1213706/what-user-do-python-scripts-run-as-in-windows"
		   target="_blank">run into problems on windows</a> when deleting files
		or directories. This is normally a <em>permissions</em> issue. Also,
		although this seems silly, you won't be able to delete a directory
		if your <em>current working directory </em> is set to that directory or
		one of its children.
</div>

<h2>Handling Signals</h2>
<p>
	Handling signals in Python can be done like so:
</p>
<div>
	<pre>import signal

# Somewhere in your initialisation
signal.signal(signal.SIGINT, signal_handler)

def signal_handler(signal, frame):
   # Clean up etc
   sys.exit(1)</pre>
</div>


<h2>Handle Non-Blocking Key Presses</h2>
<div>
<p></p>
<pre>## Keyboard stuff mostly from https://stackoverflow.com/a/55692274/1517244 with some modifications
## from https://stackoverflow.com/a/2409034/1517244
import os

if os.name == 'nt':
    import msvcrt

    def setup_terminal():
        pass

    def kbhit():
        return msvcrt.kbhit()

    def kbchar():
        return msvcrt.getch().decode("utf-8") 

else:

    import sys, select, tty, termios, atexit
    
    def setup_terminal():
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        tty.setcbreak(sys.stdin.fileno())

        def restore_terminal():
            fd = sys.stdin.fileno()
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

        atexit.register(restore_terminal)

    def kbhit():
        dr,dw,de = select.select([sys.stdin], [], [], 0)
        return dr != []

    def kbchar():
        return sys.stdin.read(1)</pre>
<p></p>
</div>


<hr>

<pre>
TODO
Stat and os.walk in opposite direction
  https://docs.python.org/2/library/os.html
  https://docs.python.org/2/library/stat.html
  http://stackoverflow.com/questions/2656322/python-shutil-rmtree-fails-on-windows-with-access-is-denied
---
  import fnmatch
  import os
  for root, dirs, files in os.walk("/some/dir"):
     for fname in files:
        if fnmatch.fnmatch(file, '*.txt'):
           pass
---

Script dir
  http://stackoverflow.com/questions/4934806/how-can-i-find-scripts-directory-with-python

Print literal {}
  https://docs.python.org/2/library/stat.html
  also formatting from my little debug output class

Get Hostname
   https://wiki.python.org/moin/Powerful%20Python%20One-Liners/Hostname

python get environment variable
import os
os.environ['A_VARIABLE'] = '1'
print os.environ['A_VARIABLE']   ## Key must exist!

To not care if key exists use
print os.environ.get('A_VAR') # Returns None of key doesn't exist

platform.system()
   https://docs.python.org/2/library/platform.html

flush stdout
   import sys
   sys.stdout.flush()

current time as string:
    def GetTimeNowAsString():
        return time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())

logging:
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.DEBUG
        [, filename='debug.txt', filemode='w'])
    log = logging.getLogger(__name__)


printing on windows. can't remember where I got this... some SO thread, needs references!

   import tempfile
   import win32api
   import win32print

   filename = tempfile.mktemp (".txt")
   open (filename, "w").write ("This is a test")
   win32api.ShellExecute (
        0,
        "print",
        filename,
        #
        # If this is None, the default printer will
        # be used anyway.
        #
        '/d:"%s"' % win32print.GetDefaultPrinter (),
        ".",
        0
   )
</pre>
	</div>
</body>
</html>

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

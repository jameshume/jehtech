<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Linux Security | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Linux Security</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>General References</h2>
<p>
  I found the following series of articles on the <a href="https://blog.vigilcode.com/" target="_blank">Vigil Code blog</a> to be really useful:
</p>
<ol>
  <li><a href="https://blog.vigilcode.com/2011/04/ubuntu-server-initial-security-quick-secure-setup-part-i/" target="_blank">Ubuntu Server Initial Security - Quick Secure Setup Part I</a></li>
  <li><a href="https://blog.vigilcode.com/2011/05/ufw-with-fail2ban-quick-secure-setup-part-ii/" target="_blank">UFW with Fail2ban - Quick Secure Setup Part II</a></li>
  <li><a href="https://blog.vigilcode.com/2011/06/using-apparmor-quick-secure-setup-part-iii/" target="_blank">Using AppArmor - Quick Secure Setup Part III</a>.</li>
</ol>

<a id="SELinux"></a>
<h2>Security-Enhanced (SE) Linux</h2>
<div>
<h3>References</h3>
<ul>
  <li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security-Enhanced_Linux/index.html"
         target="_blank">Red Hat Enterprise Linux 6, Security-Enhanced Linux User Guide</a>.
         <ul><li>Note: this &quot;article&quot;/section is mainly notes based on this reference.
         This is a r-e-a-l-l-y good bit of documentation!</li></ul>
  </li>
  <li><a href="http://people.redhat.com/dwalsh/SELinux/Presentations/ManageRHEL5.pdf"
         target="_blank">Managing Red Hat Enterprise Linux</a>, D J Walsh, K MacMilan.
         <ul><li>Note: this &quot;article&quot;/section is mainly notes based on this reference.</li></ul>
  </li>
  <li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf"
         target="_blank">The SELinux Notebook</a>, 4th edition.
      <ul><li>Note: this &quot;article&quot;/section is mainly notes based on this reference.</li></ul>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Discretionary_access_control"
         target="_blank">Discretionary access control</a>, Wikipedia.
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Mandatory_access_control"
         target="_blank">Mandatory access control</a>, Wikipedia.
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege",
        target="_blank">Principle of Least Privilege</a>, Wikipedia.
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Linux_Security_Modules"
         target="_blank">Linux Security Modules</a>, Wikipedia.
  </li>
  <li><a href="https://source.android.com/security/selinux/concepts"
         target="_blank">SELinux concepts</a>, Android Docs.
  </li>
  <li><a href="https://github.com/mairin/selinux-coloring-book/blob/master/PDF/en/selinux-coloring-book_A4-Stapled.pdf"
         target="_blank">SE Linux Colouring Booko</a>, RedHat.
  </li>
  <li><a href="https://doc.coker.com.au/computers/se-linux-saves/"
         target="_blank">SE Linux Saves</a>: Examples where SE Linux prevent exploits.
  </li>
</ul>

<h3>To Read</h3>
<pre>
https://www.systutorials.com/docs/linux/man/1-audit2why/
</pre>

<h3>Linux without the SE</h3>
<p>
  The Linux kernel controls that access that a process has to resources. In the standard Linux
  <u>D</u>iscrtionary <u>A</u>ccess <u>C</u>ontroll (DAC) this is does by assigning users and
  resources to groups. Processes are given the same group and user IDs as the user that started
  the process. The process can then access a resource if it shares either the same user or group ID
  with the resource, or if the resource is &quot;public&quot;.
</p>
<p>
  I.e., a process accesses a resource based on the resource access bits:
</p>
<ol>
  <li>If the resource available to anyone, the the process can access it,</li>
  <li>Otherwise if the process and resource are in the same group then the the process can access it,</li>
  <li>Otherwies if the process and resource are owned by the same user, the process can access it,</li>
  <li>Otherwise the process cannot access the resource.</li>
</ol>
<p>
  This is called a security <em>policy</em>. The policy is the set of rules used to make access
  control decisions.
</p>
<p>
  Therefore, access to system resources must be set by the system admin, who will decide which
  users belong to which groups and which system resources belong to which group (and user). However,
  the system is <em>discretionary</em> <q>in the sense that a subject with a certain access permission is capable of passing that permission (perhaps indirectly) on to any other subject</q> <a href="https://en.wikipedia.org/wiki/Discretionary_access_control" target="_blank">[Ref]</a>.
</p>
<p>
  This discretionary access means that the system admin is not totally in control of who accesses
  what. For example, Bob can change the group associated with a file he owns and suddenly
  give a different set of individuals the right to read/write/execute that file. This is not
  in the system admin's control. Bob has been able to make to make a <em>policy decision</em>!
</p>
<p>
  The main RedHat article referenced <a href="http://people.redhat.com/dwalsh/SELinux/Presentations/ManageRHEL5.pdf" target="_blank">[Ref]</a>,
  describes some of the disadvantages in more detail. In summary they are:
</p>
<ul>
  <li>Processes' access is based on users' access: the kernel can not distinguish applications from users,</li>
  <li>Processes can change security properties: discretionary access control. Processes can escape security policy!</li>
  <li>Only 2 privilege levels, user and root: too simplistic and no way to enforce &quot;least-privilege&quot; (i.e., a process should be given
      only those privileges essential for it to perform its work) <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege", target="_blank">[Ref]</a></li>
</ul>
<div class="box_container"><div class="info">
  <p>
    <b>Summary of terminology:
  </b>
  <ul>
    <li><em>Security policy</em> is the set of rules used to make access control decisions.</li>
    <li><em>Discretionary access</em> means that a subject with a certain access permission is capable of passing that permission on.</li>
    <li><em>Least-privilege</em> describes a security mindset that states that a process should be given
      only those privileges essential for it to perform its work.</li>
  </ul>
</div></div>

<h3>SELinux: A Bird's Eye View</h3>
<p>
  SELinux stands for <u>S</u>ecurity <u>E</u>nhanced Linux. It is built on years of the NSA's
  security research and is an application of their Flash security architecture, implemented as part of the
  <a href="https://en.wikipedia.org/wiki/Linux_Security_Modules" target="_blank">Linux Security Module (LSM)</a>
  framework. It adds <em><u>M</u>anditory <u>A</u>ccess <u>C</u>ontroll (MAC)</em> to Linux:
</p>

<blockquote>
  <p>
    ...With mandatory access control, this security policy is <em>centrally controlled</em> by a security policy administrator; users do not have the ability to override the policy ... By contrast, discretionary access control ... allows users the ability to make policy decisions and/or assign security attributes. ... MAC-enabled systems allow policy administrators to implement organization-wide security policies. Under MAC (and unlike DAC), users cannot override or modify this policy, either accidentally or intentionally ... in principle ...
  </p>
  <footer><a href="https://en.wikipedia.org/wiki/Mandatory_access_control"
             target="_blank">Mandatory access control, Wikipedia</a>.
  </footer>
</blockquote>
<p>
  Most interestingly, for me at least, Android uses SELinux (since 4.3)
  <a href="https://source.android.com/security/selinux/concepts" target="_blank">[Ref]</a>
  which means that it is
  a very heavily used and &quot;industry-leading&quot; security measure. If you're going to work in the guts of
  Android, a little knowledge of SELinux goes a long way... hence why I'm trying to learn a little
  about it.
</p>
<p>
  So, a more secure Linux: access control is mandatory (default denial - anything not explicitly allowed is denied), more fine grained (no longer just root and not-root) and also implements the principle of least-privilege.
</p>
<p>
  There are thee forms of access control, the only one I've made notes on is <em><u>T</u>ype <u>E</u>nforcement</em> (TE),
  which is the primary SELinux mechanism.
</p>
<p>
  The basic, 30k foot view of SELinux operation is this...
  Whenever a process accesses a file (this could be disk-based, a socket or shared memory, for example)
  or some other resource, this is intercepted in the kernel by SELinux. It will check all of the
  rules in the security policy and if the rules allow it access is granted, otherwise it is denied.
  The same is true when a user attempts to start a process. Note though that it runs after the
  built in Linux DAC. If the DAC blocks it SELinux won't even get a look in.
</p>

<h3>The SELinux Parlance</h3>
<p>
    Cribbed almost verbatim from:
</p>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-selinux-on-centos-7-part-1-basic-concepts"
       target="_blank">Intro To SELinux On Centos 7</a>.
</li>
</ul>
<p>
<table>
  <thead>
    <tr><td>Term</td><td>Meaning</td></tr>
  </thead>
  <tbody>
    <tr><td>User</td><td>Linux users mapped 1-to-1 to SELinux users.</td></tr>
    <tr><td>Roles</td><td>Gateway between user and process. Roles defines which users can access which processes.</td></tr>
    <tr><td>Subject</td><td>Person, process, or device. Anything that can affect an object.</td></tr>
    <tr><td>Object</td><td>Anything that can be acted upon. E.g. file.</td></tr>
    <tr><td>Permissions</td><td>Actions that a subject can perform on an object are the subject's permissions.</td></tr>
    <tr><td>Domain</td><td>Domains are for Subjects. Security context associated with a process: it tells the process what it can and can't do.</td></tr>
    <tr><td>Type</td><td>Types are for Objects: Dictates the objects purpose.</td></tr>
    <tr><td>Policy</td><td>Set of rules used to make access control decisions.</td></tr>
    <tr><td>Type Enforcement (TE)</td><td>Where a process running within a particular domain can perform only certain operations on certain types of objects.</td></tr>
  </tbody>
</table>
</p>

<h3>Modes</h3>
<p>
    SELinux can be run in one of three modes:
</p>
<ol>
  <li>Enforcing: Policy is actively enforced.</li>
  <li>Permissive: Policy is not enforced but violations are still logged. Good for debug.</li>
  <li>Disabled: Not running :(</li>
</ol>
<p>
  You can check what mode you're in by running either of the commands <code>getenforce</code>
  or <code>sestatus</code>.
</p>

<h3>Security Contexts</h3>
<p>
  All processes and files have a <em>security context</em>. A security context defines the security settings
  applied to a subject (person, process, or device). I guess the entire set of security contexts applied to everything
  in a system constitutes the security policy.
</p>
<p>
  <b>Security context:</b> security settings applied to a person, process or device (aka &quot;object&quot;).
</p>
<p>
  The SELinux <em>security context</em> (aka &quot;(security) label&quot;) is applied via a <em>label</em> associated with every user, process and resource.
  To put it another way, we can say that the rights of a process depend on it's security context. A security
  context is defined as follows:
</p>
<pre>user:role:type:level</pre>
<p>
  The field <code>type</code> is used for type enforcement (TE), the role and level fields I will
  ignore.
</p>
<p>
  Access is only allowed between types via the security policy and every process and resources
  used by that processes must have a security context (remember denial by default).
</p>
<p>
  A &quot;<em>domain</em>&quot; is a little bit of jargon you'll hear a lot:
  The security context associated with a process is called the processes' <em>domain</em>.
</p>
<blockquote>
  <p>
    When a type is associated with a process, it defines what processes
    (or domains) the SELinux user (the subject) can access.
  </p><p>
    When a type is associated with an object, it defines what access
    permissions the SELinux user has to that object.
  </p>
  <footer><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf"
             target="_blank">The SELinux Notebook</a>
  </footer>
</blockquote>
<p>
    So... we label all of our resources and all of our subjects and then define rules which
    say which subjects can do what with which objects.
</p>

<h2>Get SELinux Running On Ubuntu?</h2>
<div>
<h3>References</h3>
<ul>
  <li>https://wiki.debian.org/SELinux/Setup</li>
  <li>https://www.centos.org/docs/5/html/Deployment_Guide-en-US/rhlcommon-chapter-0001.html</li>
  <li><a href="https://www.amazon.co.uk/Android-Security-Internals-Depth-Architecture/dp/1593275811/ref=sr_1_1?ie=UTF8&qid=1504079575&sr=8-1&keywords=android+security+internals" target="_blank">Android Security Internals</a>, chapter 12.
  </li>
</ul>
<h3>The SELinux Ubuntu Setup</h3>
<p>Okay, to do this I am going to follow the Debian tutorial as the Ubuntu one points to it.
</p>
<p>Following the instructions went pretty well. I now have SELinux running in permissive mode
   on my desktop:
</p>
<pre>
sudo apt-get install selinux-basics selinux-policy-default auditd
sudo cp ~/Downloads/_load_selinux_policy /usr/share/initramfs-tools/scripts/init-bottom
update-initramfs -u
sudo update-initramfs -u
selinux-activate
sudo selinux-activate
sudo reboot now
sudo check-selinux-installation
sudo audit2why -al
</pre>
<p>
    The last command <code>audit2what -al</code> outputs a shed load of denial messages. Unfortunately
    that's where the first references Debian setup tutorial ends.
</p>
<p>
    In an earlier paragraph we talked about Linux users being mapped 1-to-1 onto SELinux users.
    Let's see what this new setup has configured for us...
</p>
<pre><b>~$ sudo semanage login -l</b>

Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *</pre>
<p>
    We can also see what roles exist:
</p>
<pre><b>~$ seinfo -r</b>

Roles: 14
   auditadm_r
   dbadm_r
   guest_r
   staff_r
   user_r
   logadm_r
   object_r
   secadm_r
   sysadm_r
   system_r
   webadm_r
   xguest_r
   nx_server_r
   unconfined_r</pre>
<p>
    We can also see the security contexts in terns of rolls and types that users a labelled with:
</p>
<pre><b>~$ id -Z</b>
unconfined_u:unconfined_r:unconfined_t:SystemLow-SystemHigh</pre>
<p>
    Remember when we said a security context looked like &quot;<code>user:role:type:level</code>&quot;?
    Well, here is the only security context in our system. The user <code>unconfined_u</code>
    has the roll <code>unconfined_r</code>, with a type <code>unconfined_t</code>.
</p>
<p>
    So, have our files been labelled as the tutorial claimed? Lets see...
</p>
<pre><b>~$ ls -lZ</b>
total 84
drwxrwxr-x.  3 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 Feb  3  2017 Android
drwxrwxr-x.  3 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 Feb  3  2017 AndroidStudioProjects
drwxrwxr-x.  2 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 May 16 19:57 bin
drwxr-xr-x. 10 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 Aug 29 17:34 Desktop
drwxr-xr-x.  4 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 May  1 18:31 Documents
...</pre>
<p>
    Here we see that, for example, the directory <code>Android</code> has a security context
    <code>unconfined_u:object_r:user_home_t:SystemLow</code>. This means that, if we are using
    type enforcement (TE), any user that has the type <code>user_home_t</code> or is, in fact,
    the user <code>unconfined_u</code> can access the directory.
</p>
<p>
    But where is all of this defined? Well, it appears the SELinux policy is compiled and exists
    in binary trees, which are compiled from source trees
    <a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/rhlcommon-chapter-0001.html" target="_blank">[Ref]</a>.
    Binary policy files are used for performance reasons <a href="https://www.amazon.co.uk/Android-Security-Internals-Depth-Architecture/dp/1593275811/ref=sr_1_1?ie=UTF8&qid=1504079575&sr=8-1&keywords=android+security+internals" target="_blank">[Ref]</a>.
    Doing a little grep we find this:
</p>
<pre><b>~$ grep -R user_home_t /etc/selinux/default/</b>
...
/etc/selinux/default/contexts/files/file_contexts.homedirs:/home/[^/]*/.+   unconfined_u:object_r:user_home_t:s0
/etc/selinux/default/contexts/files/file_contexts.homedirs:/root/.+ unconfined_u:object_r:user_home_t:s0
...</pre>
<p>
    So, the file <code>file_contexts.homedirs</code> is defining a rule that matches all direct
    subdirectories of <code>/home</code> and labels them with the security context
    <code>unconfined_u:object_r:user_home_t:s0</code>. Presumably this was compiled into a binary
    policy tree, which was applied to create the default labelling of the file system when I first
    setup SELinux, following the Debian tutorial referenced.
</p>
</div>

<h2>Other Linux Security Modules (LSMs)</h2>
<div>
  <pre>SMACK: https://en.wikipedia.org/wiki/Smack_(software)
TOMOYO
AppArmor
Yama</pre>
</div>

<a id="UFW"></a>
<h2>Uncomplicated Firewall (UFW)</h2>
<div>
<h3>References</h3>
<ul>
  <li><a href="https://wiki.debian.org/Uncomplicated%20Firewall%20%28ufw%29" target="_blank">Uncomplicated Firewall</a>, Debian Wiki.</li>
  <li><a href="https://wiki.ubuntu.com/UncomplicatedFirewall" target="_blank">Uncomplicated Firewall</a>, Ubuntu Wiki.</li>
</ul>

<h3>About</h3>
  <p>
    UFW is a nice front end to the more complicated iptables firewall. It really is nice and user friendly.
    IPTables always looked to complicated to learn to me because I'm not a hard-core system administrator. I
    just want an easy to use firewall that will do a good job.
  </p>
  <p>
    UFW is described as:
  </p>
  <blockquote>
    <p>... iptables provide a complete firewall solution that is both highly configurable and highly flexible ...</p>
    <p>... Becoming proficient in iptables takes time, and ... can be a daunting task ...</p>
    <p>... the Uncomplicated Firewall (ufw) is a ... particularly well-suited for host-based firewalls. ufw provides ... a command-line interface for manipulating the firewall. ufw aims to provide an easy to use interface for people unfamiliar with firewall concepts, while at the same time simplifies complicated iptables commands to help an administrator who knows what he or she is doing ...</p>
    <footer>
      -- <a href="https://wiki.ubuntu.com/UncomplicatedFirewall" target="_blank">UncomplicatedFirewall</a>, Ubuntu Wiki.
    </footer>
  </blockquote>
  <p></p>

<h3>Installing And First Super Restrictive Setup</h3>
  <p>Could not be easier:</p>
  <pre>sudo apt-get install --yes ufw
sudo ufw enable
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw limit ssh/tcp
sudo ufw status verbose</pre>
  <p>
    This installs UFW and sets it up to deny all incoming traffic except for SSH connections but allow all outgoing traffic.
  </p>

<h3>UFW Commands</h3>
  <p>
    The man page and the above links will tell you pretty much everything you need to know about UFW, but here is a quick cheat sheet and a little view into some of the more complicated command line options.
  </p>
  <p>
    <table>
      <tr>
        <td>Status:</td>
        <td><code>ufw status verbose</code></td>
      </tr>
      <tr>
        <td>Enable Firewall:</td>
        <td><code>ufw enable</code></td>
      </tr>
      <tr>
        <td>Deny/Block All Incoming:</td>
        <td><code>ufw deny incoming</code></td>
      </tr>
      <tr>
        <td>Deny/Block A Specific IP:</td>
        <td>IP: <code>ufw deny from 1.2.3.4</code><br/>
          IP &amp; Subnet: <code>ufw deny from 1.2.3.4/24</code><br/>
          Incoming TCP to pert 80: <code>ufw deny proto tcp to any port 80</code>
        </td>
      </tr>
      <tr>
        <td>Allow All Outgoing:</td>
        <td><code>uft default allow outgoing</code></td>
      </tr>
      <tr>
        <td>Allow SSH Incoming:</td>
        <td><code>ufw allow ssh</code></td>
      </tr>
      <tr>
        <td>Rate Limit (SSH):</td>
        <td><code>ufw limit ssh/tcp</code></td>
      </tr>
      <tr>
        <td>Allow Protocol/Port Range:</td>
        <td><code>ufw allow 1234:4321/(ip|udp|tcp)</code></td>
      </tr>
      <tr>
        <td>Allow Specific IP Incoming:</td>
        <td><code>ufw allow x.x.x.x</code></td>
      </tr>
      <tr>
        <td>Allow SSH from IP range:</td>
        <td><code>ufw allow proto tcp from 192.1.1.0/24 port 22</code></td>
      </tr>
      <tr>
        <td>Show Numbered Rules:</td>
        <td><code>ufw status numbered</code></td>
      </tr>
      <tr>
        <td>Delete Rules:</td>
        <td><code>ufw delete (allow|deny) ...</code></td>
      </tr>
      <tr>
        <td>See Apps:</td>
        <td><code>ufw app list</code></td>
      </tr>
      <tr>
        <td>Get App Info::</td>
        <td><code>ufw app info app-name</code></td>
      </tr>
    </table>
  </p>
  <p>
    A little note on how to read some of the more complicated command lines. When you see something
    like this:
  </p>
  <pre>ufw deny proto tcp to any port 80</pre>
  <p>
    Read it as &quot;<code>ufw, deny proto tcp to any, port 80</code>&quot;. I.e., do not read it as
    denying tcp &quot;to any port&quot;. It is denying tcp to any address on the host using port 80.
    The reason it reads like this is that on a <a href="https://en.wikipedia.org/wiki/Multihoming" target="_blank">mulihomed </a>
    you might only want to ban on a specific IP, so you might write <code>ufw deny proto tcp to xxx.xxx.xxx.xxx port 80</code>,
    for example.
  </p>


  <h3>UFW Rule Order</h3>
  <p>
    To view the order of the rules in the UFW table type:
  </p>
  <pre>sudo ufw status numbered</pre>
  <p>
    Rules are applied in order, starting at rule 1. The first rule that matches will be used and
    the others will not be evaluated. this is why <b>specific rules should be put first and generic
      rules second</b>.
  </p>
  <p>
    To insert rules at a specific index use the following:
  </p>
  <pre>sudo ufw insert INDEX allow from IP_ADDR [port PORT] [to IP_ADDR [port PORT] [proto PROTO]]</pre>
  <p>
    To delete a rule at a specific idex use:
  </p>
  <pre>sudo ufw delete INDEX</pre>
  <p>Where, in both cases, INDEX is the number with which the rule is listed by the numbered
    status command shown above.
  </p>

  <h3>UFW Apps</h3>
  <p>
    When you see commands like &quot;<code>ufw allow OpenSSH</code>&quot;, the &quot;<code>OpenSSH</code>&quot;
    bit is an &quot;app&quot;, which is just a name which UFW maps to a title, description, port and
    protocol.
  </p>
  <p>
    The app definitions reside in <code>/etc/ufw/applications.d</code>. Let's say I have a server
    that I have build called JEHServ and I would like to be able to write something like:
    &quot;<code>ufw allow JEHServ</code>&quot;. To accomplish this create the file
    <code>/etc/ufw/applications.d/jeh-serv</code> with the following contents:
  </p>
  <pre>title = JEHTech server, a silly example
description=A really long description about JEHTech server
ports=12345/tcp|4321|99,105:110/udp</pre>
  <p>
    The only &quot;complicated bit&quot; is the <code>ports</code>. For the ports you can use
    a pipe delimited sequence of port numbers, ranges and protocols as shown.
  </p>
  <p>
    After creating this file you will need to force UFW to re-read it. Type
    <code>ufw reload</code>.
  </p>

  <h3>Logs</h3>
  <p>
    UFW logs can be found using <code>dmesg</code> or in <code>/var/logs/ufw*</code>.
  </p>
  <h4>MAC Addresses</h4>
  <p>
    You will see MAC addresses like the following. The string is split into the 6-octet destination MAC,
    6-octet source MAC and 2-octet EtherType.
  </p>
  <pre>[UFW BLOCK] IN=wlan0 OUT= MAC=b8:27:eb:ed:4c:77:6e:ad:3b:c2:8e:60:08:00...
                              ^^^^^^^^^^^^^^^^^ ||||||||||||||||| ^^^^^
                              ^^^^^^^^^^^^^^^^^ ||||||||||||||||| Ether type (80:00 == IPv4)
                              ^^^^^^^^^^^^^^^^^ Destination MAC
                              Source MAC</pre>
    <p></p>

    <h3>Routing</h3>
    <div>
      <p>
        As UFW is a friendly wrapper for IpTables, it is worth understanding something About
        the IpTables structure <a href="https://www.karlrupp.net/en/computer/nat_tutorial" target="_blank">[Ref]</a>:
      </p>
      <p>
        <img src="##IMG_DIR##/iptables.png"/>
      </p>
      <p>
        Having said that, maybe not that necessary. The following are notes from this SO thread
        <a href="https://askubuntu.com/a/1130516/475473" target="_blank">[Ref]</a>.
        Some rules examples:
      </p>
      <pre class="prettyprint linenums")># Allow all traffic routed to eth2 and coming in on eth1 to traverse the firewall:
ufw route allow in on eth1 out on eth2

# Allow any packets coming in on eth0 to traverse the firewall out on eth1 to tcp port 80
# on 12.34.45.67.
ufw route allow in on eth0 out on eth1 to 12.34.45.67 port 80 proto tcp</pre>
      <p>
        Must also setup IP formwarding by setting the following in <code>/etc/ufw/sysctl.conf</code>:
      </p>
      <pre class="prettyprint linenums">net/ipv4/ip_forward=1
net/ipv6/conf/default/forwarding=1
net/ipv6/conf/all/forwarding=1</pre>
      <p>
        Then restart UFW. You can then check if IP forwarding is enabled by typing:
      </p>
      <pre class="prettyprint linenums"># Either
sysctl net.ipv4.ip_forward

# Or
cat /proc/sys/net/ipv4/ip_forward</pre>
        <p></p>
    </div>

</div>

<a id="fail2ban"></a>
<h2>Fail2Ban</h2>
<div>
  <h3>References</h3>
  <ul>
    <li><a href="http://www.fail2ban.org/wiki/index.php/MANUAL_0_8" target="_blank">Fail2Ban Manual</a>, Fail2Ban Wiki.</li>
    <li><a href="https://www.fail2ban.org/wiki/index.php/Commands" target="_blank">Fail2Ban Command Cheat Sheet</a>, Fail2Ban Wiki.</li>
    <li><a href="https://www.digitalocean.com/community/tutorials/how-to-protect-ssh-with-fail2ban-on-ubuntu-14-04" target="_blank">How To Protect SSH with Fail2Ban on Ubuntu 14.04 </a>, DigitalOcean.</li>
    <li><a href="https://www.the-art-of-web.com/system/fail2ban-log/" target="_blank">System: Monitoring the fail2ban log</a>, The Art Of Web.</li>
    <li><a href="https://blog.vigilcode.com/2011/05/ufw-with-fail2ban-quick-secure-setup-part-ii/" target="_blank">UFW with Fail2ban - Quick Secure Setup Part II</a>, Vigil Code blog.</li>
    <li><a href="http://johnny.chadda.se/using-fail2ban-with-nginx-and-ufw/" target="_blank">Using Fail2ban with Nginx and UFW</a>, Johnny Chadda in Technology, August 4, 2014</li>
  </ul>

  <h3>Intro</h3>
  <p>
    Fail2Ban is a log parser that monitors a set of logs for messages that look &quot;suspicious&quot;, and then uses those messages
    to ban IP addresses (i.e., add a firewall rule to block that IP). So if a server prints out an error message that contains the
    client IP address, Fail2Ban can be configured to detect that message, extract the host IP and add a firewall rule to block that
    IP, if for example, the message is logged more than 10 times in 1 second. The ban usually is not permanent.
  </p>

  <h3>Cheat Sheet</h3>
  <p>
    <table>
      <tr>
        <td>Get status:</td>
        <td><code>sudo fail2ban status</code></td>
      </tr>
      <tr>
        <td>View logs:</td>
        <td><code>sudo cat /var/log/fail2ban.log</code></td>
      </tr>
      <tr>
        <td>Set log level:</td>
        <td><code>fail2ban-client set loglevel (CRITICAL|ERROR|WARNING|NOTICE|INFO|DEBUG|HEAVYDEBUG)</code></td>
      </tr>
      <tr>
        <td>Start/stop/reload/get status:</td>
        <td><code>fail2ban-client start|stop|reload|status [jail-name]</code></td>
      </tr>
      <tr>
        <td>Un-ban an IP</td>
        <td><code>sudo fail2ban-client set jail-name unbanip ip-address</code></td>
      </tr>
      <tr>
        <td>Dump config:</td>
        <td><code>fail2ban-client -d</code></td>
      </tr>
      <tr>
        <td>Jail Information:</td>
        <td>
          <table>
            <tr>
              <td>List files jail monitors:</td>
              <td><code>fail2ban-client get &lt;jail-name&gt; logpath</code></td>
            </tr>
            <tr>
              <td>List regular expressions for failures:</td>
              <td><code>fail2ban-client get &lt;jail-name&gt; failregex</code></td>
            </tr>
            <tr>
              <td>List actions:</td>
              <td><code>fail2ban-client get &lt;jail-name&gt; actions</code></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>Test A Jail Regex:</td>
        <td><code>fail2ban-regex /path/to/log/file /etc/fail2ban/filter.d/my-silly-server.conf [regex-to-ignore]</code>
            <br/><code>fail2ban-regex /path/to/log/file "a test regex"</code>
        </td>
      </tr>
    </table>
  </p>

  <h3>Jails, Filters &amp; Actions</h3>
  <p>
    <B>Jails</B> define the conditions that will lead an IP address to be banned by associating a
    <b>filter</b> with an <b>action</b>.
  </p>
  <p>
    The <b>filter</b> is just a set of regular expressions which are used to extract the IP address
    out of log messages. The <b>action</b> is self explanatory: usually adds a rule to the firewall but
    can do anything like send emails etc.
  </p>
  <p>
    <img src="##IMG_DIR##/fail2ban_jail_assoc_filter_action.png" alt="Fail2Ban jail associates filters with actions"/>
  </p>
  <p>
    Jails are found in <code>/etc/fail2ban/jail.conf</code>. Don't modify this file! Put new changes
    in <code>/etc/fail2ban/jail.local</code>. Any settings in this file override those in the
    <code>.conf</code> file. You do <em>not</em> need to copy the <code>.conf</code> file... just
    insert the <em>changes</em> you wish to make into the <code>.local</code> file. Think of it as an
    inheritance relationship. The <code>.local</code> file inherits everything from the <code>.conf</code>
    file and then applies specific overrides and extensions. An alternative way to specify a jail is
    to add it, in its own file, to <code>/etc/fail2ban/jail.d/</code>.
  </p>
  <p>
    Actions are found in <code>/etc/fail2ban/action.d/</code>. Filters are found in <code>/etc/fail2ban/filter.d/</code>.
    The default action for everything is to ban an IP address. The default firewall being used is
    iptables. Note: if you are using UFW you will have to reconfigure Fail2Ban to use UFW.
  </p>
  <p>
    <img src="##IMG_DIR##/fail2ban-full.png" alt="Fail2Ban jail associates filters with actions"/>
  </p>
  <p>
    Note, that to begin with <em>all</em> jails are disabled by default. You should only enable
    the jails that are required for you system. For example, a basic system with only an SSH server
    running, might only have this in <code>/etc/fail2ban/jail.local</code>:
  </p>
  <pre>[sshd]
enabled = true

[sshd-ddos]
enabled = true</pre>
  <p>
    Because these settings override or add to the existing settings in <code>jail.conf</code>, thats
    all we need to specify for SSH... all the other settings like the filter and actions have already
    been defined: the jail only needs enabling.
  </p>

  <h3>Working With UFW</h3>
  <p>
    By default, Fail2Ban will use iptables to block IP addresses. What I found was that, at least on
    Debian (9.4), that it still worked, i.e., IP addresses were still banned, but the ban status
    did not show up when executing a <code>ufw status</code> command. To get it working with UFW
    all you need to do is add the following to your <code>/etc/fail2ban/jail.local</code> file:
  </p>
  <pre>[DEFAULT]
banaction = ufw</pre>
  <p>
    This works by overriding the default ban action because of the file <code>/etc/fail2ban/action.d/ufw.conf</code>
    that is nicely provided for us :)
  </p>
  <p>
    To go into a little more detail have a look at <code>/etc/fail2ban/jail.conf</code>. Inside
    you will see the following definition:
  </p>
  <pre>action = %(action_)s</pre>
  <p>
    This is the default action that will be taken when fail2ban bans an IP address. It is set to
    a macro expansion. In this case it expands the macro &quot;<code>action_</code>&quot;.
  </p>
  <p>
    If we look at this macro we can see it defined as this:
  </p>
  <pre>action_ = %(banaction)s[name=%(__name__)s, bantime="%(bantime)s", port="%(port)s", protocol="%(protocol)s", chain="%(chain)s"]</pre>
  <p>
    It is itself a string that contains multiple macros that are in turn expanded. The most important macro,
    if we want to do anything other than the default ban action is, &quot;<code>banaction</code>&quot;. Thus
    by overriding this variable we have cause the default action to use UFW.
  </p>
  <p>
    One thing you might be wondering is why each expansion has an &quot;s&quot; appended at the end, like for example,
    on the line <code>%(action_)<b>s</b></code>. What does the trailing &quot;s&quot; do? It is there because Fail2Ban uses
    <a href="https://docs.python.org/2/library/stdtypes.html#string-formatting-operations" target="_blank">Python string interpolation</a>
    and the trailing &quot;s&quot; means that the variable is converted to a string using the Python <code>str()</code> function.
  </p>

  <h3>Sending Email Alerts</h3>
  <p>
    There are other interesting actions available that we can find, including &quot;<code>action_mwl</code>&quot;. We'd want to use
    this if we not only want to ban IP addresses but also send the server admin an email about the event. To use this rule, we
    simply modify the <code>DEFAULT</code> section of our <code>jail.local</code> jail as follows:
  </p>
  <pre>[DEFAULT]
destemail = admin@email.address
sender = sender@email.address
banaction = ufw
action = %(action_mwl)s</pre>
  <p>
    There is one little caveat you will have to address. Sendmail, which is the mail client fail2ban will
    use by default, will want a fully qualified domain name as the hostname. It gets this by indirectly looking up
    the <code>/etc/hosts</code> file (via OS APIs). So you need to change the following line in <code>/etc/hosts</code>:
  </p>
  <pre>127.0.0.1 localhost</pre>
  <p>To something like:</p>
  <pre>127.0.0.1 my.client-name.com localhost</pre>
  <p>
    Now sendmail won't barf on startup and on trying to send mail! You want a real, or at least a unique, domain
    name so that if you have different servers sending events to you, you can identify which server sent it.
  </p>
  <p>
    There is also the option of hardcoding the FQDN in <code>/etc/mail/sendmail.mc</code>, but you will still
    have to modify <code>/etc/hosts</code> anwyay [<a href="https://selliott.org/node/40" target="_blank">Ref</a>].
  </p>

  <h3>Define Your Own Ban</h3>
  <p>
    Lets say I have a service that I have created that dumps error messages to a log file. Define
    the service in <code>/etc/fail2ban/jail.local</code>:
  </p>
  <pre>[my-silly-server]
enabled = true
port = 1234
logpath = /var/log/my-silly-server-log
bantime = ...
findtime = ...
maxretry = ...
</pre>
  <p>
    This tells Fail2Ban to create and enable a jail called &quot;my-silly-server&quot; for a
    service listening to port 1234 that writes to the log file <code>/var/log/my-silly-server-log</code>.
  </p>
  <p>
    Other configuration options like <code>bantime</code>, <code>findtime</code> and <code>maxretry</code>
    can also be specified. The value for <code>maxretry</code> specifies the number of failures that have to
    occur in the last <code>findtime</code> seconds in order to ban the IP. The parameter <code>bantime</code>
    dictates how many seconds the ban is in place for.
  </p>
  <p>
    However, what this doesn't tell Fail2Ban is what log messages it should scan for. To do that you
    must add a <code>.conf</code> file with the same name as the jail to the directory <code>/etc/fail2ban/filter.d</code>.
    So in this case the file would be <code>/etc/fail2ban/filter.d/my-silly-server.conf</code>. That file must contain
    the following:
  </p>
  <pre>[Definition]
failregex = Some error from &lt;HOST&gt;
            The client &lt;HOST&gt; sent yet another regex-defined error</pre>
  <p>The <a href="https://fail2ban.readthedocs.io/en/latest/filters.html" target="_blank">Developing Filters</a>
  section of the Fail2Ban docs contains much more detailed information.
  </p>
  <p>
    In the above, <code>failregex</code>, defines the regular expressions that Fail2Ban will match against
    each line of the log file specified. The &quot;<code>&lt;HOST&gt;</code>&quot; part of the expression
    is a special Fail2Ban regex that will match any IP address or host name. This will be used in the
    ban action. Thus, in the above, should the log contain &quot;Some error from 1.2.3.4:4321&quot;,
    or &quot;The client 1.2.3.4 sent yet another regex-defined error&quot;, then the
    IP address <code>1.2.3.4</code> will be blocked by adding a rule to the firewall in use.
  </p>
  <p>
    You can test out your regex using the <code>fail2ban-regex</code> as so:
  </p>
  <pre>fail2ban-regex /path/to/log/file /etc/fail2ban/filter.d/my-silly-server.conf [regex-to-ignore]</pre>
  <p>Or:</p>
  <pre>fail2ban-regex /path/to/log/file "a test regex"</pre>

  <h3>Backends</h3>
  <p>
    The following is taken from <a href="https://github.com/fail2ban/fail2ban/issues/1986" target="_blank">this fail2ban github thread</a>. You should set your backend for sshd jail to systemd. File-backends (like pyinotify, polling as well as auto) do montoring of the log-files only (not systemd-journals).
  </p>
  <pre>[sshd]
backend = systemd</pre>
  <p>
    And for check it via fail2ban-regex you can use:
  </p>
  <pre># for >= 0.10:
fail2ban-regex systemd-journal sshd
# or for 0.9:
fail2ban-regex systemd-journal /etc/fail2ban/filter.d/sshd.conf</pre>

</div>

<h2>SECure COMPuting - Seccomp</h2>
<div>
  <p></p>
  <blockquote>
    <p>
      The idea behind seccomp is to restrict the system calls that can be made from a process ... The Linux kernel has a few hundred system calls, but most of them are not needed by any given process ...
    </p>
    <footer><a href="https://lwn.net/Articles/656307/" target="_blank">A seccomp overview</a>, lwn.net</footer>
  </blockquote>
  <p>
  </p>
</div>


<h2>Secure Shell (SSH)</h2>
<div>
  <p>
    Installing the SSH client is very simple:
  </p>
  <pre>sudo apt-get install ssh</pre>
  <p>
    Once installed use <code>sudo systemctl status ssh</code> to get the status of the SSH daemon. To start/stop the daemon use <code>sudo systemctl start/stop ssh</code>.
  </p>
  <p>
    For security, root access via SSH is sometimes disabled and password authentication is always disabled (prefer public/private keys). You can also run the SSH daemon on
    a non standard port. Especially useful is to <a href="#fail2ban">setup Fail2Ban</a> to monitor system log files for suspicious SSH activity (see above).
  </p>
  <p>
    The SSH daemon configuration file is located at <code>/etc/ssh/sshd_config</code>. To disable root loging grep for the line containing &quot;<code>PermitRootLogin</code>&quot;
    and make sure it reads:
  </p>
  <pre>PermitRootLogin no</pre>
  <p>
    To disable password authentication grep for the line containing &quot;<code>PasswordAuthentication</code>&quot; and make sure it reads:
  </p>
  <pre>PasswordAuthentication no</pre>
  <p>
    You should also disable PAM:
  </p>
  <pre>UsePAM no</pre>
  <p>
  	You may also want to use <code>LogLevel VERBOSE</code>, so that the key fingerprint of SSH keys used for login are recorded.
  </p>
  <p>
    Once you have made the changes you want type:
  </p>
  <pre>sudo systemctrl restart ssh</pre>
  <p>
    To setup a new public/private key pair with, at the time of writing, some future proofing in the key length, use the following:
  </p>
  <pre>ssh-keygen -t rsa -b 3072 -C "A meaningful description" -f file-name-for-your-key-pair</pre>
  <p>
    Make sure you enter a secure password for your key. I.e., use upper and lower case as well as numbers at the very least with a reasonable length. Two new files will have
    been created in the directory from which your ran the <code>ssh-keygen</code> command: <code>file-name-for-your-key-pair</code> and <code>file-name-for-your-key-pair.pub</code>.
    Move these to a <em>secure</em> location and keep the private key secret! The minute this key is compromised, so is your server.
  </p>
  <p>
    You can have as many key pairs as you like, probably for each user of your system. You will then need to add these to your SSH server's allowed list. Note,
    never do this as root. To add a key to the SSH servers allowed list do:
  </p>
  <pre>cat file-name-for-your-key-pair.pub >> ~/.ssh/authorized_keys</pre>
  <p>
    If the <code>.ssh</code> directory does not exist you can create it using <code>mkdir ~/.ssh &amp;&amp; chmod 700 ~/.ssh</code>. If the <code>authorized_keys</code> file
    did not exist make sure to has <code>600</code> permissions. Lastly move your key file into the <code>~/.ssh</code> directory.
  </p>
  <p>
    One thing you might notice is that the key file is in the user's local directory. This can be fine if you want users to be able to dictate who can login to the system,
    but can also be a massive security hole! To overcome this you can edit <code>/etc/ssh/sshd_config</code> and make sure the key <code>AuthorizedKeyFile</code> reads as:
  </p>
  <pre>AuthorizedKeysFile /etc/ssh/authorized-keys/%u</pre>
  <p>
    Where the &quot;<code>%u</code>&quot; expands during connection setup to the user-name of the user trying to log in.
  </p>
  <p>
    To use a specific key to log into the SSH server use:
  </p>
  <pre>ssh -i /path/to/private-key user-name@server_ip</pre>
  <p></p>
</div>

<h2>SSH Tunneling</h2>
<div>
<h3>References</h3>
<ol>
  <li><a href="https://www.revsys.com/writings/quicktips/ssh-tunnel.html" target="_blank">Quick-Tip: SSH Tunneling Made Easy</a>, by Frank Wiles
  </li>
  <li><a href="https://www.ssh.com/ssh/tunneling/" target="_blank">SSH tunnel</a>, SSH Achademy.
  </li>
  <li><a href="https://www.ssh.com/ssh/tunneling/example" target="_blank">SSH Port Forwarding Example</a>, SSH Achademy.
  </li>
</ol>
<p>
  <blockquote>
    <p>
      <code><b>-f</b> Requests ssh to go to background just before command execution.</code>
    </p>
    <p>
       <code><b>-L</b> [bind_address:]port:host:hostport</code>
    </p>
    <p>
       Specifies that the given port on the local (client) host is to be forwarded to the given host and port on the remote side.  This works by allocating a socket to listen to port on the local side, optionally bound to the specified bind_address. Whenever a connection is made to this port, the connection is forwarded over the secure channel, and a connection is made to host port hostport from the remote machine.  Port forwardings can
       also be specified in the configuration file.  IPv6 addresses can be specified by enclosing the address in square brackets.  Only the superuser can forward privileged ports.  By default, the local port is bound in
       accordance with the GatewayPorts setting.  However, an explicit bind_address may be used to bind the connection to a specific address.  The bind_address of -localhost- indicates that the listening port be bound for
       local use only, while an empty address or -*- indicates that the port should be available from all interfaces.
     </p>
     <p>
        <code><b>-N</b> Do not execute a remote command.  This is useful for just forwarding ports (protocol version 2 only).</code>
     </p>
     <footer>-- Bash man page for SSH</footer>
  </blockquote>
</p>
<p>
  This diagram will help explain it:
</p>
<p>
  <img src="##IMG_DIR##/ssh_tunnel.png"/>
</p>
<p>
  This is why the following works <a href="https://www.revsys.com/writings/quicktips/ssh-tunnel.html" target="_blank">[Ref]</a>:
</p>
<pre class="prettyprint linenums">
ssh -N -f user@server.com -L 2000:server.com:25 -N
#   ^  ^  ^^^^^^^^           ^^^^^^^^^^^^^^^^^^^^^
#   ^  ^  ^^^^^^^^           Host port 2000 is forwarded to port 25 on remote server server.com.
#   ^  ^  ^^^^^^^^
#   ^  ^  User on remote server.
#   ^  ^
#   ^  Go into background.
#   ^
#   Do not execute a remote command.
</pre>
</div>

</div> <!-- End padding right div -->
</div> <!-- End content div -->
</body>
</html>
 
 
 
 
 

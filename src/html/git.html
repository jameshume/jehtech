<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>GIT Source Control | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>
 
<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">GIT Source Control</h1>
<div style="padding-right:10px;">

<p>
    GIT is a software configuration management (SCM) tool. This page offers notes on some
    of the more useful GIT commands and workflows such as merging, rebasing, hunks and patches.
</p>

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References</h2>
<div>
<ol>
    <li><a href="http://git-scm.com/doc" target="_blank">GIT SCM</a>.</li>
    <li><a href="https://progit2.s3.amazonaws.com/en/2015-08-09-23511/progit-en.661.pdf"
        target="_blank">Pro Git</a> eBook.
    </li>
    <li><a href="https://www.amazon.co.uk/gp/product/B00QFIA5OC/ref=oh_aui_d_detailpage_o00_?ie=UTF8&psc=1"
           target="_blank">Ry's Git Tutorial</a>, Ryan Hodson.
    </li>
    <li><a href="https://git-scm.com/book/en/v1/Git-Basics-Undoing-Things" target="_blank">Git Basics - Undoing Things</a>, Git Docs.
    </li>
    <li><a href="https://www.atlassian.com/git/tutorials/undoing-changes" target="_blank">Undoing Changes</a>, Atlassian Git Tutorial Page.
    </li>
    <li><a href="https://stackoverflow.com/questions/927358/how-to-undo-the-last-commits-in-git" target="_blank">How to undo the last commits in Git?</a>, SO Thread.
    </li>
    <li><b>Awesome page... just found this and it looks great:</b> <a href="https://onlywei.github.io/explain-git-with-d3/" target="_blank">Visualizing Git Concepts with D3</a>. Visit this page, it is really cool!</li>
    <li><a href="https://github.com/loranallensmith/git-scenarios" target="_blank">Common Git Scenarios</a>.</li>
</ol>
</div>

<h2>To Read / To Do</h2>
<div>
    <pre>https://stackoverflow.com/questions/35941566/delete-remote-branch-via-git
https://stackoverflow.com/questions/1889559/git-diff-to-ignore-m
https://stackoverflow.com/questions/1822849/what-are-these-ms-that-keep-showing-up-in-my-files-in-emacs
https://stackoverflow.com/questions/1510798/trying-to-fix-line-endings-with-git-filter-branch-but-having-no-luck/1511273
https://stackoverflow.com/questions/10002239/difference-between-git-checkout-track-origin-branch-and-git-checkout-b-branch/10002469#10002469
https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune

https://git-scm.com/docs/git-merge
https://stackoverflow.com/questions/4693588/git-what-is-a-tracking-branch/4697054#4697054
https://stackoverflow.com/questions/3471827/how-do-i-list-all-remote-branches-in-git-1-7
https://medium.com/@zaran.56/how-to-recover-restore-deleted-git-branch-5a068c07bed2
https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git
https://stackoverflow.com/questions/5308816/how-to-use-git-merge-squash
https://www.atlassian.com/git/tutorials/git-prune
http://www.totallynota.ninja/2016/06/why-i-prefer-merging-over-rebasing-in.html
</pre>
</div>

<h2>GitHub Related Sites</h2>
<pre>https://app.codacy.com
https://circleci.com
https://travis-ci.org
https://cirrus-ci.com
https://ci.appveyor.com
</pre>

<h2>Where Git Finds Your SSH File</h2>
<div>
	<p>
		I had a little problem on Windows. When I connected from my office location
		Git would fail to SSH into GitHub. When I connected from home Git would
		connect to GitHub with no problem whatsoever.
	</p>
	<p>
		The reason for this is that when connecting from the office my HOME DIRECTORY
		changed and git was looking for my key files relative to the home
		directory!
	</p>
	<p>
		The solution was found in this
		<a href="https://superuser.com/questions/232373/how-to-tell-git-which-private-key-to-use/920849#920849"
			target="_blank">SO thread answer</a>. The solution is to create a
		shell script that will involke the ssh client with the a parameter to tell
		it where to look for key files: give this parameter an obsolute path that
		is not relative to HOME.
	</p>
	<pre>#!/bin/sh
ssh -i /absolute/path/to/key/folder/id_rsa $*</pre>
	<p>
		In the above script <tt>id_rsa</tt> is the key filename. You might have
		saved your private key with a different file name. Save the script somewhere
		and give it executable permissions (<tt>chmod +x <i>filename</i></tt>).
	</p>
	<p>
		Then set the environment variable <tt>GIT_SSH</tt> to the absolute path
		to the script you just created.
	</p>
	<pre>export GIT_SSH=/path/to/your/script.sh</pre>
	<p>
		Now your <tt>git push</tt> operations etc should work just fine.
	</p>
</div> <!-- END H2: Where Git Finds Your SSH File -->

<h2>Create A Public/Private Keypair And Add To Your Keyring</h2>
<div>
    <pre>https://ourcodeworld.com/articles/read/1421/how-to-create-a-ssh-key-to-work-with-github-and-gitlab-using-puttygen-in-windows-10</pre>
    <p>
        References:
    </p>
    <ul><li><a href="https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git" target="_blank">Set up SSH for Git</a>, Atlassian Documentation.</li>
        <li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank">Connecting to GitHub with SSH</a>, GitHub Help.</li>
    </ul>

    <p>Check your home directory (if on a corporate network it might not be what you expect).</p>
    <pre>echo $HOME
echo ~</pre>

    <h3>Older school</h3>
    <p>To create SSH key pair:</p>
    <pre>ssh-keygen</pre>

    <h3>New school</h3>
    <pre>$ ssh-keygen -t ed25519 -C "your_email@example.com"  # Create a new SSH key, using the provided email as a label.
$ eval "$(ssh-agent -s)"                             # Start the ssh-agent in the background
$ ssh-add ~/.ssh/id_ed25519                          # Add your SSH private key to the ssh-agent</pre>        

    <p>To see your public key type:</p>
    <pre>cat ~/.ssh/id_rsa.pub</pre>

    <p>To check that SSH is working...</p>
    <pre>ssh -T git@bitbucket.org
# or...
ssh -T git@github.com</pre>

    <p>
        If you see an error message saying &quot;Could not open a connection to your authentication agent&quot;
        make sure that your ssh agent is running. If it isn't run <code>eval `ssh-agent -s`</code>
        to start it [<a href="https://stackoverflow.com/questions/17846529/could-not-open-a-connection-to-your-authentication-agent" target="_blank">Ref</a>].
    </p>

    <p>
        For more detailed debugging use:
    </p>
    <pre>ssh -vvv -T git@bitbucket.org</pre>

    <p>To see if the key has been added to the client keyring...</p>
    <pre>ssh-list -l
# or...
ssh -vT address-of-server</pre>

	<p>
		Followed the GitHub instructions to create the private/public RSA key pair. Having obtained
		this key it can be added to the keyring using the following, but this addition is <em>not</em>
		permanent.
	</p>
	<pre>ssh-add ~/.ssh/some_key_name</pre>
    <p>If the SSH agent isn't running use:</p>
    <pre>eval $(ssh-agent)</pre>
	<p>
		So to make the addition permanent I consulted
		<a href="http://stackoverflow.com/questions/3466626/add-private-key-permanently-with-ssh-add-on-ubuntu" target="_blank">this SO thread</a>.
		When you created the OpenSSH key pair you probably stored it as <tt>~/.ssh/some_key_name</tt>
		(the private key) and <tt>~/.ssh/some_key_name.pub</tt> (the public key). To add these permanently to your
		keyring edit the file <tt>~/.ssh/config</tt> (and if it is empty just create it). Add the
		following line (replicate once for each key you wish to permenantly add):
	</p>
	<pre>IdentityFile ~/.ssh/some_key_name</pre>
    <p></p>

    <h3>PuttyGen</h3>
    <ol>
        <li>Generate key: Click "Generate" and add a passphrase for the key.</li>
        <li>Save PuTTY private key: Click "Save private key" and save with a ".ppk" extension, e.g., "my-new-key.ppk"</li>
        <li>Save OpenSSH public key: Copy and paste from top text box into a file and save as a ".pub" file, e.g., "id_rsa_my-new-key.pub"</li>
        <li>Save OpenSSH private key: From top menu select "Conversions &gt; Export OpenSSG key (force new file format)". Save as id_rsa file, or for e.g., just "ids_rsa_my-new-key"</li>
    </ol>
</div> <!-- END: Create A Public/Private Keypair -->

<h2>Debugging A Git Connection</h2>
<p>
    First try connecting over HTTPS:
</p>
<pre>ssh -T -p 443 git@ssh.github.com</pre>
<p>
    If this works you can then try to debug your SSH connection. You can use <code>GIT_SSH_COMMAND</code> [<a href="https://github.com/capistrano/capistrano/issues/1421" target="_blank">Ref</a>] as so, replacing the git command with whatever you like:
</p>
<pre>GIT_SSH_COMMAND="ssh -vvv" git push</pre>
<p>
    If this isn't playing ball, checkout your <code>~/.ssh/config</code> file. It should contain this [<a href="https://help.github.com/articles/using-ssh-over-the-https-port/" target="_blank">Ref</a>]:
</p>
<pre>Host github.com
  Hostname ssh.github.com
  Port 443</pre>

<h2>Git Workspace v.s. Index v.s. Repository</h2>
<div>
    <p>
        <img src="##IMG_DIR##/git_workspace_index_repo.png" alt="Diagram of Git worspace vs index vs respository"/>
    </p>
</div>

<h2>Configuring Git</h2>
<div>
<p>
   Setup your user name and email globally:
</p>
<pre>git config --global user.name &quot;name&quot;
git config --global user.email &quot;email&quot;</pre>

<p>
    You can override the global settings for specific repos by chaning to the repo's root
    and running:
</p>
<pre>git config user.name &quot;name&quot;
git config user.email &quot;email&quot;</pre>

<p>
   Setup your editor and diff tool:
</p>
<pre>git config --global core.editor gvim
git config --global merge.tool vimdiff</pre>

<p>
   To see your config setup:
</p>
<pre>git config --list</pre>

<p>
    To see a specific key’s config:
</p>
<pre>git config key-name</pre>
<p>
    For example...
</p>
<pre>git config user.name</pre>
</div>

<h2>Search (Grep) Your Repo</h2>
<div>
<p>
Using <code>git grep</code> ignores git interal files and generated files, which can make your
grepping life a lot easier!
</p>
</div>

<h2>Cheat Sheet Of Basic Git Commands</h2>
<div>
    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Creating Git Repos</h3>
    <p>
        To create a repo in the CWD:
    </p>
    <pre>git init</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Cloning Git Repos</h3>
    <p>
        To clone a repo:
    </p>
    <pre>git clone https://repo_addr [dirname]
git clone git://repo_addr [dirname]</pre>
    <p>
        This pulls down data for the repo into dirname, if provided, or to an automatically decided
        dirname in the CWD otherwise. Note you get the <em>entire repo</em> including <em>all the history</em>
        copied locally. A remote called &quot;origin&quot; will be automatically added to point
        to <code>https://repo_addr</code>.
    </p>
    <p>
        If you want to control the amount of history you download use the <code>--depth=<i>n</i></code> option. Normaly you would
        use <code>--depth=1</code> to get just the HEAD with no history. This equals <em>faster cloning</em> at the expense of 
        a history.
    </p>
    <p>
        To do an even faster clone, you may also consider <code>--single-banch --branch <i>branch-name</i></code>.
    </p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Checking Out Repos</h3>
    <p></p>
    <blockquote>
        <p>
        Checking out a commit makes the entire working directory match that commit. This can be used to view an old state of your project without altering your current state in any way. Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.</p>
        <footer><a href="https://www.atlassian.com/git/tutorials/undoing-changes" target="_blank">Undoing Changes</a>, Atlassian Git Tutorial Page.</footer>
    </blockquote>
    <pre>git checkout commit-hash | tag-name | branch-name</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Git Branches</h3>
    <p>
        A branch is lightweight moveable pointer to a commit and the default branch name
        is &quot;master&quot;. HEAD points to current branch head, so changes when you change branch.
    </p>

    <p>
        To list all the branches in the repo type:
    </p>
    <pre>git branch</pre>
    <p>You can filter the list with the <code>--merged</code> and <code>--no-merged</code> options
        to see branches that are not merged back in etc.</p>

    <p>To create and checkout a new branch use:
    </p>
    <pre>git branch new-branch-name
git checkout new-branch-name</pre>
    <p>The shorthand for the above is:</p>
    <pre>git checkout <b>-b</b> new-branch-name</pre>

    <p>To locally delete a branch (branch history still exists and is recoverable):</p>
    <pre>git branch <b>-d</b> branch-name</pre>

    <p>To delete a branch on the remote:</p>
    <pre>git push origin --delete branch-name</pre>

    <p>To switch branches use:</p>
    <pre>git checkout branch-name</pre>
    <p>Now, HEAD will point to new branch and NOT prev branch.</p>
    <p>Note that switching branches changes files in your working directory.
         When you switch branches, Git resets your working directory to look
         like it did the last time you committed on that branch.</p>


    <h3>Finding A Branch Point With Git</h3>
    <p>
        The guy who figured this out <a href="https://stackoverflow.com/a/4991675/1517244" target="_blank">answered this title's question on StackOverflow</a>. Bloody genious!
    </p>
    <pre>diff -u <(git rev-list --first-parent topic) \
             <(git rev-list --first-parent master) | \
     sed -ne 's/^ //p' | head -1</pre>
    <p>
       Or more robustly...
    </p>
    <pre>git config --global alias.oldest-ancestor '!zsh -c '\''diff --old-line-format='' --new-line-format='' <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | head -1'\'' -'</pre>
    <p></p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Adding Files To Your Git Repo</h3>
    You must add files from your workspace into the Git index so that Git knows what to track...
    <pre>git add .  # adds all files (tracked or not) in cwd
git add -u # puts all changed tracked files into staging area (i.e., wont add new files)
git add -A # does both of the above</pre>
    <p>
       Note that if you modify a file <em>after</em> staging, the modifications after the stage
        will not be committed in this commit unless added again.
    </p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Committing Files</h3>
    <p>Each commit is pointer to snapshot plus author/committer details, msg etc and
        pointer to prev commit (or commits if this is a result of merge).
        </p>
    <p>
        To commit all <em>staged</em> changes:
    </p>
    <pre>git commit -m &quot;your msg here&quot;</pre>

    <p>
        To commit all tracked files, staged or not, use:
    </p>
    <pre>git commit <b>-a</b> -m &quot;...&quot;</pre>
    <p>Any tracked file that is not staged will be automatically staged.</p>

    <p>
        To ammed the last commit, adding in all currently staged files use:
    </p>
    <pre>git commit --amend</pre>
    <p>
        This will give you the chance to modify the last commit (launches text editor) and will
        also add any currently staged files into the last commit. For example:
    </p>
    <pre>git commit -m &quot;a commit where I forgot to add a file&quot;
git add forgotten_file
git commit --amend</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Git Logs: Viewing Your History</h3>
    <p>
        To get a summary of changes made with author, date, full commit hash and description:
    </p>
    <pre>git log</pre>

    <p>
        To do the same but for a particular directory:
    </p>
    <pre>git log &lt;options&gt; -- &lt;dirname&gt;</pre>

    <p>
        To get a one-line-per-commit summary (short hash and description):
    </p>
    <pre>git log <b>--online</b></pre>

    <p>
        To get just the commit ID:
    </p>
    <pre>git log -1 --pretty=format:"%H" HEAD</pre>

    <p>
        To get a log between versions/tags/commits/nranches etc:
    </p>
    <pre>git log <b>chng..chng</b></pre>
    <p>
        where <code>chng</code> can be a tag name, a commit's hash, a branch name etc.
    </p>

    <p>To limit the log to the last 5 entries:</p>
    <pre>git log -5</pre>

    <p>To view the differences introduced in each commit:</p>
    <pre>git log -p</pre>

    <p>To view the logs for the last two weeks:</p>
    <pre>git log --since=2.weeks</pre>
    <p>
        Use &quot;&lt;number&gt;.&lt;time-period-type&gt;&quot;. So, for example, the time period could also
        be &quot;days&quot; or &quot;hours&quot;.
    </p>

    <p>To grep the log for commits that introduces a change to the code that added or removed a
        search string:
    </p>
    <pre>git log -S&lt;search-string&gt;</pre>
    
    <p>
        To do the same, (i.e. search the commit <em>diff</em>) but using regular expressions <a href="https://stackoverflow.com/a/9045562/1517244" target="_blank">[Ref]</a>:
    </p>
    <pre>git log -G'helper.*function' --full-history --all</pre>

    <p>
        To search through the commit <em>messages</em> use <a href="https://stackoverflow.com/a/15120469/1517244" target="_blank">[Ref]</a>:
    </p>
    <pre># case sensitive
git log --all --grep='your-regexp-here'
# case insensitive
git log --all --grep='your-regexp-here' -i</pre>

    <p>To really pretty-print your logs:</p>
    <pre>git log --oneline --decorate --graph --all</pre>

    <p>To show the log with full path names and status of changed files:</p>
    <pre>git log --name-status</pre>

    <p>To show the log with abbreviated pathnames and a diffstat of changed files:</p>
    <pre>git log --stat [-M]</pre>
    <p>Add the <code>-M</code> option to detect and show moves.</p>

    <p>To show all the commits in which a certain file is changed and a certain function (awesome!): </p>
    <pre>git -L:func-name:path-to-file</pre>

    <p>Get revisions committed by specific author</p>
    <pre>git log [--oneline] [--name-only] --author=name</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Tagging Files With Git</h3>
    <p>
        Tags are &quot;nice&quot; names by which you can identify snapshots of a repo. For example,
        you will likely tag releases.
    </p>
    <pre>git tag -a &lt;tag-name&gt; -m "Description of tag"
        ^^
        -a means create an annotated tag (stores name, date and msg)</pre>

    <p>To list all the available tags in your repo:</p>
    <pre>git tag</pre>

    <p>To search for tags with names matching a given pattern:</p>
    <pre>get tag -l &lt;pattern&gt;</pre>

    <p>To see/search for tags on remote:</p>
    <pre>git ls-remote --tags /some/url/to/repo ["refs/tags/MyTag^{}"]
#                                       ^                  ^
#                                       Quotes are required here!</pre>

    <p>An important point to note is that <b><code>git push</code> does NOT transfer tags to remote servers!</b>
    You must do this explicity using <code>git push origin &lt;tagname&gt;</code>
    </p>

    <p>Delete tags locally:</p>
    <pre>git tag -d tag_name</pre>

    <p>List tags on remote:</p>
    <pre>git ls-remote --tags origin</pre>

    <p>Delete tags on remote:</p>
    <pre>git push --delete origin tag_name</pre>

    <p>Push commits <em>and</em> tags in one go:</p>
    <pre>git push --follow-tags</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Undoing Things</h3>
    <p>
        This section remains a little cheat sheety in style. I'm going to
        expand on it in a later section...
    </p>

    <p><b>Revert unstanged changes:</b></p>
    <p>Kinda like reverting a file in the SVN sense</p>
    <pre>git checkout -- filename</pre>
    <p>
        By refering to the diagram describing the working directory vs the index
        we can understand what this is doing. We have modified a local file but
        not staged the changes yet. By checking out the file we're just overwriting
        the changes in the working directory, which Git, because we haven't
        staged these changes, knows nothing about.
    </p>

    <p><b>To unstage a file:</b></p>
    <pre>git reset HEAD -- filename</pre>
    <p>This resets the index entry for &quot;filename&quot; to its state at
        HEAD, therefore removing it from the index. Note this changes the
        <em>index entry</em>, which is distinct from your working directory.
        The file in the working directory is not touched.
    </p>

    <p>
        <b>To undo all uncomitted changes to tracked files:</b>
    </p>
    <pre>git reset --hard</pre>
    <p>The option <code>--hard</code> resets (to the most recent commit) the index and the working tree.</p>

    <p><b>A Note About Reset:</b></p>
    <p>A <code>git reset</code> actually alters your history and can only work
        backwards from the current commit. By altering the history <b>you could
        potentially loose history</b>. Also once a change is pushed to a shared
        repository, resetting the change afterwards can become troublesome! You
        will also <b>loose all uncommitted changes</b>.
    </p>
    <blockquote>
        <p>If git revert is a &quot;safe&quot; way to undo changes, you can <b>think of git reset as the dangerous method</b>. When you undo with git reset(and the commits are no longer referenced by any ref or the reflog), there is no way to retrieve the original copy — <b>it is a permanent undo</b>. Care must be taken when using this tool, as it’s one of the only Git commands that <b>has the potential to lose your work</b>.</p>
        <footer><a href="https://www.atlassian.com/git/tutorials/undoing-changes" target="_blank">Undoing Changes</a>, Atlassian Git Tutorial Page (emphasis mine).</footer>
    </blockquote>

    <p><b>To remove a file from repo withOUT deleting it locally:</b></p>
    <pre>git rm --cached myfile.name</pre>

    <p>
        <b>To remove untracked files use:</b>
    </p>
    <pre>git clean -f</pre>

    <p>
        <b>To undo a commit use:</b>
    </p>
    <pre>git revert commit-id</pre>
    <blockquote>
        <p>The <code>git revert</code> command undoes a committed snapshot. But, instead of removing the commit from the project history, it <b>figures out how to undo the changes</b> introduced by the commit and <b>appends a new commit with the resulting content</b>. This prevents Git from losing history, which is important for the integrity of your revision history and for reliable collaboration.</p>
        <footer><a href="https://www.atlassian.com/git/tutorials/undoing-changes" target="_blank">Undoing Changes</a>, Atlassian Git Tutorial Page (emphasis mine).</footer>
    </blockquote>
    <p></p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Listing Files In The Git Repo</h3>
    <p>To list files currently being tracked on branch master:
    </p>
    <pre>git ls-tree -r master [--name-only]</pre>
    <p>
        The above will list all files and directories in master, recursively,
        that are being tracked. Each line output is for one file and consists
        of the file's latest comment hash and the file path. If
        <code>--name-only</code> is used then the commit hash is ommitted.
    </p>
    </p>
    <p>
        To do the same, but list on the current branch:
    </p>
    <pre>git ls-tree -r HEAD --name-only</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Diffing With Git</h3>
    <pre>git diff: What you have changed but NOT staged
git diff --staged: What will go into next commit
git diff --cached: Synonym for --staged
git difftool -y [tool=(kdiff3|p4merge|...):      To use external diff tool</pre>

    <p>To view only the names of files changed between two commits:</p>
    <pre>git diff 99f6eae 0544f6a --name-only</pre>

    <p>To produce a diff between commits but only for a subset of files,
    for example do:</p>
    <pre>diffstart=99f6eae
diffend=0544f6a
wanted=$(git diff $diffstart $diffend --name-only  | grep -v "\(xls\|tsv\)$")
git diff $diffstart $diffend --full-index  -- $wanted</pre>
    <p></p>

    <p>
    	The <code>difftool</code> can be configured by setting the configuration variable <code>difftool.&lt;tool&gt;.path</code>. To set a default
    	tool edit the file <code>~/.gitconfig</code> and in the <code>[diff]</code> section add or change the line <code>tool = your-tool</code>.
    	For anything else out of the ordinay see <a href="https://stackoverflow.com/questions/255202/how-do-i-view-git-diff-output-with-my-preferred-diff-tool-viewer" target="_blank">this SO thread</a>.
    </p>

    <h4>Diffing Between 2 Repos</h4>
    <p>
        From <a href="https://stackoverflow.com/questions/1968512/getting-the-difference-between-two-repositories" target="_blank">this SO thread:</a>
    </p>

    <blockquote>
        <p><b>Question:</b></p>
        <p>
            How can we get the difference between two git repositories?
        </p>
        <p>
            The scenario: We have a repo_a and repo_b. The latter was created as a copy of repo_a. There have been parallel development in both the repositories afterwards. Is there a way we can list the differences of the current versions of these two repositories?
        </p>
        <p><b>Answer:</b></p>
        <p>In repo_a:</p>
        <pre>git remote add -f b path/to/repo_b.git
git remote update
git diff master remotes/b/master
git remote rm b</pre>
        <footer>-- <a href="https://stackoverflow.com/questions/1968512/getting-the-difference-between-two-repositories" target="_blank">Getting the difference between two repositories</a></footer>
    </blockquote>
    <p></p>
</div>


<h2>Git Parlance &amp; Internal Structure</h2>
<div>
    <h3>What Are Commits And How Do They Store Snapshots?</h3>
    <p>
        The Git Book on the internals of Git (Git Objects) has a good explanation of
        how Git repos are organised <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" target="_blank">[Ref]</a>
        <a href="https://git-scm.com/book/en/v1/Git-Branching-What-a-Branch-Is" target="_blank">[Ref]</a>.
    </p>
    <p>
        To summarise a little:
    </p>
    <ol>
        <li><b>Commit</b> - stores meta data (author, committer, comment) and pointer to the <em>top level</em>
            tree snapshot as well as the previous commit (or commits if a merge commit). The commit object
            itself is identified by a sha1 pointer. Note that we said &quot;top level&quot;: the commit is
            a snapshot of your entire repo.
        </li>
        <li><b>Tree</b> - corresponds to a directory - collection of pointers (pair of sha1 hash and file name)
            to file blobs and trees.
        </li>
        <li><b>Block</b> - a binary blob representing a file with an associated sha1 hash.
        </li>
    </ol>
    <p>
        <img src="##IMG_DIR##/git_objects.png" alt="Diagram of GIT commits, trees and blobs"/>
    </p>

    <h3>Commit-ish &amp; Tree-ish?!</h3>
    <p>Two terms you might see in the documentation are &quot;<b>commit-ish</b>&quot; and
    &quot;<b>tree-ish</b>&quot; <a href="https://www.kernel.org/pub/software/scm/git/docs/#_identifier_terminology" target="_blank">[Ref]</a>.
    </p>
    <p><b>&quot;Commit-ish&quot;</b> means an identifier that references a commit object in the repo. For
        example a tag is an identifer that references a commit, as is the sha1 hash for that commit.
    </p>
    <p><b>&quot;Tree-ish&quot;</b> means an identified that references part of the repo's tree. Again, a
    tag can be &quot;tree-ish&quot; because it references a commit, from which we can access
    the files and folders that the commit is a snapshot of.
    </p>

    <h3>What is HEAD?</h3>
    <pre>TODO:
    https://stackoverflow.com/questions/5772192/how-can-i-reconcile-detached-head-with-master-origin
    https://git-scm.com/book/tr/v2/Git-Internals-Git-References</pre>
    <p>
    </p>
    <blockquote>
        <p>The HEAD file is a symbolic reference to the branch you’re currently on. By symbolic reference, we mean that unlike a normal reference, it doesn’t generally contain a SHA-1 value but rather a pointer to another reference</p>
        <footer>
            <a href="https://git-scm.com/book/tr/v2/Git-Internals-Git-References" target="_blank">Git Internals - Git References</a>, Git Docs.
        </footer>
    </blockquote>
    <p></p>
</div>

<h2>Specifying Revisions</h2>
<p>
	Read <a href="schacon.github.io/git/git-rev-parse.html#_specifying_revisions" target="_blank">the Docs</a> :)
</p>
<h3>Immediate Parents</h3>
<p>
	You can iterate through immediate parents using the hat character (<code>^</code>) there <code>^n</code>
	selects the n<sup>th</sup> immediate parent. Note that <code>&lt;rev&gt;^</code> is a shorthand for
	<code>&lt;rev&gt;^1</code>.
</p>
<h3>Grand Parents</h3>
<p>
	The notation <code>~n</code> selects the n<sup>th</sup> generation grand-parent. For example,
	<code>~1</code> selects the first parent, and <code>~2</code> selects the first grand-parent,
	and <code>~3</code> selects the first great grand-parent
</p>
<h3>Parent v.s. Grand Parent Selection</h3>
<p>Straight from <a href="schacon.github.io/git/git-rev-parse.html#_specifying_revisions" target="_blank">the Docs</a>:</p>
<pre>G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
A =      = A^0
B = A^   = A^1     = A~1
C = A^2  = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2</pre>
<p></p>

<h2>Revert &amp; Reset</h2>
<div>
    <p>
        As we have seen in previous quotes above, <code>revert</code> is a safer version of
        <code>reset</code>. The former creates a new commit which represents the changes needed to
        to revert the former HEAD to a previous commit. It does not change any of the previous
        commits.
    </p>
    <p>
        A <code>reset</code> on the other hand has the potention to obiliterate information.
    </p>
    <h3>Resetting The Index (aka. The Staging Area)</h3>
    <p>
        One of the cheat-sheet snippets we saw earlier was <code>git reset HEAD -- filename</code>,
        which unstaged a file. From the Git help we get the following explanation:
    </p>
    <blockquote>
        <p><code>git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...</code>
        </p>
        <p>This form resets the index entries for all &lt;paths&gt; to their state at &lt;tree-ish&gt;. 
           (It does not affect the working tree or the current branch.)
        </p>
        <p>This means that git reset &lt;paths&gt; is the opposite of git add &lt;paths&gt;.
        </p>
        <footer>Output of &quot;git reset --help&quot;</footer>
    </blockquote>
    <p>
        The effect can be visualised as shown in the diagram below:
    </p>
    <p>
        <img src="##IMG_DIR##/git_reset_form1.png" alt="Diagram showing effect of git reset HEAD -- filename"/>
    </p>

    <h3>Moving Your Branch HEAD Around &amp; Maybe Modify The Working Tree + Index</h3>
    <p>Another form of the <code>git reset</code> command can be used to move the HEAD of the
        current branch around. In all forms the HEAD of the branch is moved to a specific
        commit. What happens to the index and woking tree depends on the mode in which it is
        used...
    </p>
    <blockquote>
        <p><code>git reset [&lt;mode&gt;] [&lt;commit&gt;]</code>
        </p>
        <p>This form resets the current branch head to &lt;commit&gt; and possibly updates the index 
            (resetting it to the tree of &lt;commit&gt;) and the working tree depending on &lt;mode&gt;. 
            If &lt;mode&gt; is omitted, defaults to "--mixed". The &lt;mode&gt; must be one of the following:
        </p>
        <ul>
            <li><p><code>--soft</code>:</p>
                <p>Does not touch the index file or the working tree at all (but resets the head to &lt;commit&gt;, just like all modes do). This leaves all your changed files "Changes to be committed", as git status would put it.</p>
            </li>


           <li><p><code>--mixed</code></p>
               <p>Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</p>
               <p>If <code>-N</code> is specified, removed paths are marked as intent-to-add.</p>
           </li>
           <li><p><code>--hard</code></p>
               <p>Resets the index and working tree. Any changes to tracked files in the working tree since &lt;commit&gt; are discarded.</p>
           </li>
           <li><p><code>--merge</code></p>
               <p>Resets the index and updates the files in the working tree that are different between &lt;commit&gt; and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between &lt;commit&gt; and the index has unstaged changes, reset is aborted.</p>
               <p>In other words, <code>--merge</code> does something like a <code>git read-tree -u -m &lt;commit&gt;</code>, but carries forward unmerged index entries.</p>
           </li>
           <li><p><code>--keep</code></p>
               <p>Resets index entries and updates files in the working tree that are different between &lt;commit&gt; and HEAD. If a file that is different between &lt;commit&gt; and HEAD has local changes, reset is aborted.</p>
           </li>
       </ul>
       <footer>Output of &quot;git reset --help&quot;</footer>
    </blockquote>
    <p></p>
    <h3>Soft Reset: Move HEAD, Touch Nothing!</h3>
    <p>
    </p>

    <h3>Mixed Reset: Move HEAD, Touch Only The Index</h3>
    <p>
        <img src="##IMG_DIR##/git_reset_mixed.png" alt="Diagram of a git reset --mixed command"/>
    </p>

    <h3>Hard Reset: Move HEAD, Touch The Index And The Working Tree</h3>
    <p>
        <img src="##IMG_DIR##/git_reset_hard.png" alt="Diagram of a git reset --hard command"/>
    </p>

</div>

<h2>Branches And Commits (v.s. SVN-like SCMs)</h2>
<div>
    <p>
        <img src="##IMG_DIR##/git_branches_and_commits.png" alt="Creating branches in Git vs SVN"/>
    </p>
</div>

<h2>Add &amp; Commit A Subset Of Changes: Hunks</h2>
<div>
    <p>
        I enjoyed learning about this because it is quite often that I find I've fixed two bugs or
        more in the same file. This can be because the two bugs are so tightly coupled that fixing
        one depended on another, or it was a quick fix for something I noticed on the fly and was
        so simple it wasn't worth creating a branch just for this fix. Either way, I end up with a
        file that contains changes that address multiple bugs/tickets.
    </p>
    <p>
        Note: you can also accomplish the same thing using an interactive rebase.</p>
    </p>
    <p>
        Lets test it out. Create a new repo and add a test file...
    </p>
    <pre class="prettyprint linenums">$ git init learngit
Initialized empty Git repository in C:/Users/jh/Documents/Sandbox/learngit/.git/

$ cd learngit

$ echo "#include &lt;stdio.h&gt;
        return 0;
&gt;
&gt; int main(int argc)
&gt; {
&gt;         return 0;
&gt; }
&gt; " &gt; test.c

$ git commit -m "Create a test file.

Create a test file so that in a future commit I can test patch adds"
[master (root-commit) f573b91] Create a test file.
 1 file changed, 6 insertions(+)
 create mode 100644 test.c</pre>
    <p>
        We've created a little git repository and added one file called <code>test/c</code> to it.
        Very very simple. Now let's spoof making two bug fixes by adding the following comments
        just above the <code>return 0</code> statement:
    </p>
    <pre class="prettyprint linenums">/* This line fixes bug A*/
/* This line fixes bug B*/
/* This line fixes bug A*/</pre>
    <p>
        Okay, now I want to make two seperate commits as I'd like to have one commit that deals
        soley with the changes I've made to fix bug A, and another commit that deals soley with
        the changes I've made to fix bug B. This way, any one looking back through the logs will be
        able to easily understand which changes fix which bug.
    </p>
    <p>
        To do this I use the following command:
    </p>
    <pre class="prettyprint linenums">git add -p test.c</pre>
    <p>
        This launches an interactive command line utility:
    </p>
    <pre class="prettyprint linenums">$git add -p test.c<
diff --git a/test.c b/test.c
index 312d3cd..36da841 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,8 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }
<b>Stage this hunk [y,n,q,a,d,/,e,?]? e</b></pre>
    <p>
        The GIT command line askes me whether I want to stage this hunk. What is a &quot;hunk&quot;?
        A hunk is just a set of changes. Currently, we can see above that all the changes in the
        file are grouped together because they app have a plus sign next to them, indicating that
        they will be added in one group.
    </p>
    <p>
        I don't want the line for bug B to be added in this group. So I must split the current hunk
        into smaller hunks. I do this by entering &quot;e&quot;, as shown. This will start the
        configured text editor.
    </p>
    <p>
        To avoid committing the lines associated with bug B, I relpace the <code>+</code> symbol
        at the line start, with a <code>#</code> symbol as so (partial file in editor shown):
    </p>
    <pre class="prettyprint linenums">int main(int argc)
 {
+       /* This line fixes bug A*/
#       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Save and exit from the editor. The command ends. Now if I look at the GIT status, I see
        the following:
    </p>
    <pre class="prettyprint linenums">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   test.c

Changes not staged for commit:
  (use "git add &gt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   test.c</pre>
    <p>
        Oh la la! My file is both staged and unstaged. So have we staged only the changes for bug A?
        Lets find out by looking at what will go into the next commit:
    </p>
    <pre class="prettyprint linenums">$ git diff --staged
diff --git a/test.c b/test.c
index 312d3cd..67cc02e 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,7 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Sweet! So now I can commit these changes, then add the remaining bug B changes and commit
        them in a seperate commit... happy days!
    </p>
    <p>
        BUT before I do this, I should really make sure that the changes that I have staged are
        good: they produce a compilable set of changes that don't break the build and the changes
        do in fact do what the commit message associated with them says. To do this I would like
        to save my unstaged changes and take them out of the workspace, whilst leaving the
        staged changes in the workspace:
    </p>
    <pre class="prettyprint linenums">$ git stash --keep-index</pre>
    <p>
        Now I can review/test etc the staged changes in isolation. Once I'm happy I can run
        a <code>git commit</code>, and then to restore the remaining unstaged stuff I can run:
    </p>
    <pre class="prettyprint linenums">$ git stash pop</pre>
    <p>
        I can now repeat these steps for the bug B changes and so one...
    </p>

</div> <!-- END Adding Only Parts Of Giles -->

<h2>Integrating</h2>
<div>
    <h3>Fast forward</h3>
    <p>
        <img src="##IMG_DIR##/git_fastfwd.png" alt = "Fast forward merge of branches in Git"/>
    </p>
    <p>
        From the master directory you would merge in the new feature. But because the history
        has not divereged Git can just fast forward the master's HEAD to point to the latest
        commit.
    </p>
    <p>
        Would be done using something like this:
    </p>
    <pre  class="prettyprint linenums"># create a new branch of master
git checkout master
git checkout -b new_feature

# do some development in the new branch and then commit
git commit -m "Some new development, a fix, whatever"

# Go back to master and merge in the &quot;new_feature&quot; branch...
git checkout master
git merge new_feature

# Cleanup feature branch
git branch -d new_feature</pre>

    <h3>Merging</h3>
    <p>
        Git will do 3-way merge using the common ancestor.
        In this case, because the history between the master and feature branches has diverged,
        a simple fast-forward integration can not be performed. Instead a new commit in the master
        branch is created that exists soley to identify that a merge has taken place.
    </p>
    <p style="float: left;">
        <img src="##IMG_DIR##/git_merge.png" alt = "Merging branches in Git"/>
    </p>
    <p>
        Would be done using something like this:
    </p>
    <pre  class="prettyprint linenums"># create a new branch of master
git checkout master
git checkout -b new_feature

# do some development in the new branch and then commit
git commit -m "Some new development, a fix, whatever"

# !! Meanwhile someone else creates extra commits on the master branch !!

# Go back to master and merge in the &quot;new_feature&quot; branch...
git checkout master
git merge new_feature

# Cleanup feature branch
git branch -d new_feature</pre>
    <p style="clear: both;">
        A lot of people (including me) like these kinds of integration. Its the typical way merging is done in other
        revision control systems like SVN, for example. All the history is preserved and it is
        clear that this commit represents a merge.
    </p>
    <p>
        However, a counter argument is that we might not want to &quot;pollute&quot; our master
        branch with commits that only represent a merge. The idea is that the master line should
        show a story where each commit is some extra feature or bug-fix. We shouldn't see a ton
        of merge-commits (could be a ton in a busy master branch!). We only want to see
        the story, and that story should course-grained (i.e, for a bug fix only one extra commit
        rather than the many commits that may have been made in the development branch). This is
        why a lot of Git users prefer rebasing (see below).
    </p>

    <h3>Merging With A Squash</h3>
    <p>
    	The <code>git merge</code> command has an option <code>--squash</code>.
    </p>
    <img style="float:left;" src="##IMG_DIR##/git_merge_squash.png" alt="Image describing the 'git merge --squash' command"/>
    <p>
    	You can see code that tests this out here - <a href="https://github.com/jameshume/bash-scripts/blob/master/test_git_squash_merge.sh" target="_blank">test_git_squash_merge.sh</a>.
    </p>
    <p>
    	One can see that the squash-merge is a little bit like a rebase, except that the original branch is left alone. This has the advantage of not destorying your branch, in case you want to continue using it, or have done something wrong (and a rebase would have been harder to undo). Its basically a kinda-safer shortcut to rebasing and squashing your development branch onto the master.
    </p>

    <h3 style="clear:both;">Rebasing</h3>
    <p>The Git world offers something that CVS, SVN, Perforce etc users won't be as familiar
       with... rebasing. It gives you a cleaner (no merge commits polluting the project history)
       and a more linear project history by taking changes
       you made in your development branch, possibly combining several dev changes into one single
       commit on the fly, and &quot;appending&quot; them to another branch as-if the changes
       we made on that branch.
    </p>

    <h4>The Vanilla Rebase</h4>
    <p>
        <img src="##IMG_DIR##/git_rebase.png" alt = "Rebase branches in Git"/>
    </p>

    <p>We have used the following syntax:</p>
    <pre  class="prettyprint linenums">git rebase &lt;target-branch&gt; &lt;src-branch&gt;</pre>

    <p>Which is equivalent to doing...</p>
    <pre  class="prettyprint linenums">git checkout &lt;src-branch&gt; &amp;&amp; \
git rebase &lt;target-branch&gt; </pre>

    <p>
        I like the first variant because it makes sure you have the correct branch
        checked out <em>before</em> you do the rebase. When you use rebase with only the &quot;target-branch&quot;
        branch, you are rebasing currently checked-out branch onto the target.
    </p>

    <div class="box_container">
        <div class="info">
            <p>
                Use <code>git rebase &lt;target-branch&gt;</code> to rebased the <em>current</em> branch onto &quot;target-branch&quot;.
                <br/>
                Use <code>git rebase &lt;target-branch&gt; &lt;src-branch&gt;</code> to rebase the &quot;src-branch&quot; onto the &quot;target-branch&quot; by checking out &quot;src-branch&quot; first and then doing the rebase.
            </p>
        </div>
    </div>

    <p>
        Can investigate this using this <a href="../downloadables/test_vanilla_rebase.sh" target="_blank">simple little shell script</a>
        that tries to replicate the above. It has two command line uses: either &quot;<code>test_vanilla_rebase.sh master onto new</code>&quot;
        or  &quot;<code>test_vanilla_rebase.sh new onto master</code>&quot;.
    </p>

    <h4 style="clear: both;">Interative Rebasing: Squashing Commits</h4>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>

    <p>
        In the example above where the new feature is rebased onto the master branch,
        3 commits are added to the master for the one new feature. We might
        like to tidy this up a little and only have one new commit in the master branch that is the
        aggregation of all of the commits done during development. This way, the master branch is kept even neater
        with only one change (as we probaly don't care to much about the intermediate development steps - the detail
        - in the main master branch story... it just wants to capture that a new feature was added, not the
        nitty gritty detail of its development stages).
    </p>
    <p>
        Ideally we would do this:
    </p>
    <p>
        <img src="##IMG_DIR##/git_rebase_squash.png" alt = "Interactive rebase of branches in Git with commit squashing"/>
    </p>
    <p>
        And this is what we can achieve using <em>interactive rebasing</em> in Git! Whoop whoop...
    </p>
    <p>
        We can do the interactive rebase using:
    </p>
    <pre  class="prettyprint linenums">git rebase -i master new</pre>
    <p>
        Which, remember, is the same as doing:
    </p>
    <pre  class="prettyprint linenums">git checkout new
git rebase master</pre>
    <p>
        When we do this Git will launch an editor that will allow you to pick the commits from
        new that are going to be replaying on top of master. If we take our <a href="../downloadables/test_vanilla_rebase.sh" target="_blank">simple little shell script</a> and add a &quot;-i&quot; to the rebase command and rebase new onto
        master interactively we will get the following in a text editor:
    </p>
    <pre>pick &lt;hash&gt; First new feature
pick &lt;hash&gt; 2 new feature
pick &lt;hash&gt; 3 new feature
pick &lt;hash&gt; 4 new feature</pre>
    <p>
        If we want to combine everything into one commit, simply change the text to the following
        and save and exit:
    </p>
    <pre>pick &lt;hash&gt; First new feature
<b>squash</b> &lt;hash&gt; 2 new feature
<b>squash</b> &lt;hash&gt; 3 new feature
<b>squash</b> &lt;hash&gt; 4 new feature</pre>
    <p>
        Or lets say, for example if we want to combine the commits &quot;First new feature&quot; and
        &quot;2 new feature&quot; as a single commit but leave the others alone we would do:
    </p>
    <pre>pick &lt;hash&gt; First new feature
<b>squash</b> &lt;hash&gt; 2 new feature
pick &lt;hash&gt; 3 new feature
pick &lt;hash&gt; 4 new feature</pre>
    <p>
        Basically the &quot;squash&quot; command will combine the commit on that line with every
        commit above it, until it hits a &quot;pick&quot; line.
    </p>
    <div>
        <div class="warning">
            <p>If you delete a line from the rebase listing its contents is lost forever... eek!</p>
        </div>
    </div>
    <p style="clear:both;">
    </p>

    <h4 style="clear: both;">Interative Rebasing: Editing Commits</h4>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>
    <p>
        Lets say we <a href="../downloadables/test_ammend.sh" target="_blank">run this script to setup a sandbox repo</a>
        in which to have a little play. We would end up with the following commit log:
    </p>
    <pre>de5fcb1 Third commit about something
466318b Second commit about something, with an error... oops
fca8f1a First commit about something</pre>
    <p>
        We have traced our problem to the second commit and now we want to
        ammend it. Maybe it was something simple like changing the commit
        message or the author. But maybe it is something more complicated like
        a code change that will be required. Either was it doesn't matter.
        We can rebase our own branch like so:
    </p>
    <pre>git rebase -i HEAD~2
              ^^^^^^
              Rebase starting after the second commit before HEAD.
              In this case it is that same as typinh
                 git rebase -i fca8f1a</pre>
    <p>
        Note that with this command we cannot change the first commit. If we
        wanted to do that we could use the option <code>--root</code>, but I'm
        leaving that one out as I can't see myself ever using it.
    </p>
    <p>
        So let's rebase. Git will launch our editor and give us the following:
    </p>
    <pre>pick 466318b Second commit about something, with an error... oops
pick de5fcb1 Third commit about something</pre>
    <p>
        Change the first &quot;pick&quot; to &quot;edit&quot;, and exit the
        editor saving changes. Observe the Git message:
    </p>
    <pre>warning: stopped at 466318b... Second commit about something, with an error... oops</pre>
    <p>
        Git is replaying the history of our branch. It's as-if it rewound the branch
        to its state at commit fca8f1a (the first commit) and then applied the
        changes made in commit 466318b (the second commit), but before
        commiting those changes, it is giving us a chance to make further changes.
        Any changes we make will be written as part of this commit, as-if we
        had actually made them back in time when we actually did the second commit!
    </p>
    <p>
        We're now in a kind-of &quot;temporary world&quot; where we can edit
        this commit before it is applied. If we cat the file we see:
    </p>
    <pre>First line
Second line with an error</pre>
    <p>
        So we know that the change for the commit we are &quot;paused&quot;
        on has been applied.
    </p>
    <p>
        If we look at the log, we also see our log message:
    </p>
    <pre>$ git log --oneline
466318b Second commit about something, with an error... oops
fca8f1a First commit about something</pre>
    <p>
        So, we can see Git has &quot;paused&quot; the rebase on this commit.
        Although the commit message is in the log, it hasn't actually &quot;gone
        through&quot; yet! We have this time to modify the file or the log
        message as we see fit.
    </p>
    <p>
        Let's edit the file to remove our error and change the second line
        from &quot;Second line with an error&quot; to just
        &quot;Second line&quot;. To do this you must <code>git add</code> the
        file and then do a <code>git commit --amend</code> as follows:
    </p>
    <pre>git add file.txt
git commit --amend</pre>
    <p>Git launches our text editor. In the editor we see our commit message
    which we can now change to just &quot;Second correct commit&quot; and save.
    </p>
    <p>
        Now you <b>must remember to do <code>git rebase --continue</code></b> to
        make the changes permanent.
    </p>
    <p>
        UH OH! We get a conflict:
    </p>
    <pre>First line
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Second line
=======
Second line with an error
Third line
&gt;&gt;&gt;&gt;&gt;&gt;&gt; de5fcb1... Third commit about something</pre>
    <p>Ah, the change we made conflicts with the change made in the final commit
    on our branch. At this point the rebase has again &quot;paused&quot;,
    but this time the branch is in the state it would be when the third commit
    had been done. But as we have seen, Git cannot replay this commit automatically
    for us because a conflict has been introduced.
    </p>
    <p>This is quite easy to fix. We just edit the file so it looks like this and
    save:</p>
    <pre>First line
Second line
Third line</pre>

    <p>Having resolved the conflict we need to <code>git add file.txt</code>,
    commit it and then
     <b>remember to run <code>git rebase --continue</code></b>.
    </p>
    <p>
        At this point we are told that our rebase has been successfull. If we cat
        our file we see the contents are as we have modified them to be and the log
        reflects this:
    </p>
    <pre>caeb871 Third commit about something
2867a5a Second CORRECT commit
fca8f1a First commit about something</pre>
    <p>
        You'll notice that the second and third commits now have diffent
        commit hashes. This is to be expected as the file contents have
        changed. Any files that we had been branched from any of the changed
        files, will be updated correctly to &quot;point&quot; back to the
        equivalent modified file.
    </p>

    <h3>Undoing A Rebase</h3>
    <p>
        So, here's a mistake I made doing a rebase to squash some commits on my branch. It's a nice example
        of using <code>git reset --hard</code> and <code>git reflog</code>. I had the following set of commits,
        which I've labeled #44 through #49. I wanted to keep commit #45 and squash #46 to #49:
    </p>
    <p>
        <img src="##IMG_DIR##/git_undo_squash_img1.png" alt="Image for part 1 of description of how to undo a git rebase where files were squashed"/>
    </p>
    <p>
        I.e., I wanted to end up with the following:
    </p>
    <p>
        <img src="##IMG_DIR##/git_undo_squash_img2.png" alt="Image for part 1 of description of how to undo a git rebase where files were squashed"/>
    </p>
    <p>
        But, I was a little careless with my rebase, and ended up with this:
    </p>
    <p>
        <img src="##IMG_DIR##/git_undo_squash_img3.png" alt="Image for part 1 of description of how to undo a git rebase where files were squashed"/>
    </p>
    <p>
        Instead of doing a <code>git rebase -i 4<b>5</b></code> I had done a <code>git rebase -i 4<b>4</b></code>, thus including commit 45 in my squash. As the figure above shows, HEAD now points to my newly created commit that squashes up commits 45 through 49. If I look at the log, I can no longer see individual commits 45 through 49. So, where have they gone and can I get them back?
    </p>
    <p>
        The answer is yes. As long as I have not executed a <code>git prune</code> command, the individual commit chain still exists and is shown above by the grayed out commit nodes. These nodes still exist in the Git repo, its just that there is no &quot;handle&quot; or &quot;named pointer&quot;, if you will, that we can use to refer to them by. So, how the, can we refer to them in order to tell Git that we want them back? Answer: <code>git reflog</code>.
    </p>
    <p>
        &quot;Reflog&quot; is short for &quot;reference log&quot; and it <q>records when the tips of branches were updated in the local repository</q> [<a href="https://git-scm.com/docs/git-reflog" target="_blank">Ref</a>]. Great, so this log should contain the history that describes when our branch HEAD moved from commit 49 to commit 45-49. This means we can do a hard reset to make both our working tree, index and HEAD pointer &quot;go back&quot; to commit 49 with all the commit history associated with it, as shown below.
    </p>
    <p>
        <img src="##IMG_DIR##/git_undo_squash_img4.png" alt="Image for part 1 of description of how to undo a git rebase where files were squashed"/>
    </p>
    <p>
        Now our repository looks exactly as it did before we started messing around with rebasing. From here I could continue to do the correct rebase... all is well. Phew!
    </p>

    <h3>Using Rebase To Edit A Commit</h3>
    <p>
    	Let's create a silly little repository:
    </p>
	<img src="##IMG_DIR##/git_rebase_to_edit_commit_1.png" alt="Depiction of a Git repository with 2 commits"/ style="float:right;">
    <pre>&gt; mkdir deleteme
&gt; cd deleteme
&gt; git init
&gt; echo "First commit line" &gt; test.txt
&gt; git add -A
&gt; git commit -m "First commit"
&gt; echo "First line of second" &gt;gt; test.txt
&gt; echo "Second line of second" &gt;gt; test.txt
&gt; git add -u
&gt; git commit -m "Second commit"
&gt; git log --oneline
5156c89 Second commit
e310460 First commit</pre>
	<p>
		Great, so we have two commits. The reflog looks like this:
	</p>
	<pre>&gt; git reflog
5156c89 HEAD@{0}: commit: Second commit
e310460 HEAD@{1}: commit (initial): First commit</pre>
	<p>
		So, when we made our first commit, HEAD was set to point to it. When we made our second commit, HEAD was
		moved to point to that. What we'd expect...
	</p>
	<p>
		Let's edit the second commit. We do this by starting a rebase from <code>e310460</code>.
	</p>
	<pre>git rebase -i e310460</pre>
	<p>The editor will pop up and allow us to change &quot;pick&quot; to &quot;edit&quot; for commit <code>5156c89</code>. When we save and exit the rebase starts:
	</p>
	<pre>&gt; git rebase -i e310460
warning: Stopped at 5156c89... Second commit</pre>
	<p>The reflog now looks like this:</p>
	<pre>&gt; git reflog
5156c89 HEAD@{0}: rebase -i: fast-forward
e310460 HEAD@{1}: rebase -i (start): checkout e310460
5156c89 HEAD@{2}: commit: Second commit
e310460 HEAD@{3}: commit (initial): First commit</pre>
	<p>The log looks like this:</p>
	<pre>&gt; git log --oneline
5156c89 Second commit
e310460 First commit</pre>
	<p>Okay, so we are now on the second commit. It appears in the log, but we are editing this commit. We can see what the rebase has tried to do by looking at the reflog, where we can see it intially checked out out the first commit

    <h3>Git Filter Branch</h3>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>
    <p>
    http://schacon.github.io/git/git-filter-branch.html
    </p>
    <p>
        Eek! This little fella lets you do a batch modification of many commits!
    </p>

    <h3>Cherry Picking</h3>
    <h4>Single Commit</h4>
    <p>
        When you want to take a single commit from one branch and apply it to
        another. Note, this is different from merging or rebasing because you
        are taking one specific commit and not a range of commits. Notice also
        that because this isn't a merge you will loose the ability to track
        where these changes came from as it will look like you just made these
        edits yourself!
    </p>
    <p>
        In essance, <code>git cherry-pick A</code> does this:
    </p>
    <ol>
        <li>Note change set between A and its parent.</li>
        <li>Apply change set to HEAD and commit result with A's commit message.</li>
    </ol>
    <pre>git checkout branch-to-apply-commit-to
git cherry-pick [-e] [-x] &lt;commit-ish&gt;</pre>
    <p>Note: this does the commit for you!</p>
    </p>
    <p>Use the <code>-e</code> flag to edit the commit message prior to
      comitting.</p>
    <p>The <code>-x</code> flag can be useful, because as said, you loose
        the ability to track where these changes came from: This flag
        will append a line that says &quot;(cherry picked from commit ...)&quot;
        to your commit message.</p>

    <h4>Range Of Commits</h4>
    <p>
        To cherry pick a range that is inclusive, i.e. [A, B] use the following
        <a href="https://www.tollmanz.com/git-cherry-pick-range/" target="_blank">[Ref]</a>:
    </p>
    <pre>git cherry-pick A^..B</pre>
    <p>
        The usual syntax does not include the oldest commit, so is (A,B]. This would be specified
        as:
    </p>
    <pre>git cherry-pick A..B</pre>

    <h4>Merge Commits</h4>
    <p>
        If a cherry-picked revision is a merge commit, then Git needs to know which parent to take
        the diff against to apply to HEAD.
    </p>
    <p>
        <img src="##IMG_DIR##/git-cherry-pick-merge-commit.png" alt="Git cherry-pick a merge commit"/>
    </p>
</div>

<h2>Hunting Down Bugs: Git Bisect</h2>
<div>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>
<p>TODO</p>
</div>

<h2>Patches</h2>
<div>
    <h3>Generating Patch Files</h3>
    <p>
        A patch file represents one single commit diff. Create using:
    </p>
    <pre>git format-patch (branch-name|since) -o dir_to_store_patches</pre>
    <p>
        This will create a set of files in the directory &quot;dir-to-store-patches&quot;
        with the following naming convention:
    </p>
    <pre>xxx-commit_msg.patch
^^^ ^^^^^^^^^^
^^^ The commit message for the commit that this patch represents
^^^ withs spaces replaced by underscores.
^^^
The commit number</pre>
    <p>
        If you substitute you branch name in the format-patch command line it will
        generate patches for every commit since the start of the branch.
    </p>
    <p>
        If you specifiy a commit number in the format-patch command line, instead of a branch name,
        you will get the patches for every single commit in the current branch since that commit.
    </p>

    <h3>Applying Patch Files</h3>
    <p>
        To apply a patch to the currently checked out branch use:
    </p>
    <pre>git am &lt; patch-file</pre>
    <p>
        This will create a new commit from the patch file.
    </p>
</div>

<h2>Git Tips and Tricks</h2>
<div>
    <p>Many thanks to my colleague Kris Dunning for these. I've added a few over time but he kicked it off...</p>

    <h3>Checking for white-space</h3>
    <p>To check for white-space alone:</p>
    <pre>git diff --check</pre>
    <p>To check for white-space and tabs in indents:</p>
    <pre>git -c core.whitespace=tab-in-indent diff --check</pre>

    <h3>Adding or Removing an Alias</h3>
    <p>This can be useful when you want to make a shorthand command for something
    you do frequently, or for long commands that are hard to remember.</p>
    <p>For instance, the white-space and tabs in indent check above can be reduced to:</p>
    <pre>git whitespace</pre>
    <p>By adding the alias:</p>
    <pre>git config --global alias.whitespace 'git -c core.whitespace=tab-in-indent diff --check'</pre>
    <p>To remove an alias use:</p>
    <pre>git config --global --unset alias.the-name-of-the-alias</pre>
    <p></p>

    <h3>Listing Available Aliases</h3>
    <pre>git config --get-regexp "^alias\."
git config --global alias.alias "config --get-regexp ^alias\." # Add an alias to check aliases :)
    </pre>

    <h3>Useful Aliases</h3>
    <b>Whitespace Check: &quot;git whitespace&quot;</b>
    <p>As above:</p>
    <pre>git config --global alias.whitespace 'git -c core.whitespace=tab-in-indent diff --check'</pre>
    <b>Status short cut: "git st"</b>
    <pre>git config --global alias.st status</pre>
    <b>Gitk Visualisation Window: &quot;git visual&quot;</b>
    <pre>git config --global alias.visual '!gitk --all HEAD &amp;'</pre>
    <b>Git log with graph: &quot;git lg&quot;</b>
    <pre>git config --global alias.lg &quot;log --graph --oneline --decorate&quot;</pre>
    <p>With colour <a href="https://coderwall.com/p/euwpig/a-better-git-log" target="_blank">[Ref]</a>...</p>
    <pre>git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot;</pre>

    <h3>Custom Commands</h3>
    <p>When an alias isn't goot enough you can create an executable script called <code>git-command-name</code> and put
    	it on your <code>PATH</code>. Then you can use the command <code>git command-name</code> to execute that script
    	<a href="thediscoblog.com/blog/2014/03/29/custom-git-commands-in-3-steps/" target="_blank">[Ref]</a>.
    <p>Note that on Windows, when using Git bash, changing the file's permissions to make it executable doesn't
        seem to work. Instead, make sure there is a <code>#!/bin/bash</code> at the start of the file, then it
        will be considered executable <a href="https://stackoverflow.com/a/25730108/1517244" target="_blank">[Ref]</a>.

    <h3>Get The Repo Root Directory</h3>
    <pre>git rev-parse --show-toplevel</pre>

    <h3>Logs</h3>
    <p>To see all the commits that have been for a specific branch that was branched off &quot;parent-branch-name&quot;:</p>
    <pre># From the branch that was branched from &quot;parent-branch-name&quot;
git log --no-merges parent-branch-name..
                                      ^^
                                      These 2 dots are important!</pre>
    <p>The flag <code>--no-merges</code> tells Git not to print commits
    with more than one parent and will make the log stop at the point the
    branch is merged back to the parent branch.</p>

    <h3>Get The Root Repository Directory</h3>
    <pre>git rev-parse --show-toplevel</pre>
    <p></p>

    <h3>Get The Branch Name For the Current Repository</h3>
    <pre>git rev-parse --abbrev-ref HEAD</pre>
    <p></p>

    <h3>Get The Last Commit ID</h3>
    <pre>git log --oneline -1 | cut -f1 -d" "</pre>
    <p></p>
</div>

<h2>Stashes</h2>
<div>
	<p>
		Useful reads <a href="https://stackoverflow.com/a/20412685/1517244" target="_blank">here</a> and
		<a href="https://stackoverflow.com/a/19003191/1517244" target="_blank">here</a> on SO.
	</p>
	<pre>https://stackoverflow.com/questions/1108853/recovering-added-file-after-doing-git-reset-hard-head/1109433#1109433
https://stackoverflow.com/questions/89332/how-to-recover-a-dropped-stash-in-git</pre>
    <p>
        Stashes are for when you don't want to commit your current work, want
        to get on with something else, but don't, obviously, want to loose the
        current work in progress.
    </p>
    <p>
        A stash is basically a <em>snapshot of your <b><u>un</u></b>committed
        changes</em>. This is different to a patch, which is a <em>snapshot of
        you committed changes</em>. Also, unlike a patch, you can not push a
        stash to a remote.
    </p>
    <p>
    	To stash uncommitted changes do <code>git stash save [stash-name]</code>. If you do not
    	supply the optional stash name it gets an auto generated one. Even with a stash name you
    	can only subsequently apply it using its index.
    </p>
    <p>
        <img src="##IMG_DIR##/git_stash.png" alt="Picture describing the Git stash processes/usage"/>
    </p>
    <p>
        Interestingly you can do more than one stash and then re-apply them
        seperately - the stash command creates a stack of stashes.
        Use <code>stash list</code> to see a list of stashes. To
        apply a specific stash use something like <code>git stash apply stash@{1}</code>,
        which would re-apply the penultimate stash (the smaller the number
        the more recent the stash).
    </p>
    <p>
    	It is better to <b>prefer <code>apply</code> over <code>pop</code></b>.
    	The reason for this is that <code>git stash apply</code> <b>leaves the
    	stash in-place</b>. So, if you did something wrong the stash still
    	exists. You can later, once you're happy, manually remove the stash using
    	<code>git stash drop</code>. If you use <code>git stash pop</code> to apply
    	your stashes it will apply the stash and automatically drop it, so if something
    	was wrong, you don't have the stash to fall back on!
    </p>
    <p>
        Although you can't push a stash to a remote, you can carry it over to
        another branch using <code>git stash branch-name</code>. This will
        switch you to &quot;branch-name&quot; and apply the stash to that
        branch. Sweet!
    </p>
</div>

<h2>Hooks</h2>
<div>
    <p>
        Hooks are actions that Git will automatically perform at perticular points. For example,
        a pre-commit hook, is an action that will be executed with you <code>git commit</code> some
        changes and will determine whether the commit should, in fact, be accepted or not.
    </p>

    <h3>Client Side Hooks</h3>
    <p>Look at the <code>.sample</code> files in the repo's &quot;hooks&quot;
    directory in the repo root. Rename a sample without the <code>.sample</code>
    extensions to &quot;activate&quot; it.</p>
    <p>Could use this as a way to auto-backup you git repo to a shared server,
    for example, or run pre-commit checks like syntax checking, linting etc.
    </p>
    <p>
        For example, in my repo dir under <code>.git/hooks</code> I see the following
        files:
    </p>
    <pre>-rwxr-xr-x 1 jh 1049089  478 Jul 28 10:27 applypatch-msg.sample*
-rwxr-xr-x 1 jh 1049089  896 Jul 28 10:27 commit-msg.sample*
-rwxr-xr-x 1 jh 1049089  189 Jul 28 10:27 post-update.sample*
-rwxr-xr-x 1 jh 1049089  424 Jul 28 10:27 pre-applypatch.sample*
-rwxr-xr-x 1 jh 1049089 1642 Jul 28 10:27 pre-commit.sample*
-rwxr-xr-x 1 jh 1049089 1348 Jul 28 10:27 pre-push.sample*
-rwxr-xr-x 1 jh 1049089 4951 Jul 28 10:27 pre-rebase.sample*
-rwxr-xr-x 1 jh 1049089  544 Jul 28 10:27 pre-receive.sample*
-rwxr-xr-x 1 jh 1049089 1239 Jul 28 10:27 prepare-commit-msg.sample*
-rwxr-xr-x 1 jh 1049089 3610 Jul 28 10:27 update.sample*</pre>
    <p>
        If we look at <code>pre-commit.sample</code> we can read that
        it is <q>an example hook script to verify what is about to be
        comitted</q>. We could, if we wanted to, run a linting tool or
        style checked from this script and deny the commit if it didn't meet
        our coding standards.
    </p>

    <h4>Pre-Commit Hooks</h4>
    <p>
    	This hook can be super useful - eg auto-run a sanity checker like a linter or make sure the
    	commit message is formatted correctly etc.
    </p>
    <p>
    	If you want to <i>skip</i> any pre-commit tests you implement use <code>--no-verify</code>.
    </p>
    <p>
    	For example my (sanitised-for-public-web-page) pre-commit hook looks like this:
    </p>
    <pre class="prettyprint linenums">##
## Use Git boiler plate from sample pre-commit hook to figure out what to diff against
if git rev-parse --verify HEAD >/dev/null 2>&1
then
   against=HEAD
else
   against=$(git hash-object -t tree /dev/null) # Initial commit: diff against an empty tree object
fi

##
## Check all the changed files that have not been deleted for things...
changed_files=$(git diff --name-only "$against")
for file in $changed_files
do
   if [ -e "$file" ] # Cope with deleted files - obv must not check these...
   then
      if ! python my-script-name.py
      then
         echo -e "###\n### Could not do stuff \"$file\" has some kind of error \n###"
         exit 1
      fi
   fi
done</pre>

</div>

<h2>Adding Git Branch To Linux Prompt</h2>
<div>
<p>
    See <a href="linux_script.html#Adding-Current-Git-Or-Svn-Branch-To-The-Linux-Prompt">this section of the Linux shell page</a>.
</p>
</div>

<h2>Dealing With Conflicts</h2>
<div>
    <p>REF: http://tedfelix.com/software/git-conflict-resolution.html</p>
    <pre>##  Note that this is backwards from what you might expect,
## "theirs" is the one we are currently on!!
##
## From the man page:
##
## Note that during git rebase and git pull --rebase, ours and theirs may appear swapped;
## --ours gives the version from the branch the changes are rebased onto, while --theirs
## gives the version from the branch that holds your work that is being rebased.
##
## This is because rebase is used in a workflow that treats the history at the remote as
## the shared canonical one, and treats the work done on the branch you are rebasing as the
## third-party work to be integrated, and you are temporarily assuming the role of the keeper
## of the canonical history during the rebase. As the keeper of the canonical history, you
## need to view the history from the remote as ours (i.e. "our shared canonical history"),
## while what you did on your side branch as theirs (i.e. "one contributor’s work on top of it").

git checkout --(theirs|ours) mergetool.txt</pre>
</div>

<h2>When Git Auto-Complete Shows Deleted Branches</h2>
<div>
    <p>
        Found the answer on <a href="https://stackoverflow.com/questions/17933401/how-do-i-remove-deleted-branch-names-from-autocomplete" target="_blank">this SO thread</a>.
    </p>
    <p>
        If, when using Git auto-complete, Git displays branches that you have deleted
        it is likely that they are remote branches, i.e., origin/xxx. Use <code>git branch -a</code>
        to see if they exist. To get rid of ones that have been deleted on the
        remote use <code>git fetch --prune origin</code>.
    </p>
</div>

<h2>Git and Line Endings</h2>
<div>
<pre>https://help.github.com/articles/dealing-with-line-endings/
https://adaptivepatchwork.com/2012/03/01/mind-the-end-of-your-line/ ## << Really good!</pre>
</div>

<h2>Submodules</h2>
<div>
    <p>References:</p>
    <ul>
        <li><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank">The official &quot;Git Tools - Submodules&quot;</a>.</li>
        <li><a href="http://www.speirs.org/blog/2009/5/11/understanding-git-submodules.html" target="_blank">Understanding Git Submodules</a>, Fraser Speirs.</li>
        <li><a href="https://www.atlassian.com/git/tutorials/git-submodule" target="_blank">Git Submodules</a>, Atlassian</li>
        <li><a href="https://www.atlassian.com/blog/git/git-submodules-workflows-tips" target="_blank">Git submodules: core concept, workflows, and tips, Nicola Paolucci</a></li>
    </ul>
    <p>
        The Git docs say the following:
    </p>
    <blockquote>
        <p>Submodules allow you to keep a Git repository as a subdirectory of another Git repository.
            This lets you clone another repository into your project and keep your commits separate.
        </p>
        <footer><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank">-- Git SCM</a></footer>
    </blockquote>
    <p>
        However...
    </p>
    <blockquote>
        <p>Git submodules are locked to a specific revision and don't automatically track the external project's HEAD.</p>
        <footer>--<a href="http://www.speirs.org/blog/2009/5/11/understanding-git-submodules.html" target="_blank">Understanding Git Submodules</a>, Fraser Speirs.</footer>
    </blockquote>
    <p>
        The Atliassian page on the subject says it nicely:
    </p>
    <blockquote>
        <p>
            Git submodules allow you to keep a git repository as a subdirectory of another git
            repository. Git submodules are simply a reference to another repository at a particular
            snapshot in time. ...
        </p>
        <p>
            ... A git submodule is a record within a host git repository that points to a specific
            commit in another external repository. Submodules are very static and only track
            specific commits. Submodules do not track git refs or branches and are not automatically
            updated when the host repository is updated ...
        </p>
        <footer>-- <a href="https://www.atlassian.com/git/tutorials/git-submodule" target="_blank">Git Submodules</a>, Atlassian Tutorials
        </footer>
    </blockquote>
    <p></p>

    <h3>Add A Git Submodule To Your Project</h3>
    <p>
        From directory in your project into which you want to add the submodule:
    </p>
    <pre class="prettyprint linenums">
git submodule add [-b BRANCH_NAME] GIT-URL</pre>
    <p>
        This adds the file <code>.gitmodules</code> and <code>your-submodule-name</code> into your
        repo. Note that the new directory is <i>seen as a file</i> by Git, even though on your local
        machine it is realy a directory. Commit your changes to add these two files.
    </p>
    <p>
        To track a specific branch use the <code>-b</code> option.
    </p>
    <p>
        Or, to retrospecitively track a different branch, edit the <code>.gitmodules</code> file
        in your repository base directory and add a branch key like so:
    </p>
    <pre class="prettyprint linenums">[submodule my-sub-module"]
    path = path/relative/to/repo/base/where/submodule/is/cloned
    url = https://git@bitbucket.org/my.repository.git
    branch = my/branch</pre>
    <p>
        Or, probably better, use:
    </p>
    <pre class="prettyprint linenums">git config -f .gitmodules submodule.my-sub-module.branch branch-name</pre>

    <h3>Clone a Git Project With Submodules</h3>
    <p>
        To clone a project with submodules do:
    </p>
    <pre>git clone https://the-project
git submodule init   # You only get submodule directories but not code so run
git submodule update [--recursive] [--remote] # these to get the data!</pre>
    <p>Or...</p>
    <pre>git clone <b>--recurse-submodules</b> https://the-project</pre>
    <p>As the submodule is a repository-in-a-repository you can check out any branch of the
    submodule independently of the branch of you main repository that is checked out.</p>
    <p>
        To merge or rebase in remote changes to the submodule do:
    </p>
    <pre>git submodule update --remote (--merge|--rebase)</pre>
    <p>
        When pushing from a repository with submodules be sure to use:
    </p>
    <pre>git push --recurse-submodules=check # Or...
git push --recurse-submodules=on-demand</pre>
    <h3>Working On Git Submodules</h3>
    <p>
        To checkout a branch or revision of the submodules:
    </p>
    <pre class="prettyprint linenums">
cd you-submodule-directory
git checkout [-b] some-branch
#            ^^^^
#            Only if you are creating a new branch, rather than checking out an existing one.

# ... make some changes ...

git add -u
git commit -m "..."

cd submodule-parent-directory
git add -u
git commit -m "updated the submodule reference"</pre>
<p>
    If you have checked out a repo and want to recursively update the submodules:
</p>
<pre style="prettyprint linenums">git submodule update --init --recursive</pre>
<p></p>
</div>

<h2>Super Error Recovery</h2>
<div>
	<p>If you have deleted something you shouldn't have or even lost a stash, <a href="https://stackoverflow.com/a/5879550/1517244" target="_blank">this SO thread</a> has the answers!
		This beauty let me recover a stash that I had popped (note: should always prefer apply!) and then reverted - wow :)
	</p>
	<p>I have replicated the answer here with a little scripting added around it:</p>
	<pre>while read filename
do
    echo -e "\n#########################################################\n$filename\n";
    git cat-file -p $filename; 
done <<< $(find .git/objects -newermt $(date +%Y-%m-%d -d '4 hours ago') \
                -type f -exec ls -hal {} \; |
           cut -d" " -f 9 |
           sed -e 's/.git\/objects\///g' |
           sed -e 's/\///g') > out.txt</pre>
     <p>
     	Then you can edit the file <code>out.txt</code> to possibly find what you lost :D
     </p>
</div>

<h2>Remotes</h2>
<div>
    <h3>Push To Remote With Different Name</h3>
    <pre>git push origin local-name:remote-name</pre>

    <h3>Syncing GitHub Forks</h3>
    <p>
        Read <a href="https://help.github.com/articles/syncing-a-fork/#platform-linux" target="_blank">the docs</a>!
    </p>
    <pre class="prettyprint linenums">git remote add upstream https://github.com/ORIG_OWNER/ORIG_REPO.git # Specify a new remote upstream repository that will be synced with the fork.
git fetch upstream        # Get the upstream fork
git checkout master       # Checkout the branch you want to merge the upstream into
git merge upstream/master # Merge locally
git push                  # Push back to your remote</pre>
    <p></p>
</div>

<h2>Git Large File Systems (Git LFS)</h2>
<div>
	<p>
		Ref: <a href="https://git-lfs.github.com/" target="_blank">https://git-lfs.github.com/</a>: <q>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server...</q>.
	</p>
    <p>
        Git LFS can store large files as &quot;pointers&quot; to separate binary storage in your repo. The repo can thus
        be smaller.
    </p>
	<p>
		In your repository directory, to start using LFS type:
	</p>
	<pre>git lfs install</pre>
	<p>
		To get the large objects associated with the repo type:
	</p>
	<pre>git lfs pull</pre>
	<p>
		For general help:
	</p>
	<pre>git lfs help</pre>
    <p></p>

    <h3>Encountered X file(s) that should have been pointers, but weren't:</h3>
    <p>
        Bah! Encountered this on occasion. This can happen when you do a checkout that contains
        files which should have been been tracked by LFS as specified in .gitattributes but somehow
        they've been committed directly instead! Or there is, in fact, a genuine conflict where
        on one branch the file is raw binary and on another it is Git LFS managed.
    </p>
    <p>
        See the Git LFS status:
    </p>
    <pre>git lfs status</pre>
    <p>
        List the files that are under LFS control:
    </p>
    <pre>git lfs ls-files</pre>
    <p>
        See the files that match the LFS filters:
    </p>
    <pre>git ls-files ':(attr:filter=lfs)'</pre>
    <p>
        Another way to programmatically test if a file is managed by LFS
        <a href="https://github.com/git-lfs/git-lfs/issues/2748" target="_blank">[Ref]</a> is to
        compare the file size of the file on disk with the block size in Git. The Git blob size
        should be about 130 bytes and the file on disk should be significantly bigger:
    </p>
    <pre>git ls-tree HEAD -rl | grep some-file-name-pattern</pre>
    <p>
        The following can also help <a href="https://stackoverflow.com/a/54804224/1517244" target="_bank">[Ref]</a>:
    </p>
    <pre>git lfs uninstall
git reset --hard
git lfs install
git lfs pull</pre>
    <p>And if that doesn't work you can try:</p>
    <pre>git rm --cached -r .
git reset --hard
git rm .gitattributes
git reset .
git checkout .</pre>
    <p>It is also possible to migrate files to LFS <a href="https://stackoverflow.com/a/57820265/1517244" target="_bank">[Ref]</a>:</p>
    <pre>git lfs migrate import --no-rewrite "broken file.jpg" "another broken file.png" ...
# This "migrates" files to git lfs which should be in lfs as per .gitattributes, but aren't
# at the moment (which is the reason for your error message).
#
# --no-rewrite prevents git from applying this to older commits, it creates a single new
# commit instead.</pre>
    <p></p>


</div>

</div> <!-- END H1 Git Notes -->
</div>
</body>
</html>

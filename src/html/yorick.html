<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
	<title>Yorick notes</title>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']]
			},
			displayAlign: "left",
			displayIndent: "2em"
		});
	</script>
	<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
	<style>
		ul li .MathJax {font-size: 3em;}
	</style>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<!-- TITLE ------------------------------------------------------------- -->
<h1 class="title">Yorick Notes</h1>
<div style="padding-right:10px;">
	<p>
		<a href="http://dhmunro.github.io/yorick-doc/" target="_blank">Yorick</a>, written by 
		<a target="_blank" href="http://en.wikipedia.org/wiki/David_H._Munro">David Munro</a>, &quot;...is an interpreted 
			programming language for scientific simulations or calculations, postprocessing or steering large 
			simulation codes, interactive scientific graphics, and reading, writing, or translating large files of numbers...&quot; 
	</p>

	<!-- PAGE CONTENTS ----------------------------------------------------- -->
	<h2>Page Contents</h2>
	<div id="page_contents">
	</div>

	<!-- INSTALL YORICK ON UBUNTU ------------------------------------------ -->
	<h2>Easy Yorick Install On Ubuntu</h2>
	<div>
		<p>
			Really very very easy. Just do <tt>sudo apt-get install yorick</tt>! If you want to develop
			your own Yorick plugins then your will also need to do a <tt>sudo apt-get install yorick-dev</tt>.
		</p>
		<pre class="prettyprint linenums">apt-get install yorick yorick-dbg yorick-dev</pre>
	</div>

	<!-- GET Y_HOME -------------------------------------------------------- -->
	<h2>Get Yorick Home Path, Y_HOME</h2>
	<div>
		<p>
			For some of my little make jobs I want to be able to compile Yorick on two targets.
			On one target it is built from scratch so Yorick lives in one directory but on my
			Linux box it lives under <tt>/usr/bin</tt> and <tt>/usr/lib</tt>. Really the <tt>/usr/bin/yorick</tt>
			binary just points to <tt>/usr/lib/yorick/bin/yorick</tt> as Yorick tends to live under the one
			installation directory.
		</p>
		<p>
			Usually to generate a plugin Makefile you'd just type...
		<pre class="prettyprint linenums">yorick -batch make.i</pre>
		<p>... and get an auto generated Makefile with variables pointing to your Yorick installation written into
			the Makefile for you. For example, on my Ubuntu atp-getted installation I get the following.
		</p>
		<pre class="prettyprint linenums"># these values filled in by &quot;yorick -batch make.i&quot;
Y_MAKEDIR=/usr/lib/yorick
Y_EXE=/usr/lib/yorick/bin/yorick
Y_EXE_PKGS=
Y_EXE_HOME=/usr/lib/yorick
Y_EXE_SITE=/usr/lib/yorick
Y_HOME_PKG=</pre>
		<p>
			One way to get the Yorick installation directory for a system that is
			independent of the particular Yorick installation is as follows. 
		</p>
			<pre class="prettyprint linenums">YORICK_HOME="$(echo "print, Y_HOME" | yorick | grep '^".*yorick' | sed -e 's/"//g' | tr -d '\r' | sed -r 's/\/ *$//g')"
echo $YORICK_HOME</pre>
		<p>
			You can then substitute <tt>YORICK_HOME</tt> into the auto-generated Makefile so that
			it should work regardless who has the plugin and where their particular Yorick
			is installed (it might not be <tt>/usr/lib/yorick</tt> if they have installed in manually,
			for example).
		</p>
	</div>

	<!-- YORICK ARRAYS ----------------------------------------------------- -->
	<h2>Yorick Arrays</h2>
	<div>
		<h3>Versus C Arrays</h3>
		<p>The major differences are</p>
		<ol>
			<li>Yorick arrays start at index <tt>1</tt> but C arrays start at index <tt>0</tt>.
			<li>Yorick arrays are column-major whereas C arrays are row-major. This means that <tt>array[1][2]</tt> in C addresses row 1, 
			column 2, but in Yorick (adjust syntax to <tt>array(1,2)</tt>) it addresses column 1, row 2 (in C column 0, row 1 taking 
			into account the start index of <tt>1</tt> instead of <tt>0</tt>.</li>
		</ol>
		<p>
			<div class="box_container"><div class="info">
				<p>
					Yorick arrays are column major and indicies start at 1.
				</p>
			</div></div>
		</p>
		<h4>Row/Column Major</h4>
		<p>
			For all languages, arrays are are contigous blocks of items. Therefore, in memory we can 
			store a 1D arrays as follows:
		</p>
		<pre>| ITEM[0] | ITEM[1] | ITEM[2] |  ...  | ITEM[N]
|         |         |         |       |
0 *sz     |         |         |       |
          1 *sz     |         |       |
                    2 *sz     |       |
                              3 * sz  :
                                      |
                                      N * sz</pre>
		<p>
			Here we store the first array element at the lowest memory address and increment upwards. 
			You can see that each element is contiguous in memory. It is worth noting that the
			array is contiguous in terms of the language's model of the memory. For systems with
			an MMU this means virtual memory (which if the array crosses a page boundary
		</p><p>
			What happens when we try to store a 2D array? Consider the following array:
		</p><pre>int someArray[2][3] = { { 1, 2, 3},
                        { 4, 5, 6} }</pre>
		<p>
			This is something we're very used to in C. We read this as an array with 2 rows and 3 columns.
			But how is this laid out in memory? It still has to be a contiguous chunk of memory but now there
			are two layout options. The C way is to lay out the array as follows:
		</p><pre>| ITEM[0][0] | ITEM[0][1] | ITEM[0][2] | ITEM[1][0] | ITEM[1][1] | ...
|            |            |            |     ^^^    |          
0 *sz        |            |            | Note: new  |
             1 *sz        |            | row starts |
                          2 *sz        |            |
                                       3* sz        |
                                                    |
                                                    4 * sz</pre>
		<p>
			The array items are represented as a contiguous flow of values. The first row is laid out as it
			was for the 1D array, then the second row is appended to this block as if it were a 1D array
			and so on. Each row, therefore, starts at address <tt>row_index*3</tt>.
		</p><p>
			The C syntax specifies the fastest increasing index in memory from right to left. What does
			&quot;fastest&quot; mean? I'm using Munro speak here, and what he means is that, if we looked
			at the above memory layout, as we move one position from left to right the first dimension
			to increase is the &quot;fastest&quot;, so in the C sense this is column. 
		</p>
		<p>
			Another way to think about this is considering
			an <tt>int p* = someArray</tt> pointer. As we increment this pointer by one (<tt>p++</tt>) it will traverse the columns in a row,
			which is what Munro calls the fastest increasing dimension, and then once all the columns in one row
			are iterated over it will move to the columns in the next row (so therefore the row is the second
			fastest increasing dimension) and so on.
		</p>
		<p>
			We can see 
			this in the above definition, <tt>int [2][3]</tt>, where the right most dimension is <tt>[3]</tt> 
			and represents the fastest increasing dimension in memory. The next dimension to the left is 
			<tt>[2]</tt> and is the second fastest increasing dimension: rows.
		</p><p>
			This method of thinking about an array can be used for any number of dimensions. Consider <tt>int anotherArray[2][3][4][5]</tt>.
			We know that the fastest increasing dimension is <tt>5</tt>, so if <tt>int *p = anotherArray</tt> then...
		</p>
		<ul><li><tt>*p &nbsp;&nbsp;&nbsp;&nbsp;== anotherArray[0][0][0][0]</tt></li>
			 <li><tt>*(p+<b>1</b>) == anotherArray[0][0][0][<u>1</u>]</tt></li>
			 <li><tt>...</tt></li>
			 <li><tt>*(p+<b>4</b>) == anotherArray[0][0][0][<u>4</u>]</tt></li>
		</ul>
		</p><p>
			We also know that:
		</p>
		<ul>
			<li><tt>*(p+<b>a*5</b>)&nbsp;&nbsp;&nbsp;&nbsp; == anotherArray[0][0][<u>a</u>][0]</tt></li>
			<li><tt>*(p+<b>b*4*5</b>) &nbsp; == anotherArray[0][<u>b</u>][0][0]</tt></li>
			<li><tt>*(p+<b>c*3*4*5</b>) == anotherArray[<u>c</u>][0][0][0]</tt></li>
		</ul>
		<p>
			So when we say <em>row-major</em>, we mean that, in terms of the syntax, the right most index is the
			<em>fastest incrementing dimension</em> and going left the speed of increment decreases.
		</p>
		<p>
			<em>Column-major</em> therefore means, that, again in terms of the syntax, the right most index is the
			<em>slowest incrementing dimensions</em> and going left the speed of increment increases.
		</p><p>
			I keep saying &quot;in terms of syntax&quot; because as Yorick is implemented in C its physical array
			storage is C-like. It is only in the scripting language itself that column-major notation is used.
		</p>
	
		<h4>In C</h4>
		<p>Consider the following C program:</p>
		<pre>#include <stdio.h>
int main(void) {           +-+-+-&gt; along the right most [] (depth)
                           | | |
   int b[2][2][3] = { +&gt;{ {1,2,3}, &lt;+| 
                      |   {4,5,6}  &lt;+| second most [col]
                      | },
                      +&gt;{ {11,22,33},
                      |   {44,55,66}  
                      | } };
                      +- outer most (row)

	int i = 0, j = 0, k = 0;
	for(i = 0; i &lt; 2; ++i ) 
		for(j = 0; j &lt; 2; ++j) for(k = 0; k &lt; 3; ++k)
			printf("b[%i][%i][%i] == %i\n", i, j, k, b[i][j][k]);</pre>
		<p>
			It outputs the following...
		</p>
		<pre>b[0][0][0] == 1	b[1][0][0] == 11
b[0][0][1] == 2	b[1][0][1] == 22
b[0][0][2] == 3	b[1][0][2] == 33
b[0][1][0] == 4	b[1][1][0] == 44
b[0][1][1] == 5	b[1][1][1] == 55
b[0][1][2] == 6	b[1][1][2] == 66</pre>
		<p>
			Have to visualise the inner brace as being your <em>least</em> dimension. So 
			in the 3D case the inner brace gives you the 3rd, axis, depth or really z. The next
			outer brace gives you the next least axis, in this case column. So you are getting 
			columns of the inner axis. Scale up then to rows. The cube therefore looks like:
		</p>
		<pre>
           3------6
          /      /| 
         2------5 |
        /  33--/--66           [r][c][d]
       1------4  /             Its basically a matter of definition of
 |     | 22---|-55   _ d       what row,col,depth means in terms of
 |     |/     |/     /|        the C array layout. Must structure numbers
 |     11     44    /          in array appropriately if we defined [r][c][d]
 \/                /           as opposed to say, [d][r][c] or any
 r -------------&gt; c            other combination
		</pre>
		<p>
			Basically in C world we work from the outer brace inwards so the right-most index is 
			our least significant dimension and the left-most index is our most significant dimension 
			(in this case row)
		</p>
		<h4>In Yorick</h4>
		<pre>
                   +-+-+-&gt; along the right most [] (depth)
                   | | |
&gt; b =     [ +&gt; [  [1,2,3], &lt;+| 
            |     [4,5,6]  &lt;+|second most [col]
            |  ],
            +&gt; [  [11,22,33],
            |     [44,55,66]  ]
            |  ];
            +- outer most (row)

&gt; dimsof(b)
[3,3,2,2]

   h  c  r
"b[1][1][1] == 1"            3------6
"b[1][1][2] == 11"          /      /| 
"b[1][2][1] == 4"          2------5 |
"b[1][2][2] == 44"        /  33--/--66           [r][c][d]
"b[2][1][1] == 2"        1------4  /             Its basically a matter of definition of
"b[2][1][2] == 22" |     | 22---|-55   _ d       what row,col,depth means in terms of
"b[2][2][1] == 5"  |     |/     |/     /|        the Yor array layout. Must struct nums
"b[3][1][1] == 3"  |     11     44    /          in array appropriately if def (d,c,r)
"b[3][1][2] == 33" \/                /           as opposed to say, (r,c,d) in C or any
"b[3][2][1] == 6"  r -------------&gt; c            other combination
"b[3][2][2] == 66"  </pre>
		<p>
			Basically in Yorick world we work from the inner brace outwards so the left-most 
			index is our least significant dimension and the right-most index is our most significant 
			dimension (in this case row)
		</p>

		<h3>Slices Are Views Onto Arrays But Beware Of Array Copy</h3>
		<div>
			<p>
				In NumPy slices are like views into the array, and this
				is also the case in Yorick. BUT... if we transliterate the 
				<a href="python/numpy.html#numpy_slice">NumPy example</a> into Yorick 
				script, we will see a different result! See below:
			</p>
			<pre class="prettyprint linenums">&gt; a = [1,2,3,4,5,6]
&gt; b = a(2:4)
&gt; b
[2,3,4]
&gt; b(:) = 111
&gt; b
[111,111,111]
&gt; a /*&lt;-- LOOK: Unlike the NumPy example, a has not been affected! */
[1,2,3,4,5,6]</pre>
			<p>
				In the NumPy example a would have been effected. Now, it's not quite
				that the slice isn't a view. It still is. Observe the following.
			</p>
			<pre class="prettyprint linenums">&gt; a(2:4) = 111
&gt; a
[1,111,111,111,5,6] /*&lt; Aha! the slice is a view into the array */</pre>
			<p>
				So, the slice is in fact a view into the array. The caveat is that
				in Yorick when we did <tt>b = a(...whatever...)</tt>, <tt>b</tt>
				will be a <em>copy of</em> and not a reference to the array (slice).
				This can be quite an expensive operation so beware!
			</p>
			<p>
				<div class="box_container"><div class="info">
					<p>
						In NumPy assigning one array (or non primative) variable to 
						another copies a <em>reference</em> and not the value. In
						Yorick however, in the specific case of array = array, the
						<em>entire array is copied</em>... Beware of this as for 
						large arrays this can get expensive!
					</p>
				</div></div>
			</p>
			<p>
				The Yorick manual entry for 
				<a href="http://dhmunro.github.io/yorick-doc/stdlib/std-advanced.html#eq_nocopy" target="_blank">
				eq_nocopy()</a> says that <q>having multiple variables
				reference the same data can be confusing, which is why the default
				&quot;<tt>=</tt>&quot; operation copies the array.</q>
			</p>
			<p>
				To copy an an array <em>by reference</em> use 
				<a href="http://dhmunro.github.io/yorick-doc/stdlib/std-advanced.html#eq_nocopy" target="_blank">
				eq_nocopy()</a>. Note, however, that you can only do this for the 
				entire array, not slices. Munro <a href="https://github.com/dhmunro/yorick/issues/16" target="_blank">
				explains this here</a>: <q>...Unlike NumPy, Yorick does not have any way to refer to
				a slice of an object. All slicing operations happen immediately and result in a 
				temporary array...</q>.
			</p>
			<p>
				<div class="box_container"><div class="info">
					<p>
						All slicing operations happen immediately and result in a temporary
						array (i.e., a <em>copy-by-value</em>).
					</p>
				</div></div>
			</p>

		</div> <!-- END H3: Slices Are Not Like NumPy Slices -->

		<h3>When Arrays Are Not Copied By Value</h3>
		<div>

	
			<h4>Arrays Passed To Functions By Reference</h4>
			<div>
				<p>
					Arrays are passed to functions by reference in the sense that if you modify the array in
					the function, the caller's array is modified...
				</p>
				<pre class="prettyprint linenums">&gt; y = [1,2,3,4]
&gt; func cheeseit(x) {
    x(1) = 9999 /*&lt;-- NOTE: Will change array in caller's scope */
  }
&gt; cheeseit(y)
&gt; y /*&lt;-- NOTE: y has been changed by function */
[9999,2,3,4]</pre>
				<p>
					For a pass-by-copy kind of semantic, do the following, but note copying an array will
					be expensive if this is a large array!
				</p>
				<pre class="prettyprint linenums">&gt; y = [1,2,3,4]
&gt; func cheeseit(x) {
    x_local = x;       /*&lt;-- x is <em>copied</em> to x_local, but copy is <em>EXPENSIVE</em>! */
    x_local(1) = 9999; /*&lt;-- Changes to x_local will NOT affect array in caller's scope */
}
&gt; cheeseit(y)
&gt; y /*&lt;-- NOTE: y is NOT changed by the function */
[1,2,3,4]</pre>
			</div> <!-- END H4: Arrays Passed To Functions By Reference -->

			<h4>OXY Objects Store References</h4>
			<div>
				<p>
					Above we just saw that when copying an entire array, or a slice
					of an array, the copy is done by value and not by reference. There
					is a caveat however... when assigning an array belonging to an OXY
					object to another OXY object, a reference to the array is copied.
					The array is <em>not</em> copied by value in this instance!
				</p>
				<pre class="prettyprint linenums">&gt; a = save(q=[1,2,3,4])
&gt; b = save(q=a.q) /* b's copy of a.q is a reference to a.q. unlike bare
&gt; a.q              * array-to-array copy, which is by value, this copy is
[1,2,3,4]         * by reference! */
&gt; b.q
[1,2,3,4]
&gt; a.q(1)=999
&gt; a.q
[999,2,3,4]
&gt; b.q
[999,2,3,4]          /* LOOK! b.q must be a <em>reference</em> to a.q! */</pre>
				<p>
					This is not just true of copying OXY members between objects.
					If <tt>a.q</tt> is replaced by a vanilla array (just normal
					variable and not an OXY object), the result is the same!
				</p>
			</div> <!-- H4: OY Objects -->
		</div> <!-- END H3: When Arrays Are Not Copied By Value (OXY Objects) -->


		<a name="broadcasting"><h3>Broadcasting</h3></a>
		<p>
			Yorick, being a nicely vectorised language, lets you do mathematical 
			operations between scalars and arrays, and arrays and arrays. The only
			condition is that the arrays are what is called <em>&quot;conformable&quot;</em>.
		</p>
			Two operands are conformable if the dimensions which they share in 
			common have the same length. This means that if we have two operands,
			<tt>A</tt> and <tt>B</tt>, where <tt>A</tt> has the smaller rank,
			that <tt>dimsof(A)(2:) == dimsof(B)(-dimsof(A)(1)+1:)</tt>. Eek! That's
			a little horrid right?! It just expresses that the dimensions shared in
			common have the same length.
		</p>
		<p>
			Try thinking of it this way: if you can create the array <tt>B</tt> by
			joining together a load of <tt>A</tt> arrays then they will be
			conformable because the dimensions they share in common must be of
			equal length as <tt>B</tt> is just made up of many <tt>A</tt>'s.
			The image below is meant to make that a little more clear...
		</p>
		<p>
			<img src="##IMG_DIR##/yorick_broadcast.png" alt="Image showing how arrays of shorter dimensions can broadcast to arrays of larger dimensions in Yorick"/>
		</p>
		<p>
			The image is trying to show that, as the manual says, the shorter 
			operand repeats its values for every dimension that is does not have.
			This is what is called <em>broadcasting</em>.
		</p>
		<p>
			As a little side note, it appears that Yorick actually created the 
			term broadcasting, to the extent that it 
			<a href="http://stackoverflow.com/questions/26948776/where-did-the-term-broadcasting-come-from/26950256#26950256" target="_blank">
			inspired Python's NumPy broadcasting</a>... wowzers!
		</p>
		<p>
			We can see that because, for example, the 2D array is made up of
			two 1D arrays, the 1D array can be multiplied, added, etc with the
			2D array by &quot;expanding&quot; into a 2D array by repeating 
			itself in the second dimension so that it has the same shape. The
			same goes for 1D <tt>op</tt> 3D or 2D <tt>op</tt> 3D in the above 
			example. 
		</p>
		<p>
			Let's see this in practice...
		</p>
		<pre class="prettyprint linenums"> Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; a = [1,2]
&gt; b = [a,a]
&gt; c = [b,b,b]
&gt; a
[1,2]
&gt; b
[[1,2],[1,2]]
&gt; c
[[[1,2],[1,2]],[[1,2],[1,2]],[[1,2],[1,2]]]
&gt;
&gt; a+b 
[[2,4],[2,4]]
&gt;
&gt; a+c
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]
&gt; c+a
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]
&gt;
&gt; b+c
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]
&gt; c+b
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]</pre>
		<p>
			As per our little image above... the arrays are conformable and so
			can be operands to the normal mathematical operations. BUT... the above 
			does not give the whole story. &quot;In common&quot; can be more 
			flexible. For example, we can do the following...
		</p>
		<pre class="prettyprint linenums">&gt; aa = [1]
&gt;
&gt; dimsof(aa)
[1,1]
&gt; dimsof(b)
[2,2,2]
&gt;
&gt; aa + b
[[2,3],[2,3]]
&gt; aa + c
[[[2,3],[2,3]],[[2,3],[2,3]],[[2,3],[2,3]]]
&gt; bb = [[1], [1]]
&gt; bb+c
[[[2,3],[2,3]],[[2,3],[2,3]],[[2,3],[2,3]]]
		</pre>
		<p>
			Now, given the above definition, one might thing that the common 
			dimension between <tt>aa</tt> and <tt>b</tt> does not have the same
			lenth, yet they are clearly conformable as far as the Yorick 
			interpretter is concerned. What's going on?
		</p>
		<p>
			The reason that this works is that <q>Yorick will broadcast any 
			unit-length dimension in addition to a missing final dimension</q>.
		</p>
		<p>
			Therefore, pictorially, we can see the following...
		</p>
		<p>
			<img src="##IMG_DIR##/yorick_boardcast_unit_dim.png" alt="Image showing how Yorick can conform unit-length dimensions"/>
		</p>
		<p>
			So far we seem to have the following definition... 
			<div class="box_container"><div class="info">
				<p>
					Yorick operands are conformable if the dimensions they share in
					common have exactly the same length or the shared dimensions in the &quot;smaller&quot;
					operand that are not the same length as in the other are unit length.
				</p>
			</div></div>
		</p>
		<p>
			One does have to take a little care in what is understood by 
			&quot;dimensions in common&quot;, however. This might appear obvious
			to you, but I had to do a double take...
		</p>
		<pre class="prettyprint linenums">&gt; a = [1,2]
&gt; dimsof(a)
[1,2]
&gt; b = [[7,8,9,0],[6,5,4,3]]
&gt; dimsof(b)
[2,4,2]
&gt; a+b
ERROR (*main*) operands not conformable in binary +
WARNING source code unavailable (try dbdis function)</pre>
		<p> 
			If we look at the dimensions with the following formatting we might
			be fooled into thinking that <tt>a</tt> and <tt>b</tt> share a
			common dimension of exactly the same length, and therefore should
			be conformable.
		</p>
		<pre>
/* Caution: This is an INcorrect grouping of the dimsof result */
                +++
dim_a =    [ 1, |2| ]
dim_b = [ 2, 4, |2| ]
                +++</pre>
		<p>
			Remember that because Yorick is column major the <tt>dimsof</tt>
			array has the format <tt>[2, cols, rows]</tt>!
			Writing out the dimensions as I have above is quite misleading, and 
			the mistake I at first made, because <tt>a</tt> has
			2 <em>columns</em> and <tt>b</tt> has 2 <em>rows</em> and 
			<em>4 columns</em>. They are therefore <em>NOT</em> conformable.
			Remember to group your dimensions correctly:
		</p>
		<pre>
/* This is the right way! */
             +++
dim_a = [ 1, |2| ]
dim_b = [ 2, |4|, 2 ]
             +++</pre>

		<h3>Pseudo Index</h3>
		<p>
			The Yorick manual example starts with the <a href="http://en.wikipedia.org/wiki/Outer_product"
			target="_blank">outer product</a> of two vectors. The following is taken from the
			linked-to Wikipedia article...
		</p>
		<p>
			Assume that there are two column vectors $u$ and $v$.
		</p>
		<p>
			$u = \begin{pmatrix}
			u1 \\
			u2 \\
			u3 \\
			u4
			\end{pmatrix}$

			and 

			$v = \begin{pmatrix}
			v1 \\ 
			v2 \\ 
			v3 
			\end{pmatrix}$
		</p>
		<p>
			The outer product of the two column vectors is defined as follows...
		</p>
		<p>
			$u \otimes v = uv^T = $
			$\begin{pmatrix}
			u_1 \\
			u_2 \\
			u_3 \\
			u_4 \\
			\end{pmatrix}$
			$\begin{pmatrix}
			v_1 & v_2 & v_3 \\
			\end{pmatrix} = $
			$\begin{pmatrix}
			u_1v_1 & u_1v_2 & u_1v_3 \\
			u_2v_1 & u_2v_2 & u_2v_3 \\
			u_3v_1 & u_3v_2 & u_3v_3 \\
			u_4v_1 & u_4v_2 & u_4v_3 \\
			\end{pmatrix}$
		</p>
		<p>
			The matrix multiplication of those two vectors puzzled me for a little
			bit (I've only ever been used to multiplying matricies with dimension
			sizes greater than 1). It may be easier to think of it as follows...
		</p>
		<p>
			$\begin{pmatrix}
			u_1 \\
			u_2 \\
			u_3 \\
			u_4 \\
			\end{pmatrix}$
			$\begin{pmatrix}
			v_1 & v_2 & v_3 \\
			\end{pmatrix} \equiv $

			$\begin{pmatrix}
			u_1 & 0\\
			u_2 & 0\\
			u_3 & 0\\
			u_4 & 0\\
			\end{pmatrix}$

			$\begin{pmatrix}
			v_1 & v_2 & v_3 \\
			0 & 0 & 0
			\end{pmatrix}$
		</p>
		<p>
			How do we do this using Yorick? All one dimension vectors in Yorick
			are column vectors (even if they are displayed textually as-if they
			are a row!). So can we just <tt>transpose()</tt> the $v$ vector?
		</p>
		<pre class="prettyprint linenums">&gt; a * transpose(b)
ERROR (*main*) operands not conformable in binary *
WARNING source code unavailable (try dbdis function)
&gt; transpose(b)
[100,200,300]
&gt; dimsof(transpose(b))
[1,3]</pre>
		<p>
			Apparently not! <tt>transpose(b)</tt> didn't do what it might have... I 
			thought it would turn the column vector into a row vector, but it doesn't.
			The reason for this is that a row vector is actually a 2D array, i.e.,
			it has an <em>extra dimension</em>. So, to convert $v$ into a row vector 
			we need to add an extra dimension!
		</p>
		<p>
			To convert $v$ into a row vector we need to make each column element
			it's own row in a 2D vector. If $v$ has 3 columns, $v^T$ has 3 rows,
			where each row has only one element. To do this in Yorick, as said, 
			we need an extra dimension... enter the <em>pseudo index</em>...
		</p>
		<pre class="prettyprint linenums">&gt; b
[100,200,300]
&gt; b(-,)
[[100],[200],[300]]
&gt; b(,-)
[[100,200,300]]</pre>
		<p>
			The syntax <tt>(-,)</tt>, really the symbol &quot;<tt>-</tt>&quot;, is
			the <b>pseudo index</b>. &quot;<tt>-</tt>&quot; means &quot;add an extra dimension
			here&quot;. 
		</p>
		<p>
			Munro calls <q>the - sign, when used as an index, a 
			<b>pseudo-index because it actually inserts an additional dimension into 
			the result[ing] array</b> which was not present in the array being indexed</q>.
			And, as we noted above, to go from a column vector to a row vector (i.e, transpose
			the column vector) we need to increase the dimensionality of our array.
		</p>
		<p>
			So, based on this, we can say that <tt>b(-,)</tt> is saying add a row
			dimension to the column vector, or more generally add another
			most-slow increasing dimension to the existing vector. In
			the example above we get a 2D vector with 3 rows and 1 column.
		</p>
		<p>
			How the extra dimension is added is both interesting and important.
			If <tt>b(-,)</tt> is saying add a row dimension, why does 
			<tt>b(-,) == [[100],[200],[300]]</tt> and not 
			<tt>[[100,200,300]]</tt>? They both have a row dimension added!
		</p>
		<p>
			I think of it in the following way. Remembering that Yorick is column
			major, anything to the left of the &quot;<tt>,</tt>&quot; in
			<tt>(,)</tt> indicates a faster dimension and anything to the right a
			slower dimension. Therefore, <tt>(-,)</tt> is saying add a faster
			dimension and <tt>(,-)</tt> is saying add a slower dimension... and this kinda works...
		</p>
		<p>
			This generalises... suppose we can <tt>c</tt> a two dimensional array 
			and we write <tt>c(-,)</tt>.
		</p>
		<pre>
&gt; c = [[1,2,3],[4,5,6]]
&gt; c
[[1,2,3],[4,5,6]]
&gt; c(-,)
[[[1],[2],[3]],[[4],[5],[6]]]

/* 
 * c hand-formatted is...
 *    [
 *       [ 1,  2,  3],
 *       [ 4,  5,  6]
 *    ]    |   |   |
 *         |   |   |
 * c(-,) hand-formatted is...
 *    [    |   |   |
 *       [[1],[2],[3]],
 *       [[4],[5],[6]]
 *    ]
 */
</pre>
	<p>
		To add the extra dimension, each column element becomes a row with one
		column, and therefore the rows become depths. <b>More generally it is like
			we shift the dimensions up one...</b> The fastest increasing dimension is changed
		so that each individual element inside it is now the fastest increasing
		dimension and all the containing dimensions become one slower! Ie., we've added
		a new fastest dimension.
	</p>
	<p>
		Now we can look at  <tt>b(,-)</tt> .
		Given the discussion so far it looks like we are saying add a column 
		dimension. We have
		seen that <tt>b(,-) == [[100,200,300]]</tt>. And this also makes sense...
		we've added a new slowest dimension.
	</p>
	<p>
		<img src="##IMG_DIR##/yorick_pseudo_index.jpg"/>
	</p>
	<p>
		So back to the original example of outer product. To accomplish this in
		Yorick we need to do <tt>u*(v-,)</tt> I.e., the transpose of <tt>v</tt>
		is <tt>v(-,)</tt>.
	</p>

		<h3>Matrix Multipication &amp; Inner Product</h3>
		<p>
			In Yorick the <a href="http://dhmunro.github.io/yorick-doc/manual/yorick_45.html#Matrix-Multiply"
				target="_blank">'<tt>+</tt>' sign</a> labels an array index for use
			in an <a href="https://en.wikipedia.org/wiki/Dot_product" target="_blank">inner product</a>
			(a.k.a. dot product or scalar product) and can be used to calculate vector 
			inner products or matrix multiplications.
		</p>
		<p>
			For two 1D arrays, <tt>a</tt> and <tt>b</tt>, the operation is fairly 
			straight forward. Writing <tt>a(+)</tt> and <tt>b(+)</tt> marks the only
			dimension in each array as being used for the inner product. Therefore,
			the calculation becomes $\Sigma a(i)b(i)$.
		</p>
		<p>
			So, what happens when the arrays have more than 1D? Let's have a look
			at some 2D arrays...
		</p>
		<p>
			<img src="##IMG_DIR##/dot_product_yorick_1.png" style="margin:10px;"/>
			<img src="##IMG_DIR##/dot_product_yorick_2.png" style="margin:10px;"/>
			<br/>
			<img src="##IMG_DIR##/dot_product_yorick_4.png" style="margin:10px;"/>
			<img src="##IMG_DIR##/dot_product_yorick_3.png" style="margin:10px;"/>
		</p>
		<p>
			We can see from the above that the index marked with the <tt>+</tt> 
			sign is used for the inner product. Note that all these combinations 
			are only possible because the matricies are square.
		</p>
		<p>
			For example, in the pictures above, <tt>a(,+)</tt> marks the <em>row</em>
			index as being used for the inner product. I.e by selecting all rows in 
			each column we create the vectors being used on the LHS of the dot 
			product. Therefore we select <tt>a(1,:)</tt>, <tt>a(2,:)</tt>
			all the way through to <tt>a(n,:)</tt>.
		</p>
		<p>
			Therefore, the indicies marked 
			with the <tt>+</tt> sign <em>must have the same length</em>. 
		</p>
		<p>
			<div class="box_container"><div class="info">
				<p>
					Indicies marked  with the <tt>+</tt> sign <em>must have the same 
					length</em>.
				</p>
			</div></div>
		</p>
		<p>
			Lets say <tt>dimsof(a) = (2, n, m)</tt> and <tt>dimsof(b) = (2, m, l)</tt>.
			The process for <tt>c = a(,+)*b(+,)</tt> becomes:
		</p>
		<pre>for i 1..n 
   v1 = a(i, :) // 1d vector, length m
   for j in 1..l
      v2 = b(:, j) // 1d vector, length m
      r(i,j)  = v1(+) * v2(+)</pre> 

		<p>
			The only matrix multiplication I was ever taught was &quot;normal&quot;
			matrix multiplication:
		</p>
		<p>
			$$\begin{pmatrix}
			a(1,1) & a(2,1)\\
			a(1,2) & a(2,2)\\
			\end{pmatrix}
			\begin{pmatrix}
			b(1,1) & b(2,1)\\
			b(1,2) & b(2,2)\\
			\end{pmatrix} = $$
			$$\begin{pmatrix}
			a(1,1)b(1,1) + a(2,1)b(1,2) & a(1,1)b(2,1) + a(2,1)b(2,2)\\
			a(1,2)b(1,1) + a(2,2)b(1,2) & a(1,2)b(2,1) + a(2,2)b(2,2)\\
			\end{pmatrix} = $$
			$$\begin{pmatrix}
			a(:,1)b(1,:) & a(:,1)b(2,:)\\
			a(:,2)b(1,:) & a(:,2)b(2,:)\\
			\end{pmatrix}$$
		</p>

		<p>
			What you might notice is that the way the matrix multiplication works
			in Yorick, as described above, the index of the RHS changes most
			quickly. In &quot;normal&quot; matrix multiplication, it is the LHS
			index that is changing most quickly. 
			
		</p>
		<p>
			The figure below compares the closest operation we've seen so far with
			what I'd think of as a &quot;normal&quot; matrix multiplication...
		</p>
		<p>
			<img src="##IMG_DIR##/dot_product_normal.png" style="margin:10px;"/>
		</p>
		<p>
			Visually we can see that <tt>transpose(a(+,)*b(,+))</tt> is equivalent
			to the &quot;normal&quot; matrix multiplication.
		</p>
		<p>
			Another way to do this is to note that...
			$$\begin{pmatrix}
			a(:,1)b(1,:) & a(:,1)b(2,:)\\
			a(:,2)b(1,:) & a(:,2)b(2,:)\\
			\end{pmatrix} \equiv 
			\begin{pmatrix}
			b(1,:)a(:,1) & b(2,:)a(:,1)\\
			b(1,:)a(:,2) & b(2,:)a(:,2)\\
			\end{pmatrix}$$
		</p>
		<p>
			Therefore, to accomplish this &quot;normal&quot; matrix multiplication
			between <tt>a</tt> and <tt>b</tt>, in Yorick we would write
			<tt>b(,+) * a(+,)</tt> to do the &quot;normal&quot; matrix 
			multiplication <tt>AB</tt>.
		</p>
		<p>
			As we've noted, all these combinations above are only possible because 
			the matricies are square. Remember that the indicies marked for inner
			product must share the same length. If, for example <tt>a</tt> has
			3 rows and 2 columns and <tt>b</tt> had 8 rows and 2 columns, the 
			only possible operation would be <tt>a(+,)*b(,+)</tt>.
		</p>

		<h4>An Example With SVsolve</h4>
		<p>
			The function <tt>SVsolve</tt> can be used to solve sets of simultaneous
			linear equations. Let's say that we have two arrays. Array <tt>a</tt>
			will represent the coefficients of the unknowns in our set of quations.
			lets say that that we have <tt>n</tt> unknowns and <tt>m</tt> 
			equations. The array <tt>a</tt> is an <tt>n x m</tt> matrix. Our linear
			equations, as we would normally write them (i.e., as I was taught in
			school) therefore look like this:
		</p>
		<p>
			<img src="##IMG_DIR##/solve_linear_equations_norm.png" style="margin:10px;"/>
		</p>
		<p>
			So if I were to pass the coefficient matrix (2D array) and the result
			vector (1D array) to <tt>SVsolve</tt> everything will work fine right?
			Err... no! Doh! Why not? It comes back to the issue
			above... the matrix multiplication is (at least for me) slightly
			unintuitive (probably just me!).
		</p>
		<p>
			<tt>SVsolve()</tt> solves for <tt>A(,+)*x(+) = B</tt>. As we've seen,
			<tt>A(,+)</tt> will multiply the <em>columns</em> of <tt>A</tt> with 
			<tt>x(+)</tt>. Oops: <tt>SVsolve()</tt> is trying to do this:
		</p>
		<p>
			<img src="##IMG_DIR##/solve_linear_equations_oops.png" style="margin:10px;"/>
		</p>
		<p>
			So, the solution is to <tt>transpose()</tt> the array you are using
			before passing it to <tt>SVsolve()</tt>!
		</p>


			

			

		<h3>Rubber Indicies In Yorick</h3>
		<p>
			<q>Yorick has one other indexing syntax which has proven useful, which I
				call <em>rubber indices</em>.  They address the problem of writing
			interpreted code which extracts slices of arrays when you don't know
			beforehand how many dimensions the array has.  An example is an
			opacity array for which you know that the most slowly varying index
			represents photon wavelength, but there might be zero, one, two, or
			three faster varying dimensions representing position in space.</q> -- 
			<a href="https://mail.python.org/pipermail/matrix-sig/1995-November/000142.html" target="_blank">
			PYTHON MATRIX-SIG</a>
		</p>
		<div>
			<pre class="prettyprint linenums">
&gt; a = [ [    [1,2,3], 
             [4,5,6]
        ],[
             [11, 22, 33], 
             [44,55,66]
      ] ]
&gt; a
[[[1,2,3],[4,5,6]],[[11,22,33],[44,55,66]]]
&gt; a(1)
1
&gt; a(1,1,1)  ## Give me the first element in the inner array, from 1st array 
1           ## in the middle array, from the first array (of arrays) from the 
            ## outer array

&gt; a(1,:)    ## Give me the first element in each inner array, contained in the
[1,4]       ## same parent array. This is a little incorrect because we donâ€™t
            ## specify all array dimensions in the indecies

&gt; a(1,:,:)      ## Give me the first element in each inner array, from each 
[[1,4],[11,44]] ## outer array, contained in the overall array

&gt; a(1,..)       ## The RUBBER INDEX says the same thing: Give me the first
[[1,4],[11,44]] ## element from the innermost array and do the same recursing
                ## outwards

&gt; a(1,*)        ## Another RUBBER INDEX that collapses all arrays into one.
[1,4,11,44]

&gt; a(:,1,1)      ## Give me everything from the first array, i.e., the array
[1,2,3]         ## itself, from the element in the middle array from the first
                ## element in the outer array.

&gt; a(:,1,..)           ## Give me everything from the first array, ie. the
[[1,2,3],[11,22,33]]  ## array itself, from the first element in the middle
                      ## array from all elements in the outermost array.</pre>
			<img src="##IMG_DIR##/YorickRubberIndex.png"/>
		</div> <!-- END H3: Rubber Indicies In Yorick -->
	</div> <!-- END H2: Yorick Arrays -->

	<!-- YORICK OXY OBJECTS ------------------------------------------------ -->
	<h2>Oxy Objects</h2>
	<div>
		<h3>Copying Oxy Objects</h3>
		<p>
			When you assigned an OXY object from one variable to another is is <em>copied by reference</em>.
			Thus changing an object member will be reflected in both variables as <em>assignment is not copy</em>
			for OXY objects.
		</p>
	
		<pre class="prettyprint linenums">&gt; a = save(q = 123)
&gt; a.q
123
&gt; b = a
&gt; save, a, q=321 /*&lt;--  Changing a's member variable will change b's! */
&gt; a.q 
321
&gt; b.q 
321              /*&lt;-- LOOK, b has been affected by the change to a! */</pre>
	
		<p>
			Given the rational behind Yorick as a number cruncher, this makes a lot of sense. It's a little like passing an array into
			a function. If we think as an OXY object as a potential &quot;bag&quot; of large data, copying it would be hugely expensive, so that is why an object
			assignment is NOT a copy!
		</p>
		<p>
			To actually make a realy copy of the object you have to manually copy each member of one object to the other.
		</p>
		<pre class="prettyprint linenums">&gt; a = save(q=101)
&gt; b = save()     /*&lt;-- Must manually re-create a new... */
&gt; save, b, q=a.q /*    ...object if we are to copy a */
&gt; a
object [1]: group
&gt; a.q
101
&gt; b.q
101
&gt; save, a, q=999
&gt; a.q
999
&gt; b.q
101              /*&lt;-- Changing a.q has not affected b.q. We did a proper copy!</pre>
		<p>
			BUT, this is further complicated by arrays as member variables and OXY objects as
			member variables. For example, examine the following.
		</p>
		<pre class="prettyprint linenums">&gt; a = save(q=[1,2,3])        
&gt; b = save()
&gt; save, b, q=a.q
&gt; b.q
[1,2,3]
&gt; a.q
[1,2,3]
&gt; a.q(1) = 111
&gt; a.q
[111,2,3]
&gt; b.q
[111,2,3]</pre>
		<p>
			In the above example we used the same recipe as above, but because <tt>q</tt> is now an array
			the reference to the array is copied and not the value. Again, make sense for Yorick as a
			number cruncher of large data arrays, but if you wanted a copy, this could throw you. The same
			copy-of-reference problem would occur if <tt>q</tt> has been another OXY object.
		</p>
		<p>
			You make have done a double-take here because previosuly, when describing arrays,
			we said array assignment copies the array <em>values</em>, i.e. a complete copy of the array
			is made. This is clearly not the case when saving an OXY object member as an
			array. OXY object members appear always to be references unless the member stores
			a non-array primative.
		</p>
		<p>
			<div class="box_container"><div class="info">
				<p>
					OXY object members appear always to be references unless the member stores
					a non-array primative. Be cautious, when setting an OXY object 
					member to equal an array: remember, unlike vanilla array to array copy, the OXY object member stores a 
					<em>reference</em> to the asignee!
				</p>
			</div></div>
		</p>
		<p>
			If you want to copy an array &quot;into&quot; an OXY object (actually create a nameless
			array and assign the reference to the OXY object member), use <em>array slicing</em> and
			take, if you want the entire array, a slice of the entire array:
		</p>
		<pre class="prettyprint linenums">
&gt; a = [1,2,3]
&gt; b = save(a=a(:)) # By taking a slice of the entire array we force a copy.
&gt; b.a              # Slicing operations happen immediately and result in a 
[1,2,3]            # temporary array, the reference to which is then stored
&gt; a                # in the OXY object member.
[1,2,3]
&gt; a(1)=99
&gt; a
[99,2,3]
&gt; b.a
[1,2,3]</pre>
		<p>
			To fully, deep copy, an OXY object your therefore have to build a new object from scratch,
			and copy in all primative types and then recursively copy in all member OXY objects and also
			take care to copy the arrays correctly.
		</p>
	</div>  <!-- END "Oxy Objects" H2 Div -->

	<!-- YORICK WRITING PLUGINS -------------------------------------------- -->
	<h2>Writing Yorick Plug-Ins</h2>
	<div>
		<p>
			Here I cover &quot;manually&quot; writing a plugin, i.e, <em>not</em> using Codger to
			auto-generate the C code using the <tt>PROTOTYPE</tt> Yorick comment method. Most of the
			stuff you need to know in order to do this can be found in 
			<a href="https://github.com/dhmunro/yorick/blob/master/yorick/yapi.h" target="_blank">yapi.h</a> 
			and the source code comments are pretty comprehensive.
		</p>
		<p>
			One point to note about terminology. Whenever I talk about &quot;stack&quot; I will,
			unless made explicitly clear, be talking about the Yorick stack. This is a stack maintained
			by the Yorick interpretter and has nothing to do with your process/thread stack!
		</p>
		<h3>An Intro: Create The Plugin Shell And The Basics</h3>
		<div>
			<h4>Create The Shell</h4>
			<p>
				To create the Yorick makefile, there must be at least one <tt>.i</tt> file available.
				You will most likely also need the equivalent <tt>.c</tt> file. In this example I will
				call the plugin &quot;jehtech&quot;, so I have created the files &quot;<tt>jehtech.i</tt>&quot;
				and &quot;<tt>jehtech.c</tt>&quot;.
			</p>

			<pre class="prettyprint linenums">/*
 * FILE: jehtech.i
 */
plug_in, "jehtech"

extern jehtech_Version;
/* DOCUMENT void jehtech_Version()
 *
 *    Return string describing version of the library
 */</pre>

		<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
#include "yapi.h"
#include "ydata.h"

#ifndef NULL
#define NULL '\0'
#endif

void Y_jehtech_Version(int argc)
{
   ystring_t *verStr = NULL; /* ystring_t is char*, so this is char** */

   /* Push a ystring_t* onto the stack. This is a char** */
   verStr = ypush_q(0);
   if( !verStr )
      y_error("Could not push return string onto stack"); 

   /* p_strcpy is Yorick's mem-managed of strcpy(). Returns char* */
   *verStr = (ystring_t)p_strcpy("v1.0");
}</pre>
 
			<p>
				Once these are created we can create the Makefile for this plugin. From the linux command line:
			</p>

			<pre class="prettyprint linenums"><b>$ yorick -batch make.i</b>
created Makefile
 automatically generated make macros and dependencies:
PKG_NAME=jehtech
PKG_I=jehtech.i
OBJS=jehtech.o
 edit Makefile by hand to provide PKG_DEPLIBS or other changes</pre>
			<p>
				In your working directory you will now have a ready made <tt>Makefile</tt>. Run it by typeing <tt>make all</tt>.
			</p>
			<p>
				In the directory of complilation you will now have the object and library files <tt>jehtech.o</tt> and <tt>jehtech.so</tt>. There
				will also be two new files <tt>ywrap.c</tt> and <tt>ywrap.o</tt>, the object file having been added into the library.
			</p>
			<p>
				Now, from this directory, fire up Yorick to test our little plugin...
			</p>
			<pre class="prettyprint linenums"><b>$ rlwrap yorick</b>
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; jehtech_Version()
"v1.0"</pre>
			<p>
				The function <tt>jehtech_Version()</tt> has correctly returned the version string!
			</p>
			<p>
				So, we kinda just dived into the deep end of the pool here so now to explain what we've done...
			</p>
			<p>
				The example above shows us how to extend Yorick by binding a Yorick function name to a C function.
				There are two component files, the Yorick include file and the C file that implements the functionality.
				This C-implemented functionality will often call upon other libraries that you are in some way wrapping.
			</p>
			<p>
				The Yorick include file so far has two lines of note:
			</p>
			<ol>
				<li>
					<tt>plug_in, "jehtech"</tt><br/>
					This line declares this script file as one that defines a plugin or library. When this file is
					included Yorick will go off and try to find the dynamic library <tt>jehtech.so</tt> and attempt to
					load it.
				</li>
				<li>
					<tt>extern jehtech_Version;</tt></br/>
					Declares a symbol that will be added to the Yorick interpretters list of recognised symbols.
					The magic Yorick binding will associate this symbol with the C function <tt>Y_jehtech_version</tt>.
					Whenever a Yorick script calls the function <tt>jehtech_Version()</tt>, under the hood
					<tt>Y_jehtech_version()</tt> will be called.
				</li>
			</ol>

			<h4>Quick Debug Tip</h4>
			<p>
				If Yorick is complaining that it cannot find a library you can always try setting <tt>export LD_DEBUG=libs</tt>
				before running Yorick (or <tt>export LD_DEBUG=help</tt> to get help). You'll get debug output describing libraries being searched for and
				loaded. You can also set <tt>export LD_DEBUG=all</tt> for an absolute shed-load of debug info, which might be too much, but at least
				you'll be able to see where the loader is searching for libraries and what, if anything, it finds. To clear the
				loader debug output just set <tt>export LD_DEBUG=</tt>.
			</p>
		</div> <!-- END H3 Div -->



		<h3>Passing Values To C Functions From Yorick</h3>
		<div>
			<h4>Parameters Passed On Yorick Stack</h4>
			<p>
				Yorick maintains a parameter stack that it uses to pass values to an interface function (for example <tt>Y_jehtech_version()</tt>) 
				and receive return values. Function parameters are pushed in-order onto the stack and whatever
				is at the top of the stack when the interface function exists, is it's return value.
			</p>
			<p>
				So, if we have a Yorick function with parameters a, b, c, they will be passed to the C interface function 
				on the Yorick stack. At stack position 0 will be c, at position 1, b, and at position 2, a. If the function
				wanted to return the multiple a*b*c it would put the result on the top of the stack, at position 0, to return
				this value to the Yorick interpretter.
			</p>
			<p>
				All interface functions will have the same return value, <tt>void</tt>, and the same parameter list, consisting
				of one integer, usually called <tt>argc</tt>, which gives the number of parameters pushed onto the stack 
				(note I mean the <em>Yorick stack</em> and *not* the C stack!).
			</p>
			<pre class="prettyprint linenums">void Y_functionName(int argc) {
   /* argc gives the number of elements pushed onto the **Yorick** stack. 
    * Note this has nothing to do with the C stack! */
   ... 
   /* Anything left or placed on the top of the **Yorick** stack is the
    * function's return value */
}</pre>
			<p>
				Lets see this in action by creating a new function <tt>jehtech_ParameterOrder(a,b,c)</tt> and the associated
				interface function <tt>Y_jehtech_ParameterOrder()</tt>:
			</p>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.i
 */
... snip ...
extern jehtech_ParameterOrder;</pre>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
... snip ...
void Y_jehtech_ParameterOrder(int argc)
{
   long hundreds = ygets_l(0),
        tens     = ygets_l(1),
        units    = ygets_l(2);

   ypush_long(hundreds*100 + tens*10 + units);
}</pre>
			<p>
				With the above modifications added and the plugin recompiled (just use <tt>make all</tt>, no need to regenerate the Makefile!) 
				we can run the Yorick interpretter and see the results.
			</p>
			<pre class="prettyprint linenums">$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; <b>jehtech_ParameterOrder(1,2,3)
321</b></pre>
			<p>
				The signature, written in C parlance, for <tt>jehtech_ParameterOrder()</tt> is 
				<tt>long jehtech_Parameters(long units, long tens, long hundreds)</tt>.
			</p>
			<p>
				We can clearly see that the last parameter is at the top of the stack and the first parameter is at the bottom.
				<div class="box_container"><div class="info">
						<p>
							Function parameters, passed on the Yorick stack, are pushed on in parameter order. This means that
							the last parameter will be at the top of the stack and the first at the bottom.
						</p>
				</div></div>
			</p>
			<p>
				As explained in <tt>yapi.h</tt>, the stack has space for at least 8 
				new elements when your plug-in's interface C function is called.
				It notes that if you are going to push more than 8 things onto the stack however, that you must reserve
				that space to avoid stack overflow.
				<div class="box_container"><div class="warning">
						<p>
							If you push more than 8 items onto the Yorick stack you must reserve enough space using 
							<tt>ypush_check()</tt> to avoid stack overflow!
						</p>
				</div></div>
			</p>

			<h4>Getting Scalar Parameters</h4>
			<p>
				The previous example showed how a function could retrieve 3 <tt>long</tt> parameters. The function
				<tt>ygets_l(stack_index)</tt> reads the <tt>long</tt> value at position <tt>stack_index</tt> in the
				stack. Note that it <em>does not pop</em> the value, it <em>only peeks</em> at the value. Position
				zero is the top of the stack.
			</p>
			<p>
				All of the functions that peek at scalars on the stack are called <tt>ygets_X</tt>, where <tt>X</tt>
				is a single character representing the type of value, <tt>l</tt> for long, for example. Here is a list
				of the scalar-peaking functions. Each function has one <tt>int</tt>argument, the stack position to peak.
			</p>
			<table style="border:0px">
				<tr>
					<td><tt>long ygets_l(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>double ygets_d(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>ystring_t ygets_q(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>ypointer_t ygets_p(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>char ygets_c(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>unsigned char ygets_uc(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>short ygets_s(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>int ygets_i(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>float ygets_f(int iarg)</tt></td>
				</tr>
			</table>

			<h4>Getting Array Parameters</h4>
			<p>
				All yorick array dimensions are represented by the list <tt>[rank, ndim1, ndim2, ..., ndimY]</tt>. The first
				parameter of the list, <tt>rank</tt>, gives the number of dimensions that the array possesses. The size of
				each dimension is given by <tt>ndimX</tt>. For example, a 2D array with 10 columns and 90 rows will be
				described by the list <tt>[2, 10, 90]</tt>. The size of the array dimension list is limited in Yorick. It 
				will be a maximum of <tt>Y_DIMSIZE</tt> <tt>long</tt>'s. This means that Yorick arrays cannot have more than
				<tt>Y_DIMSIZE-1</tt> dimensions.
			</p>
			<p>
				The first thing to remember is that <em>Yorick arrays are column major</em>. Therefore a 2D array is 
				described by the dimensions list <tt>[2, #columns, #rows]</tt>. Very easy to see this in action. We'll
				make the following additions to our project (note: generally you should not use <tt>printf</tt> like
				I'm doing here).
			</p>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.i
 */
...
extern jehtech_ArrayTest;</pre>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
...
#include &lt;stdio.h&gt;
...
void Y_jehtech_ArrayTest(int argc)
{
   long i;
   long dimInf[Y_DIMSIZE];
   long ntot;
   long *ary = ygeta_l(0, &amp;ntot, dimInf);
   printf("jehtech_2DArray: ntot == %ld\n", ntot);
   printf("jehtech_2DArray: dimInf = [");
   for(i = 0; i &lt;= dimInf[0]; ++i) {
      printf(&quot;%ld%s&quot;, dimInf[i], i == dimInf[0] ? &quot;]&quot; : &quot;, &quot;);
   }
   printf(&quot;\n&quot;);
}</pre>
			<p>
				Recompile the plugin and running Yorick, we can get the following:
			</p>
			<pre class="prettyprint linenums">
$ make all
...
$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; jehtech_ArrayTest, [1,2,3]
jehtech_2DArray: ntot == 3
jehtech_2DArray: dimInf = [1, 3]
&gt; jehtech_ArrayTest, [[1,2,3], [1,2,3]]
jehtech_2DArray: ntot == 6
jehtech_2DArray: dimInf = [2, 3, 2]
&gt; jehtech_ArrayTest, [[[1,2,3,4], [1,2,3,4]], [[1,2,3,4], [1,2,3,4]]]
jehtech_2DArray: ntot == 16
jehtech_2DArray: dimInf = [3, 4, 2, 2]</pre>

			<p>
				Great so we can, from our C code, get an array of <tt>long</tt>'s, or at least so far, it's dimensions
				so that we can determine what shape the array is. But what about accessing the array values? Yorick
				specifies everything <em>column major</em>, so in the array <tt>[[1,2,3,4], [5,6,7,8]]</tt> to access
				the third column, second row, we would write <tt>a(3,2)</tt>. However, under the hood Yorick stores
				arrays C-style... i.e., from C, when passed an array, we would access it as <tt>a[2][3]</tt> or
				<tt>a[2*num_cols + 3]</tt>. 
			</p>
			<p>
				Lets see this in action to see that this is in fact the case. We'll make the following additions to
				out project files...
			</p>
			<pre class="prettyprint linenums">/* 
 * FILE: jehtech.i
 */
...
extern jehtech_Dump2D;</pre>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
...
void Y_jehtech_Dump2D(int argc)
{
   /* PRE: array is 2D! */
   long row, col;
   long dimInf[Y_DIMSIZE];                       /* [rank, #cols, #rows] */
   long *ary = ygeta_l(0, NULL, dimInf);
   for(row = 0; row &lt; dimInf[2]; ++row) {        /* dimInf[2] is #rows   */
      for(col = 0; col &lt; dimInf[1]; ++col) {     /* dimInf[1] is #cols   */
         printf("%ld\t", ary[row*dimInf[1] + col]);
      }
      printf("\n");
   }
}</pre>
			<p>
				Recompiling and running Yorick we then see the following...
			</p>
			<pre class="prettyprint linenums">$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; require, "jehtech.i"
&gt; jehtech_Dump2D, [[1,2,3,4], [5,6,7,8]]
1	2	3	4	
5	6	7	8</pre>

		</div> <!-- END H3 Div -->
	</div> <!-- END H2 Div -->


	<h2>Run Yorick From Python</h2>
	<div>
		<p>
			Cool... this looks promising as to test some Yorick I have been
			using Robot Framework so being able to do this would make tests 
			easier! Haven't done anything with it yet but Munro has written a
			<a href="https://github.com/dhmunro/pyorick"
				target="_blank">Python module interact with Yorick</a>.
		</p>
	</div> <!-- End H2: Run Yorick From Python -->
</div> <!-- END H1 Div -->
</div> <!-- END "Contents" Div -->
</body>
</html>


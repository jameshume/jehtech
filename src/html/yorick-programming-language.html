<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>The Yorick Programming Language | JEHTech</title>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']]
			},
			displayAlign: "left",
			displayIndent: "2em"
		});
	</script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
	<style>
		ul li .MathJax {font-size: 3em;}
	</style>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<!-- TITLE ------------------------------------------------------------- -->
<h1 class="title">The Yorick Programming Language</h1>
<div style="padding-right:10px;">
	<p>
		The <a href="http://dhmunro.github.io/yorick-doc/" target="_blank">Yorick Programming Language</a>, written by 
		<a target="_blank" href="http://en.wikipedia.org/wiki/David_H._Munro">David Munro</a>, &quot;...is an interpreted 
			programming language for scientific simulations or calculations, postprocessing or steering large 
			simulation codes, interactive scientific graphics, and reading, writing, or translating large files of numbers...&quot; 
	</p>
	<p>
		The size of the Yorick 2.2.03 binaries and supporting files, i.e., the 
		relocate directory with <tt>doc</tt> and <tt>g</tt> removed for my ARM9 
		cross compilation was ~5MB. The interpreter binary was ~1.2MB
		with ~1.5MB for the Yorick include files (demo and test files deleted) 
		but you can trim this further depending on what you use. Things like the C include 
		files can be removed (you only need these if you're writing your own 
		Yorick extensions). The <tt>lib</tt> can also be trimmed if
		you were not using the 
		<tt><a href="https://github.com/dhmunro/yorick/tree/master/hex" 
				target="_blank">hex</a></tt> or 
		<tt><a href="https://github.com/dhmunro/yorick/tree/master/drat" 
				target="_blank">drat</a></tt> libraries and didn't
		ever need to run <tt>codger</tt> on target. You could also trim out 
		<a href="https://github.com/dhmunro/yorick/tree/master/gist" 
			target="_blank">Gist</a>,
		which is a 
		<a href="https://en.wikipedia.org/wiki/Computer_Graphics_Metafile" 
			target="_blank">Computer Graphics Metafile (CGM)</a> file viewer.
	</p>

	<!-- PAGE CONTENTS ----------------------------------------------------- -->
	<h2>Page Contents</h2>
	<div id="page_contents">
	</div>

	<h2>Useful Links</h2>
	<div>
		<ul>
			<li><a href="http://dhmunro.github.io/yorick-doc/" target="_blank">Yorick Documentation On GitHub</a>.</li>
			<li><a href="http://yorick.sourceforge.net/yorick.pdf" target="_blank">Yorick Manual as a PDF</a>.</li>
			<li><a href="http://yorick.sourceforge.net/yorickfaq.php" target="_blank">Yorick FAQ on Source Forge</a>.</li>
		</ul>
	</div>

	<!-- INSTALL YORICK ON UBUNTU ------------------------------------------ -->
	<h2>Easy Yorick Install On Ubuntu</h2>
	<div>
		<p>
			Really very very easy. Just do <tt>sudo apt-get install yorick</tt>! If you want to develop
			your own Yorick plugins then your will also need to do a <tt>sudo apt-get install yorick-dev</tt>.
		</p>
		<pre class="prettyprint linenums">apt-get install yorick yorick-dbg yorick-dev</pre>
	</div>

	<!-- GET Y_HOME -------------------------------------------------------- -->
	<h2>Get Yorick Home Path, Y_HOME</h2>
	<div>
		<p>
			For some of my little make jobs I want to be able to compile Yorick on two targets.
			On one target it is built from scratch so Yorick lives in one directory but on my
			Linux box it lives under <tt>/usr/bin</tt> and <tt>/usr/lib</tt>. Really the <tt>/usr/bin/yorick</tt>
			binary just points to <tt>/usr/lib/yorick/bin/yorick</tt> as Yorick tends to live under the one
			installation directory.
		</p>
		<p>
			Usually to generate a plugin Makefile you'd just type...
		<pre class="prettyprint linenums">yorick -batch make.i</pre>
		<p>... and get an auto generated Makefile with variables pointing to your Yorick installation written into
			the Makefile for you. For example, on my Ubuntu atp-gett'ed installation I get the following.
		</p>
		<pre class="prettyprint linenums"># these values filled in by &quot;yorick -batch make.i&quot;
Y_MAKEDIR=/usr/lib/yorick
Y_EXE=/usr/lib/yorick/bin/yorick
Y_EXE_PKGS=
Y_EXE_HOME=/usr/lib/yorick
Y_EXE_SITE=/usr/lib/yorick
Y_HOME_PKG=</pre>
		<p>
			One way to get the Yorick installation directory for a system that is
			independent of the particular Yorick installation is as follows. 
		</p>
			<pre class="prettyprint linenums">YORICK_HOME="$(echo "print, Y_HOME" | yorick | grep '^".*yorick' | sed -e 's/"//g' | tr -d '\r' | sed -r 's/\/ *$//g')"
echo $YORICK_HOME</pre>
		<p>
			You can then substitute <tt>YORICK_HOME</tt> into the auto-generated Makefile so that
			it should work regardless who has the plugin and where their particular Yorick
			is installed (it might not be <tt>/usr/lib/yorick</tt> if they have installed in manually,
			for example).
		</p>
	</div>

	<!-- YORICK ARRAYS ----------------------------------------------------- -->
	<h2>Yorick Arrays</h2>
	<div>
		<h3>Major Differences VS C Arrays</h3>
		<ol>
			<li><b>Yorick arrays start at index <tt>1</tt></b> but C arrays start at index <tt>0</tt>.
			<li><b>Yorick arrays are column</e>-major</b> whereas C arrays are row-major. 
				<ul>
					<li>This means that <tt>array[1][2]</tt> in C addresses row 1, 
						column 2 (remember because C indices start at 0 this means the second row, third column).
						<b>I.e., the C-syntax is <code>array[ROW][COL]</code></b>
					</li>
					<li>But in Yorick, <tt>array(1,2)</tt>, addresses column 1, row 2 (in C column 0, row 1 taking 
					into account the start index of <tt>1</tt> instead of <tt>0</tt>. 
					<b>I.e, the Yorick-syntax is <code>array(COL, ROW)</code>.</b>
					</li>
				</ul>
			</li>
		</ol>
		<p>
			<div class="box_container"><div class="info">
				<p>
					Yorick arrays are column major and indices start at 1.
				</p>
			</div></div>
		</p>
		<h3>What Is Row/Column Major?</h3>
		<p>
			For all languages, arrays are are contiguous blocks of items. Therefore, in memory we can 
			store a 1D arrays as follows:
		</p>
		<pre>| ITEM[0] | ITEM[1] | ITEM[2] |  ...  | ITEM[N]
|         |         |         |       |
0 *sz     |         |         |       |
          1 *sz     |         |       |
                    2 *sz     |       |
                              3 * sz  :
                                      |
                                      N * sz</pre>
		<p>
			Here we store the first array element at the lowest memory address and increment upwards. 
			You can see that each element is contiguous in memory. It is worth noting that the
			array is contiguous in terms of the language's model of the memory. For systems with
			an MMU this means virtual memory (which if the array crosses a page boundary it is 
			only contiguous in virtual memory, not necessarily physical memory)
		</p><p>
			What happens when we try to store a 2D array? Consider the following array:
		</p><pre>int someArray[2][3] = { { 1, 2, 3},
                        { 4, 5, 6} }</pre>
		<p>
			This is something we're very used to in C. We read this as an array with 2 rows and 3 columns.
			But how is this laid out in memory? It still has to be a contiguous chunk of memory but now there
			are two layout options. The C way is to lay out the array as follows:
		</p><pre>| ITEM[0][0] | ITEM[0][1] | ITEM[0][2] | ITEM[1][0] | ITEM[1][1] | ...
|            |            |            |     ^^^    |          
0 *sz        |            |            | Note: new  |
             1 *sz        |            | row starts |
                          2 *sz        |            |
                                       3* sz        |
                                                    |
                                                    4 * sz</pre>
		<p>
			The array items are represented as a contiguous flow of values. The first row is laid out as it
			was for the 1D array, then the second row is appended to this block as if it were a 1D array
			and so on. Each row, therefore, starts at address <tt>row_index*3</tt>.
		</p><p>
			The C syntax specifies the fastest increasing index in memory from right to left. What does
			&quot;fastest&quot; mean? I'm using Munro speak here, and what he means is that, if we looked
			at the above memory layout, as we move one position from left to right the first dimension
			to increase is the &quot;fastest&quot;, so in the C sense this is column. 
		</p>
		<p>
			Another way to think about this is considering
			an <tt>int p* = someArray</tt> pointer. As we increment this pointer by one (<tt>p++</tt>) it will traverse the columns in a row,
			which is what Munro calls the fastest increasing dimension, and then once all the columns in one row
			are iterated over it will move to the columns in the next row (so therefore the row is the second
			fastest increasing dimension) and so on.
		</p>
		<p>
			We can see 
			this in the above definition, <tt>int [2][3]</tt>, where the right most dimension is <tt>[3]</tt> 
			and represents the fastest increasing dimension in memory. The next dimension to the left is 
			<tt>[2]</tt> and is the second fastest increasing dimension: rows.
		</p><p>
			This method of thinking about an array can be used for any number of dimensions. Consider <tt>int anotherArray[2][3][4][5]</tt>.
			We know that the fastest increasing dimension is <tt>5</tt>, so if <tt>int *p = anotherArray</tt> then...
		</p>
		<ul><li><tt>*p &nbsp;&nbsp;&nbsp;&nbsp;== anotherArray[0][0][0][0]</tt></li>
			 <li><tt>*(p+<b>1</b>) == anotherArray[0][0][0][<u>1</u>]</tt></li>
			 <li><tt>...</tt></li>
			 <li><tt>*(p+<b>4</b>) == anotherArray[0][0][0][<u>4</u>]</tt></li>
		</ul>
		</p><p>
			We also know that:
		</p>
		<ul>
			<li><tt>*(p+<b>a*5</b>)&nbsp;&nbsp;&nbsp;&nbsp; == anotherArray[0][0][<u>a</u>][0]</tt></li>
			<li><tt>*(p+<b>b*4*5</b>) &nbsp; == anotherArray[0][<u>b</u>][0][0]</tt></li>
			<li><tt>*(p+<b>c*3*4*5</b>) == anotherArray[<u>c</u>][0][0][0]</tt></li>
		</ul>
		<p>
			So when we say <em>row-major</em>, we mean that, in terms of the syntax, the right most index is the
			<em>fastest incrementing dimension</em> and going left the speed of increment decreases.
		</p>
		<p>
			<em>Column-major</em> therefore means, that, again in terms of the syntax, the right most index is the
			<em>slowest incrementing dimensions</em> and going left the speed of increment increases.
		</p><p>
			I keep saying &quot;in terms of syntax&quot; because as Yorick is implemented in C its physical array
			storage is C-like. It is only in the scripting language itself that column-major notation is used.
		</p>
			<div class="box_container"><div class="info">
				<p>
					<b>Row-major</b> means that, syntactically, the right most index is the
					<em>fastest incrementing dimension</em> and going left the speed of increment decreases.
					<br/>
					<b>Column-major</b> means that, syntactically, the right most index is the
					<em>slowest incrementing dimensions</em> and going left the speed of increment increases.
				</p>
			</div></div>

		<h3>Adding More Dimensions: Row/Column Major Syntax in C VS Yorick</h3>
		<img style="float:right; margin-right:10px;" src="##IMG_DIR##/C_3D_Array.png" alt="3D array visualisation">
		<p>
		So, now moving onto ad 3D example... I'd normally visualise a 2x2x2 array
		as is shown to the right.
		</p>
		</p>
			The 2x2x2 array is an array of two 2x2 arrays. Each 2x2 array is what
			one would normally expect: a set of rows and a set of columns. So,
			the front 2x2 block has 2 rows and 2 columns, as does the back 2x2 block.
			The new dimension is the depth (or what I call &quot;depth&quot; anyway),
			the third dimension.
		</p>
		<p>
			Given the description so far I would intuitively expect C to access 
			the array using this syntax: <code>array[DEPTH][ROW][COL]</code>. I would
			expect Yorick to access the array using this syntax: <code>array(COL, ROW, DEPTH)</code>.
		</p>

		<h4>In C: <code>array[DEPTH][ROW][COL]</code></h4>
		<p>To be double sure, look at the noddy little program below:
		</p>
		<pre>#include <stdio.h>

int main(int argc, char *argv[])
{
   int array[2][2][2] = {
                           {
                              { 1, 2}, /* Depth, 0, row 0 */
                              { 3, 4}  /* Depth, 0, row 1 */
                           },
                           { 
                              { 5, 6}, /* Depth, 1, row 0 */
                              { 7, 8}  /* Depth, 0, row 1 */
                           }
                        };

   int r,c,d;
   for(d = 0; d < 2; ++d)
      for(r = 0; r < 2; ++r)
         for(c = 0; c < 2; ++c)
            printf("[d%i][r%i][c%i] == %i\n", d, r, c, array[d][r][c]);

   return 0;
}</pre>
		<p>
			It outputs the following...
		</p>
		<pre>[d0][r0][c0] == 1
[d0][r0][c1] == 2
[d0][r1][c0] == 3
[d0][r1][c1] == 4
[d1][r0][c0] == 5
[d1][r0][c1] == 6
[d1][r1][c0] == 7
[d1][r1][c1] == 8</pre>
		<p>
			So, in C, one have to visualise the inner most brace as being your 
			<em>slowest-incrementing</em> dimension. 
		</p>

		<h4>In Yorick: <code>array(COL, ROW, DEPTH)</code></h4>
		<p>
			So, we can test how Yorick dimensions work. I would assume, given the
			Yorick syntax, Yorick would represent the array above using the
			syntax <code>array(COL, ROW, DEPTH)</code>.
		</p>
		<p>
			And again, to be sure, we make a little noddy program:
		</p>
		<pre>myarray = [
             [
                [ 1, 2], /* Depth, 0, row 0 */
                [ 3, 4]  /* Depth, 0, row 1 */
             ],
             [ 
                [ 5, 6], /* Depth, 1, row 0 */
                [ 7, 8]  /* Depth, 0, row 1 */
             ]
          ];

for (d=1; d<3; ++d)
   for (r=1; r<3; ++r)
      for (c=1; c<3; ++c)
         print, swrite(format="[d%i][r%i][c%i] == %i", d-1, r-1, c-1, myarray(c, r, d))
		</pre>
		<p>
		And, this outputs exactly the same as our little C program (the 
		<code>d/r/c-1</code> in the <code>swrite()</code> function is so that 
		we print out the indexing from zero, as the C program would have done).
		This shows that our intuitive understanding of the syntax works for
		adding extra dimensions to arrays in Yorick is correct...
		</p>

		<h3>Array Indexing</h3>
		<div>
			<p>
				The <a href="http://dhmunro.github.io/yorick-doc/manual/yorick_37.html#Indexing"
					target="_blank">Yorick docs on this pretty much explain everything</a> but the
				Yorick equivalent of &quot;fancy&quot; indexing on arrays with 2 
				or more dimensions puzzled me for a second... had to think it through
				so here's a graphic :)
			</p>
			<p>
				Lets say we define the following array
			</p>
			<pre class="prettyprint linenums">a = [ [1,2,3], [4,5,6] ]</pre>
			<p>
				This is an array with 3 columns and 2 rows, which we can see
				by using <tt>dimsof()</tt>:
			</p>
			<pre class="prettyprint linenums">&gt; dimsof(a)
[2,3,2]
 ^ ^ ^
 ^ ^ # rows
 ^ ^
 ^ # columns
 ^
 # dimensions</pre>
			<p>
				The array can be indexed as if it were a flat object:
			</p>
			<pre class="prettyprint linenums">&gt; a(1)
1
&gt; a(2)
2
&gt; a(3)
3
&gt; a(4)
4
&gt; a(5)
5
&gt; a(6)
6</pre>
			<p>
				And you can slice it as you might expect:
			</p>
			<pre class="prettyprint linenums">&gt; a(2:3, 1:2)
[[2,3],[5,6]]</pre>

			<p>
				The <a href="http://dhmunro.github.io/yorick-doc/manual/yorick_41.html#Index-List"
					target="_blank">&quot;fancy&quot; indexing</a> took me a second though:
			</p>
			<pre class="prettyprint linenums">&gt; a([2,1],[1,2])
[[2,1],[5,4]]</pre>
			<p>
				The Yorick docs says <q>dimensions from the dimensions of the index list; values from the array
being indexed</q>... which is very true, but I still needed a pretty picture :)
			</p>
			<p>
				The dimensions used in the fancy index will be the dimensions of the
				resulting array. So in the above example the array in the column index
				has 2 elements to the resulting array will have 2 columns. The array
				in the row index as 2 elements so the resulting array will have 2 rows.
				Therefore we know the result is a 2-by-2 array.
			</p>
			<p>
				Now for the values. TODO
			</p>
		</div>

		<h3>Slices Are Views Onto Arrays But Beware Of Array Copy</h3>
		<div>
			<p>
				In <a href="python/numpy.html">Python's NumPy</a>, slices are like views into the array, and this
				is also the case in Yorick. BUT... if we transliterate the 
				<a href="python/numpy.html#numpy_slice">NumPy example</a> into Yorick 
				script, we will see a different result! See below:
			</p>
			<pre class="prettyprint linenums">&gt; a = [1,2,3,4,5,6]
&gt; b = a(2:4)
&gt; b
[2,3,4]
&gt; b(:) = 111
&gt; b
[111,111,111]
&gt; a /*&lt;-- LOOK: Unlike the NumPy example, a has not been affected! */
[1,2,3,4,5,6]</pre>
			<p>
			In the  <a href="python/numpy.html">Python NumPy</a> example a would have been effected. Now, it's not quite
				that the slice isn't a view. It still is. Observe the following.
			</p>
			<pre class="prettyprint linenums">&gt; a(2:4) = 111
&gt; a
[1,111,111,111,5,6] /*&lt; Aha! the slice is a view into the array */</pre>
			<p>
				So, the slice is in fact a view into the array. The caveat is that
				in Yorick when we did <tt>b = a(...whatever...)</tt>, <tt>b</tt>
				will be a <em>copy of</em> and not a reference to the array (slice).
				This can be quite an expensive operation so beware!
			</p>
			<p>
				<div class="box_container"><div class="info">
					<p>
						In Python's NumPy assigning one array (or non primitive) variable to 
						another copies a <em>reference</em> and not the value. In
						Yorick however, in the specific case of array = array, the
						<em>entire array is copied</em>... Beware of this as for 
						large arrays this can get expensive!
					</p>
				</div></div>
			</p>
			<p>
				The Yorick manual entry for 
				<a href="http://dhmunro.github.io/yorick-doc/stdlib/std-advanced.html#eq_nocopy" target="_blank">
				eq_nocopy()</a> says that <q>having multiple variables
				reference the same data can be confusing, which is why the default
				&quot;<tt>=</tt>&quot; operation copies the array.</q>
			</p>
			<p>
				To copy an an array <em>by reference</em> use 
				<a href="http://dhmunro.github.io/yorick-doc/stdlib/std-advanced.html#eq_nocopy" target="_blank">
				eq_nocopy()</a>. Note, however, that you can only do this for the 
				entire array, not slices. Munro <a href="https://github.com/dhmunro/yorick/issues/16" target="_blank">
				explains this here</a>: <q>...Unlike NumPy, Yorick does not have any way to refer to
				a slice of an object. All slicing operations happen immediately and result in a 
				temporary array...</q>. Munro discusses it further in the 
			<a href="http://yorick.sourceforge.net/yorickfaq.php#Q43" target="_blank">FAQ</a>.
			</p>
			<p>
				<div class="box_container"><div class="info">
					<p>
						All slicing operations happen immediately and result in a temporary
						array (i.e., a <em>copy-by-value</em>).
					</p>
				</div></div>
			</p>

		</div> <!-- END H3: Slices Are Not Like NumPy Slices -->

		<h3>When Arrays Are Not Copied By Value</h3>
		<div>
			<h4>Arrays Passed To Functions By Reference</h4>
			<div>
				<p>
					Arrays are passed to functions by reference in the sense that if you modify the array in
					the function, the caller's array is modified...
				</p>
				<pre class="prettyprint linenums">&gt; y = [1,2,3,4]
&gt; func cheeseit(x) {
    x(1) = 9999 /*&lt;-- NOTE: Will change array in caller's scope */
  }
&gt; cheeseit(y)
&gt; y /*&lt;-- NOTE: y has been changed by function */
[9999,2,3,4]</pre>
				<p>
					For a pass-by-copy kind of semantic, do the following, but note copying an array will
					be expensive if this is a large array!
				</p>
				<pre class="prettyprint linenums">&gt; y = [1,2,3,4]
&gt; func cheeseit(x) {
    x_local = x;       /*&lt;-- x is <em>copied</em> to x_local, but copy is <em>EXPENSIVE</em>! */
    x_local(1) = 9999; /*&lt;-- Changes to x_local will NOT affect array in caller's scope */
}
&gt; cheeseit(y)
&gt; y /*&lt;-- NOTE: y is NOT changed by the function */
[1,2,3,4]</pre>
			</div> <!-- END H4: Arrays Passed To Functions By Reference -->

			<h4>OXY Objects Store References</h4>
			<div>
				<p>
					Above we just saw that when copying an entire array, or a slice
					of an array, the copy is done by value and not by reference. There
					is a caveat however... when assigning an array belonging to an OXY
					object to another OXY object, a reference to the array is copied.
					The array is <em>not</em> copied by value in this instance!
				</p>
				<pre class="prettyprint linenums">&gt; a = save(q=[1,2,3,4])
&gt; b = save(q=a.q) /* b's copy of a.q is a reference to a.q. unlike bare
&gt; a.q              * array-to-array copy, which is by value, this copy is
[1,2,3,4]         * by reference! */
&gt; b.q
[1,2,3,4]
&gt; a.q(1)=999
&gt; a.q
[999,2,3,4]
&gt; b.q
[999,2,3,4]          /* LOOK! b.q must be a <em>reference</em> to a.q! */</pre>
				<p>
					This is not just true of copying OXY members between objects.
					If <tt>a.q</tt> is replaced by a vanilla array (just normal
					variable and not an OXY object), the result is the same! Note, 
					however, that assigning from an OXY object array member to a
					normal variable is a copy-by-value.
				</p>
			</div> <!-- H4: OY Objects -->
		</div> <!-- END H3: When Arrays Are Not Copied By Value (OXY Objects) -->


		<a name="broadcasting"><h3>Broadcasting</h3></a>
		<p>
			Yorick, being a nicely vectorised language, lets you do mathematical 
			operations between scalars and arrays, and arrays and arrays. The only
			condition is that the arrays are what is called <em>&quot;conformable&quot;</em>.
		</p>
			Two operands are conformable if the dimensions which they share in 
			common have the same length. This means that if we have two operands,
			<tt>A</tt> and <tt>B</tt>, where <tt>A</tt> has the smaller rank,
			that <tt>dimsof(A)(2:) == dimsof(B)(-dimsof(A)(1)+1:)</tt>. Eek! That's
			a little horrid right?! It just expresses that the dimensions shared in
			common have the same length.
		</p>
		<p>
			Try thinking of it this way: if you can create the array <tt>B</tt> by
			joining together a load of <tt>A</tt> arrays then they will be
			conformable because the dimensions they share in common must be of
			equal length as <tt>B</tt> is just made up of many <tt>A</tt>'s.
			The image below is meant to make that a little more clear...
		</p>
		<p>
			<img src="##IMG_DIR##/yorick_broadcast.png" alt="Image showing how arrays of shorter dimensions can broadcast to arrays of larger dimensions in Yorick"/>
		</p>
		<p>
			The image is trying to show that, as the manual says, the shorter 
			operand repeats its values for every dimension that is does not have.
			This is what is called <em>broadcasting</em>.
		</p>
		<p>
			As a little side note, it appears that Yorick actually created the 
			term broadcasting, to the extent that it 
			<a href="http://stackoverflow.com/questions/26948776/where-did-the-term-broadcasting-come-from/26950256#26950256" target="_blank">
			inspired Python's NumPy broadcasting</a>... wowzers!
		</p>
		<p>
			We can see that because, for example, the 2D array is made up of
			two 1D arrays, the 1D array can be multiplied, added, etc with the
			2D array by &quot;expanding&quot; into a 2D array by repeating 
			itself in the second dimension so that it has the same shape. The
			same goes for 1D <tt>op</tt> 3D or 2D <tt>op</tt> 3D in the above 
			example. 
		</p>
		<p>
			Let's see this in practice...
		</p>
		<pre class="prettyprint linenums"> Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; a = [1,2]
&gt; b = [a,a]
&gt; c = [b,b,b]
&gt; a
[1,2]
&gt; b
[[1,2],[1,2]]
&gt; c
[[[1,2],[1,2]],[[1,2],[1,2]],[[1,2],[1,2]]]
&gt;
&gt; a+b 
[[2,4],[2,4]]
&gt;
&gt; a+c
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]
&gt; c+a
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]
&gt;
&gt; b+c
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]
&gt; c+b
[[[2,4],[2,4]],[[2,4],[2,4]],[[2,4],[2,4]]]</pre>
		<p>
			As per our little image above... the arrays are conformable and so
			can be operands to the normal mathematical operations. BUT... the above 
			does not give the whole story. &quot;In common&quot; can be more 
			flexible. For example, we can do the following...
		</p>
		<pre class="prettyprint linenums">&gt; aa = [1]
&gt;
&gt; dimsof(aa)
[1,1]
&gt; dimsof(b)
[2,2,2]
&gt;
&gt; aa + b
[[2,3],[2,3]]
&gt; aa + c
[[[2,3],[2,3]],[[2,3],[2,3]],[[2,3],[2,3]]]
&gt; bb = [[1], [1]]
&gt; bb+c
[[[2,3],[2,3]],[[2,3],[2,3]],[[2,3],[2,3]]]
		</pre>
		<p>
			Now, given the above definition, one might thing that the common 
			dimension between <tt>aa</tt> and <tt>b</tt> does not have the same
			length, yet they are clearly conformable as far as the Yorick 
			interpreter is concerned. What's going on?
		</p>
		<p>
			The reason that this works is that <q>Yorick will broadcast any 
			unit-length dimension in addition to a missing final dimension</q>.
		</p>
		<p>
			Therefore, pictorially, we can see the following...
		</p>
		<p>
			<img src="##IMG_DIR##/yorick_boardcast_unit_dim.png" alt="Image showing how Yorick can conform unit-length dimensions"/>
		</p>
		<p>
			So far we seem to have the following definition... 
			<div class="box_container"><div class="info">
				<p>
					Yorick operands are conformable if the dimensions they share in
					common have exactly the same length or the shared dimensions in the &quot;smaller&quot;
					operand that are not the same length as in the other are unit length.
				</p>
			</div></div>
		</p>
		<p>
			One does have to take a little care in what is understood by 
			&quot;dimensions in common&quot;, however. This might appear obvious
			to you, but I had to do a double take...
		</p>
		<pre class="prettyprint linenums">&gt; a = [1,2]
&gt; dimsof(a)
[1,2]
&gt; b = [[7,8,9,0],[6,5,4,3]]
&gt; dimsof(b)
[2,4,2]
&gt; a+b
ERROR (*main*) operands not conformable in binary +
WARNING source code unavailable (try dbdis function)</pre>
		<p> 
			If we look at the dimensions with the following formatting we might
			be fooled into thinking that <tt>a</tt> and <tt>b</tt> share a
			common dimension of exactly the same length, and therefore should
			be conformable.
		</p>
		<pre>
/* Caution: This is an INcorrect grouping of the dimsof result */
                +++
dim_a =    [ 1, |2| ]
dim_b = [ 2, 4, |2| ]
                +++</pre>
		<p>
			Remember that because Yorick is column major the <tt>dimsof</tt>
			array has the format <tt>[2, cols, rows]</tt>!
			Writing out the dimensions as I have above is quite misleading, and 
			the mistake I at first made, because <tt>a</tt> has
			2 <em>columns</em> and <tt>b</tt> has 2 <em>rows</em> and 
			<em>4 columns</em>. They are therefore <em>NOT</em> conformable.
			Remember to group your dimensions correctly:
		</p>
		<pre>
/* This is the right way! */
             +++
dim_a = [ 1, |2| ]
dim_b = [ 2, |4|, 2 ]
             +++</pre>

		<h3>Pseudo Index</h3>
		<p>
			The Yorick manual example starts with the <a href="http://en.wikipedia.org/wiki/Outer_product"
			target="_blank">outer product</a> of two vectors. The following is taken from the
			linked-to Wikipedia article...
		</p>
		<p>
			Assume that there are two column vectors $u$ and $v$.
		</p>
		<p>
			$u = \begin{pmatrix}
			u1 \\
			u2 \\
			u3 \\
			u4
			\end{pmatrix}$

			and 

			$v = \begin{pmatrix}
			v1 \\ 
			v2 \\ 
			v3 
			\end{pmatrix}$
		</p>
		<p>
			The outer product of the two column vectors is defined as follows...
		</p>
		<p>
			$u \otimes v = uv^T = $
			$\begin{pmatrix}
			u_1 \\
			u_2 \\
			u_3 \\
			u_4 \\
			\end{pmatrix}$
			$\begin{pmatrix}
			v_1 & v_2 & v_3 \\
			\end{pmatrix} = $
			$\begin{pmatrix}
			u_1v_1 & u_1v_2 & u_1v_3 \\
			u_2v_1 & u_2v_2 & u_2v_3 \\
			u_3v_1 & u_3v_2 & u_3v_3 \\
			u_4v_1 & u_4v_2 & u_4v_3 \\
			\end{pmatrix}$
		</p>
		<p>
			The matrix multiplication of those two vectors puzzled me for a little
			bit (I've only ever been used to multiplying matrices with dimension
			sizes greater than 1). It may be easier to think of it as follows...
		</p>
		<p>
			$\begin{pmatrix}
			u_1 \\
			u_2 \\
			u_3 \\
			u_4 \\
			\end{pmatrix}$
			$\begin{pmatrix}
			v_1 & v_2 & v_3 \\
			\end{pmatrix} \equiv $

			$\begin{pmatrix}
			u_1 & 0\\
			u_2 & 0\\
			u_3 & 0\\
			u_4 & 0\\
			\end{pmatrix}$

			$\begin{pmatrix}
			v_1 & v_2 & v_3 \\
			0 & 0 & 0
			\end{pmatrix}$
		</p>
		<p>
		How do we do this using Yorick? <b>All one dimension vectors in Yorick
			are column vectors</b> (even if they are displayed textually as-if they
			are a row!). So can we just <tt>transpose()</tt> the $v$ vector?
		</p>
		<pre class="prettyprint linenums">&gt; a * transpose(b)
ERROR (*main*) operands not conformable in binary *
WARNING source code unavailable (try dbdis function)
&gt; transpose(b)
[100,200,300]
&gt; dimsof(transpose(b))
[1,3]</pre>
		<p>
			Apparently not! <tt>transpose(b)</tt> didn't do what it might have... I 
			thought it would turn the column vector into a row vector, but it doesn't.
			The reason for this is that a row vector is actually a 2D array, i.e.,
			it has an <em>extra dimension</em>. 
		</p>
		<p>
			And this makes sense... as we saw in our section on adding extra
			dimensions to arrays and how to syntactically express this:
			we know a 1D vector is <code>array(col)</code> and a 2D vector is 
			<code>array(col, row)</code>. Thus, is makes sense that a <b>row vector
				is a 2D array with one column!</b>
		</p>
		<p>
			So, to convert $v$ into a row vector 
			we need to <b>add an extra dimension</b>...
		</p>
		<p>
			To convert $v$ into a row vector we need to make each column element
			it's own row in a 2D vector. If $v$ has 3 columns, $v^T$ has 3 rows,
			where each row has only one element. To do this in Yorick, as said, 
			we need an extra dimension... enter the <em>pseudo index</em>...
		</p>
		<pre class="prettyprint linenums">&gt; b
[100,200,300]
&gt; b(-,)
[[100],[200],[300]]
&gt; b(,-)
[[100,200,300]]</pre>
		<p>
			The syntax <tt>(-,)</tt>, really the symbol &quot;<tt>-</tt>&quot;, is
			the <b>pseudo index</b>. &quot;<tt>-</tt>&quot; means &quot;add an extra dimension
			here&quot;. 
		</p>
		<p>
			Munro calls <q>the - sign, when used as an index, a 
			<b>pseudo-index because it actually inserts an additional dimension into 
			the result[ing] array</b> which was not present in the array being indexed</q>.
			And, as we noted above, to go from a column vector to a row vector (i.e, transpose
			the column vector) we need to increase the dimensionality of our array.
		</p>
		<p>
			So, based on this, we can say that <tt>b(-,)</tt> is saying add a row
			dimension to the column vector, or more generally add another
			most-slowly-increasing dimension to the existing vector. In
			the example above we get a 2D vector with 3 rows and 1 column.
		</p>
		<p>
			How the extra dimension is added is both interesting and important.
			If <tt>b(-,)</tt> is saying add a row dimension, why does 
			<tt>b(,-) == [[100],[200],[300]]</tt> and not 
			<tt>[[100,200,300]]</tt>? They both have a row dimension added!
		</p>
		<p>
			I think of it in the following way. Remembering that Yorick is column
			major, anything to the left of the &quot;<tt>,</tt>&quot; in
			<tt>(,)</tt> indicates a faster dimension and anything to the right a
			slower dimension. Therefore, <tt>(-,)</tt> is saying add a faster
			dimension and <tt>(,-)</tt> is saying add a slower dimension... and this kinda works...
		</p>
		<p>
			This generalises... suppose we can <tt>c</tt> a two dimensional array 
			and we write <tt>c(-,)</tt>.
		</p>
		<pre class="prettyprint linenums">
&gt; c = [[1,2,3],[4,5,6]]
&gt; c
[[1,2,3],[4,5,6]]
&gt; c(-,)
[[[1],[2],[3]],[[4],[5],[6]]]

/* 
 * c hand-formatted is...
 *    [
 *       [ 1,  2,  3],
 *       [ 4,  5,  6]
 *    ]    |   |   |
 *         |   |   |
 * c(-,) hand-formatted is...
 *    [    |   |   |
 *       [[1],[2],[3]],
 *       [[4],[5],[6]]
 *    ]
 */
</pre>
	<p>
		To add the extra dimension, each column element becomes a row with one
		column, and therefore the rows become depths. <b>More generally it is like
			we shift the dimensions up one...</b> The fastest increasing dimension is changed
		so that each individual element inside it is now the fastest increasing
		dimension and all the containing dimensions become one slower! Ie., we've added
		a new fastest dimension.
	</p>
	<p>
		Now we can look at  <tt>b(,-)</tt> .
		Given the discussion so far it looks like we are saying add a column 
		dimension. We have
		seen that <tt>b(,-) == [[100,200,300]]</tt>. And this also makes sense...
		we've added a new slowest dimension.
	</p>
	<p>
		<img src="##IMG_DIR##/yorick_pseudo_index.jpg"/>
	</p>
	<p>
		So back to the original example of outer product. To accomplish this in
		Yorick we need to do <tt><b>transpose(</b>u*v(-,)<b>)</b></tt> I.e., the transpose of <tt>v</tt>
		is <tt>v(-,)</tt>:
	</p>
	<pre class="prettyprint linenums">&gt; u = [1,2,3,4]
&gt; v = [1, 10, 100]

&gt; v(-,)
[[1],[10],[100]]

&gt; u * v(-,) /* This won't be quite right! */
[ [  1,   2,   3,   4],
  [ 10,  20,  30,  40],
  [100, 200, 300, 400] ]

<b>&gt; transpose(u*v(-,)) /* YAY, now we're good! */</b>
[ [1, 10, 100],
  [2, 20, 200],
  [3, 30, 300],
  [4, 40, 400] ]
</pre>

		<h3>Matrix Multiplication &amp; Inner Product</h3>
		<p>
			Remember to keep in mind that
			Yorick is column-major so the indices are <tt>a(col, row)</tt>!
		</p>
		<p>
			The concept of matrix multiplication, the type we learnt in school, is
			shown in the little animation below. For each <i>row</i> vector of the LHS matrix
			we take the <a href="https://en.wikipedia.org/wiki/Dot_product" target="_blank">dot product</a> 
			of that vector with each <i>column</i> vector from the RHS matrix to produce the result:
		</p>

		<iframe src="yorick_matrix_anim.html" style="width:660px; height:270px; border:0px;">
		</iframe>

		<p>
			In Yorick the <a href="http://dhmunro.github.io/yorick-doc/manual/yorick_45.html#Matrix-Multiply"
				target="_blank">'<tt>+</tt>' sign</a> labels an array index for use
			in the <a href="https://en.wikipedia.org/wiki/Dot_product" target="_blank">dot product</a>
			(a.k.a. inner product or scalar product) and can be used to calculate vector 
			inner products or matrix multiplications. Munro has generalised the &quot;school-learnt&quot; matrix multiplication concept
			so that we are not constrained as to the choice of row/column vectors we take from the LHS and RHS. For example, we might want to take the dot product of column vectors from the LHS and column vectors from the RHS.
		</p>

		<p>
			For two 1D arrays, <tt>a</tt> and <tt>b</tt>, the operation is fairly 
			straight forward. Writing <tt>a(+)</tt> and <tt>b(+)</tt> marks the only
			dimension in each array as being used for the inner product. Therefore,
			the calculation becomes $\Sigma a(i)b(i)$. Let's take a look at this
			pictorially, otherwise the 2D example melts my brain a little...
		</p>

		<p>
			<img src="##IMG_DIR##/single_dim_inner_prod.png" style="margin:10px;"/>
		</p>

		<p>
			Now we move on to the more complex examples... as always, remember to
			keep in mind that Yorick is column-major, so the indices are 
			<tt>M(col, row)</tt>.
		</p>

		<h4>LHS column vectors and RHS row vectors</h4>
		<p>
			<img src="##IMG_DIR##/dot_product_yorick_1.png" style="margin:10px;"/>
		</p>

		<p>
			I feel like the above needs a little explanation before continuing with
			the others. 
		</p>
		<p>
			Munro describes the plus symbol as &quot;marking an index for use in an inner product&quot;. 
			But what exactly do we mean? It means that the index used is the one that we iterate over by
			summing the multiplication of each element with it's respective &quot;partner&quot; in the
			dot product. Thus <tt>a(, +)</tt> means iterate over the row indices in the dot product
			summation. If we are iterating over the row index, then the column index must remain
			constant, so we will be taking column vectors.
		</p>
		<p>
			To understand
			what the + sign means we could think of it as meaning &quot;selecting 
			the dimension to be iterated over in the summation of the inner product&quot;,
			because what the above does is to select all dimensions not marked by a + sign, and then iterate over the
			marked dimension marked for the inner product. 
		</p>
		<p>
			So, if the + sign marks rows, we are NOT selecting row vectors and then using the row vector for the inner product. We ARE selecting column
			vectors and using the rows from each column vector in the inner product. The same is also happening with respect
			to <code>b(+,)</code>: we are selecting rows and iterating over the columns. 
		</p>
		<p>
			<b>I.e., for the + sign we select the vectors in the other dimensions and iterate over the marked dimension in those selected vectors.</b>
		</p>
		<div class="box_container"><div class="info">
				<p>
					Munro describes the plus symbol as &quot;marking an index for use in an inner product&quot;. I prefer 
					to think of it as  &quot;selecting the dimension to be iterated over in the summation of the inner product&quot;.
					<br>
					<b>I.e., for the + sign we select the vectors in the other dimensions and 
						iterate over the marked dimension in those selected vectors.</b>
				</p>
		</div></div>
		<p>
			So, now we can continue looking at the other possible ways to multiply out
			these square matrices...
		</p>

		<h4>LHS column vectors and RHS column vectors</h4>
		<p><img src="##IMG_DIR##/dot_product_yorick_2.png" style="margin:10px;"/></p>

		<h4>LHS row vectors and RHS row vectors</h4>
		<p><img src="##IMG_DIR##/dot_product_yorick_4.png" style="margin:10px;"/></p>

		<h4>LHS row vectors and RHS column vectors</h4>
		<p><img src="##IMG_DIR##/dot_product_yorick_3.png" style="margin:10px;"/></p>

		<p>
			We can see from the above that the index marked with the <tt>+</tt> 
			sign is used for the inner product. Note that all these combinations 
			are only possible because the matrices are square (for rectangular 
			matrices, normal matrix multiplication shapes apply).
		</p>
		<p>
			For example, in the pictures above, <tt>a(,+)</tt> marks the <em>row</em>
			index as being used for the inner product. I.e by selecting all rows in 
			each column we create the vectors being used on the LHS of the dot 
			product. Therefore we select <tt>a(1,:)</tt>, <tt>a(2,:)</tt>
			all the way through to <tt>a(n,:)</tt>.
		</p>
		<p>
			Therefore, the indices marked 
			with the <tt>+</tt> sign <em>must have the same length</em>. 
		</p>
		<p>
			<div class="box_container"><div class="info">
				<p>
					Indices marked with the <tt>+</tt> sign <em>must have the same 
					length</em>.
				</p>
			</div></div>
		</p>
		<p>
			Lets say <tt>dimsof(a) = (2, n, m)</tt> and <tt>dimsof(b) = (2, m, l)</tt>.
			The process for <tt>c = a(,+)*b(+,)</tt> becomes:
		</p>
		<pre>for i in 1..n 
   v1 = a(i, :) // 1d vector, length m
   for j in 1..l
      v2 = b(:, j) // 1d vector, length m
      r(i,j)  = v1(+) * v2(+)</pre> 

		<h4>Normal or &quot;School-Learnt&quot; Matrix Multiplication vs Yorick</h4>
		<p>
			The only matrix multiplication I was ever taught was &quot;normal&quot;
			matrix multiplication:
		</p>
		<p>
			$$\begin{pmatrix}
			a(1,1) & a(2,1)\\
			a(1,2) & a(2,2)\\
			\end{pmatrix}
			\begin{pmatrix}
			b(1,1) & b(2,1)\\
			b(1,2) & b(2,2)\\
			\end{pmatrix} = $$
			$$\begin{pmatrix}
			a(1,1)b(1,1) + a(2,1)b(1,2) & a(1,1)b(2,1) + a(2,1)b(2,2)\\
			a(1,2)b(1,1) + a(2,2)b(1,2) & a(1,2)b(2,1) + a(2,2)b(2,2)\\
			\end{pmatrix} = $$
			$$\begin{pmatrix}
			a(:,1)b(1,:) & a(:,1)b(2,:)\\
			a(:,2)b(1,:) & a(:,2)b(2,:)\\
			\end{pmatrix}$$
		</p>

		<p>
			What you might notice is that the way the matrix multiplication works
			in Yorick, as described above, the index of the RHS changes most
			quickly. In &quot;normal&quot; matrix multiplication, it is the LHS
			index that is changing most quickly. 
			
		</p>
		<p>
			The figure below compares the closest operation we've seen so far with
			what I'd think of as a &quot;normal&quot; matrix multiplication...
		</p>
		<p>
			<img src="##IMG_DIR##/dot_product_normal.png" style="margin:10px;"/>
		</p>
		<p>
		Visually we can see that <b><tt>transpose(a(+,)*b(,+))</tt> is equivalent
			to the &quot;normal&quot; matrix multiplication</b>.
		</p>

		<iframe src="yorick_matrix_anim_2.html" style="width:660px; height:270px; border:0px;">
		</iframe>

		<p>
			Another way to do this is to note that...
			$$\begin{pmatrix}
			a(:,1)b(1,:) & a(:,1)b(2,:)\\
			a(:,2)b(1,:) & a(:,2)b(2,:)\\
			\end{pmatrix} \equiv 
			\begin{pmatrix}
			b(1,:)a(:,1) & b(2,:)a(:,1)\\
			b(1,:)a(:,2) & b(2,:)a(:,2)\\
			\end{pmatrix}$$
		</p>
		<p>
			Therefore, to accomplish this &quot;normal&quot; matrix multiplication
			between <tt>a</tt> and <tt>b</tt>, in Yorick we would write
			<tt>b(,+) * a(+,)</tt> to do the &quot;normal&quot; matrix 
			multiplication <tt>AB</tt>.
		</p>
		<p>
			<div class="box_container"><div class="info">
				<p>
					<tt>transpose(a(+,)*b(,+))</tt> is equivalent
				to the &quot;normal&quot; matrix multiplication.
				</p>
			</div></div>
		</p>
		<p>
			As we've noted, all these combinations above are only possible because 
			the matrices are square. Remember that the indices marked for inner
			product must share the same length. If, for example <tt>a</tt> has
			3 rows and 2 columns and <tt>b</tt> had 8 rows and 2 columns, the 
			only possible operation would be <tt>a(+,)*b(,+)</tt>.
		</p>

		<h4>An Example With SVsolve</h4>
		<p>
			The function <tt>SVsolve</tt> can be used to solve sets of simultaneous
			linear equations. Let's say that we have two arrays. Array <tt>a</tt>
			will represent the coefficients of the unknowns in our set of equations.
			Lets say that that we have <tt>n</tt> unknowns and <tt>m</tt> 
			equations. The array <tt>a</tt> is an <tt>n x m</tt> matrix. Our linear
			equations, as we would normally write them (i.e., as I was taught in
			school) therefore look like this:
		</p>
		<p>
			<img src="##IMG_DIR##/solve_linear_equations_norm.png" style="margin:10px;"/>
		</p>
		<p>
			So if I were to pass the coefficient matrix (2D array) and the result
			vector (1D array) to <tt>SVsolve</tt> everything will work fine right?
			Err... no! Doh! Why not? It comes back to the issue
			above... the matrix multiplication is (at least for me) slightly
			unintuitive (probably just me!).
		</p>
		<p>
			<tt>SVsolve()</tt> solves for <tt>A(,+)*x(+) = B</tt>. As we've seen,
			<tt>A(,+)</tt> will multiply the <em>columns</em> of <tt>A</tt> with 
			<tt>x(+)</tt>. Oops: <tt>SVsolve()</tt> is trying to do this:
		</p>
		<p>
			<img src="##IMG_DIR##/solve_linear_equations_oops.png" style="margin:10px;"/>
		</p>
		<p>
			So, the solution is to <tt>transpose()</tt> the array you are using
			before passing it to <tt>SVsolve()</tt>!
		</p>


			

			

		<h3>Rubber Indices In Yorick</h3>
		<p>
			<q>Yorick has one other indexing syntax which has proven useful, which I
				call <em>rubber indices</em>.  They address the problem of writing
			interpreted code which extracts slices of arrays when you don't know
			beforehand how many dimensions the array has.  An example is an
			opacity array for which you know that the most slowly varying index
			represents photon wavelength, but there might be zero, one, two, or
			three faster varying dimensions representing position in space.</q> -- 
			<a href="https://mail.python.org/pipermail/matrix-sig/1995-November/000142.html" target="_blank">
			PYTHON MATRIX-SIG</a>
		</p>
		<div>
			<pre class="prettyprint linenums">
&gt; a = [ [    [1,2,3], 
             [4,5,6]
        ],[
             [11, 22, 33], 
             [44,55,66]
      ] ]
&gt; a
[[[1,2,3],[4,5,6]],[[11,22,33],[44,55,66]]]
&gt; a(1)
1
&gt; a(1,1,1)  ## Give me the first element in the inner array, from 1st array 
1           ## in the middle array, from the first array (of arrays) from the 
            ## outer array

&gt; a(1,:)    ## Give me the first element in each inner array, contained in the
[1,4]       ## same parent array. This is a little incorrect because we don’t
            ## specify all array dimensions in the indices

&gt; a(1,:,:)      ## Give me the first element in each inner array, from each 
[[1,4],[11,44]] ## outer array, contained in the overall array

&gt; a(1,..)       ## The RUBBER INDEX says the same thing: Give me the first
[[1,4],[11,44]] ## element from the innermost array and do the same recursing
                ## outwards

&gt; a(1,*)        ## Another RUBBER INDEX that collapses all arrays into one.
[1,4,11,44]

&gt; a(:,1,1)      ## Give me everything from the first array, i.e., the array
[1,2,3]         ## itself, from the element in the middle array from the first
                ## element in the outer array.

&gt; a(:,1,..)           ## Give me everything from the first array, ie. the
[[1,2,3],[11,22,33]]  ## array itself, from the first element in the middle
                      ## array from all elements in the outermost array.</pre>
			<img src="##IMG_DIR##/YorickRubberIndex.png"/>
		</div> <!-- END H3: Rubber Indices In Yorick -->
	</div> <!-- END H2: Yorick Arrays -->

	<!-- YORICK OXY OBJECTS ------------------------------------------------ -->
	<h2>Oxy Objects</h2>
	<div>
		<h3>Copying Oxy Objects</h3>
		<p>
			When you assigned an OXY object from one variable to another is is <em>copied by reference</em>.
			Thus changing an object member will be reflected in both variables as <em>assignment is not copy</em>
			for OXY objects.
		</p>
	
		<pre class="prettyprint linenums">&gt; a = save(q = 123)
&gt; a.q
123
&gt; b = a
&gt; save, a, q=321 /*&lt;--  Changing a's member variable will change b's! */
&gt; a.q 
321
&gt; b.q 
321              /*&lt;-- LOOK, b has been affected by the change to a! */</pre>
	
		<p>
			Given the rational behind Yorick as a number cruncher, this makes a lot of sense. It's a little like passing an array into
			a function. If we think as an OXY object as a potential &quot;bag&quot; of large data, copying it would be hugely expensive, so that is why an object
			assignment is NOT a copy!
		</p>
		<p>
			To actually make a real copy of the object you have to manually copy each member of one object to the other.
		</p>
		<pre class="prettyprint linenums">&gt; a = save(q=101)
&gt; b = save()     /*&lt;-- Must manually re-create a new... */
&gt; save, b, q=a.q /*    ...object if we are to copy a */
&gt; a
object [1]: group
&gt; a.q
101
&gt; b.q
101
&gt; save, a, q=999
&gt; a.q
999
&gt; b.q
101              /*&lt;-- Changing a.q has not affected b.q. We did a proper copy!</pre>
		<p>
			BUT, this is further complicated by arrays as member variables and OXY objects as
			member variables. For example, examine the following.
		</p>
		<pre class="prettyprint linenums">&gt; a = save(q=[1,2,3])        
&gt; b = save()
&gt; save, b, q=a.q
&gt; b.q
[1,2,3]
&gt; a.q
[1,2,3]
&gt; a.q(1) = 111
&gt; a.q
[111,2,3]
&gt; b.q
[111,2,3]</pre>
		<p>
			In the above example we used the same recipe as above, but because <tt>q</tt> is now an array
			the reference to the array is copied and not the value. Again, make sense for Yorick as a
			number cruncher of large data arrays, but if you wanted a copy, this could throw you. The same
			copy-of-reference problem would occur if <tt>q</tt> has been another OXY object.
		</p>
		<p>
			You make have done a double-take here because previously, when describing arrays,
			we said array assignment copies the array <em>values</em>, i.e. a complete copy of the array
			is made. This is clearly not the case when saving an OXY object member as an
			array. OXY object members appear always to be references unless the member stores
			a non-array primitive.
		</p>
		<p>
			<div class="box_container"><div class="info">
				<p>
					OXY object members appear always to be references unless the member stores
					a non-array primitive. Be cautious, when setting an OXY object 
					member to equal an array: remember, unlike vanilla array to array copy, the OXY object member stores a 
					<em>reference</em> to the assignee!
				</p>
			</div></div>
		</p>
		<p>
			If you want to copy an array &quot;into&quot; an OXY object (actually create a nameless
			array and assign the reference to the OXY object member), use <em>array slicing</em> and
			take, if you want the entire array, a slice of the entire array:
		</p>
		<pre class="prettyprint linenums">
&gt; a = [1,2,3]
&gt; b = save(a=a(:)) # By taking a slice of the entire array we force a copy.
&gt; b.a              # Slicing operations happen immediately and result in a 
[1,2,3]            # temporary array, the reference to which is then stored
&gt; a                # in the OXY object member.
[1,2,3]
&gt; a(1)=99
&gt; a
[99,2,3]
&gt; b.a
[1,2,3]</pre>
		<p>
			To fully, deep copy, an OXY object your therefore have to build a new object from scratch,
			and copy in all primitive types and then recursively copy in all member OXY objects and also
			take care to copy the arrays correctly.
		</p>
	</div>  <!-- END "Oxy Objects" H2 Div -->

	<!-- YORICK NAMESPACES ------------------------------------------------- -->
	<h2>Yorick &quot;Namespaces&quot;</h2>
	<div>
		<p>
			If you are writing a lot of Yorick scripts that get included in 
			other scripts etc etc, you can end up with a lot of variable and
			function names in the global scope... this can lead to global namespace
			pollution.
		</p>
		<p>
			You can create a kind-of namespace in Yorick. There is no &quot;namespace&quot;
			command but you do have access to <tt>save()</tt> and <tt>restore()</tt> which
			can be used to save a set of variables in an object and restore those variables
			from that object respectively. The general idea is this:
		</p>
		<pre class="prettyprint linenums">/* a and blah are already in the global namespace */
a = 1
func blah(void) { ... }

/* Our script starts here...
 * Now we defined our own namespace that will be accessed through the
 * object my_new_namespace. The save() function saves the variable a and
 * function blah in this object. */
my_new_namespace = save(a, blah)
//{
   /* Here we overwrite the variable a and function blah in the global namespace
    * with these new values */
   a = 101
   func blah(does_something_else) { ... }
//}

/* We restore() the original namespace that existed before we modified it by 
 * swapping the data from my_new_namespace.a and my_new_namespace.blah with
 * their the current values in the global namespace - the ones we just defined.
 * Thus the global namespace appears untouched by our script, and the variables
 * and functions in our script can be accessed using my_new_namespace.xxx.
 */
my_new_namespace = restore(my_new_namespace)</pre>

	<p>
		The are a couple of subtleties to watch out for here and they have to do
		with when statements are evaluated. For example, if you assign from
		one variable in your module's &quot;namespace&quot; to another variable in your
		module's &quot;namespace&quot;, you would <em>not</em> use the namespace prefix
		<tt>my_new_namespace.xxx</tt>. For example:
	</p>

	<pre class="prettyprint linenums">//------------
// my_module.i
//------------
my_new_namespace = save(a, b, blah, blah_oops)
   a = 222
   b = a
   func blah(void) { print, my_new_namespace.a; }
   func blah_oops(void) { print, a; }
my_new_namespace = restore(my_new_namespace)

//------------
// main_program.i
//------------
a = 111
b = 999
func blah(void) { print, a; }

require, "my_module.i"

print, "global a", a
print, "global blah"
blah, []

print, "my_module a", my_new_namespace.a
print, "my_module blah"
my_new_namespace, blah, []
print, "my_module blah_oops"
my_new_namespace, blah_oops, []</pre>

	</div> <!-- END H2:  "Yorick Name Spaces" -->

	<p>
		The program will output the following:
	</p>

<pre>"global a"  111
"global blah"
111
"my_module a"  222
"my_module blah"
222
"my_module blah_oops"
111</pre>

	<p>
		We can see that although <tt>my_module.i</tt> has it's own &quot;global&quot;
		symbols <tt>a</tt>, <tt>b</tt>, <tt>blah</tt> and <tt>blah_oops</tt>, when it is included from
		the main module, it does not effect that module's global scope. Instead
		to access these symbols from <tt>my_module.i</tt> the prefix <tt>my_new_namespace.xxx</tt>
		has to be used.
	</p>
	<p>
		Note the difference between <tt>blah()</tt> and <tt>blah_oops()</tt> in
		<tt>my_module.i</tt>: when the function is called, it is evaluated after
		the <tt>save()</tt>/<tt>restore()</tt> commands, so to access the
		module's &quot;globals&quot; it now has to used the prefix <tt>my_new_namespace.xxx</tt>.
		The function <tt>blah_oops()</tt> represents an error! It does not access the
		module's variable, it accesses the variable from the global scope (if it
		exists - otherwise Yorick will <tt>error</tt> out!).
	</p>
	<p>
		Also note the that <tt>my_module.i</tt> assigns <tt>a</tt> to <tt>b</tt> but
		in this case it is accessing <tt>my_module.i</tt>'s symbol <tt>a</tt>. This
		is because the evaluation of this bit of code is immediate and occurs before
		the <tt>restore()</tt>.
	</p>
	<p>
		Watch out for these subtle little caveats!!
	</p>

	<!-- YORICK WRITING PLUGINS -------------------------------------------- -->
	<h2>Writing Yorick Plug-Ins</h2>
	<div>
		<p>
			Here I cover &quot;manually&quot; writing a plugin, i.e, <em>not</em> using Codger to
			auto-generate the C code using the <tt>PROTOTYPE</tt> Yorick comment method. Most of the
			stuff you need to know in order to do this can be found in 
			<a href="https://github.com/dhmunro/yorick/blob/master/yorick/yapi.h" target="_blank">yapi.h</a> 
			and the source code comments are pretty comprehensive.
		</p>
		<p>
			One point to note about terminology. Whenever I talk about &quot;stack&quot; I will,
			unless made explicitly clear, be talking about the Yorick stack. This is a stack maintained
			by the Yorick interpreter and has nothing to do with your process/thread stack!
		</p>
		<h3>An Intro: Create The Plugin Shell And The Basics</h3>
		<div>
			<h4>Create The Shell</h4>
			<p>
				To create the Yorick makefile, there must be at least one <tt>.i</tt> file available.
				You will most likely also need the equivalent <tt>.c</tt> file. In this example I will
				call the plugin &quot;jehtech&quot;, so I have created the files &quot;<tt>jehtech.i</tt>&quot;
				and &quot;<tt>jehtech.c</tt>&quot;.
			</p>

			<pre class="prettyprint linenums">/*
 * FILE: jehtech.i
 */
plug_in, "jehtech"

extern jehtech_Version;
/* DOCUMENT void jehtech_Version()
 *
 *    Return string describing version of the library
 */</pre>

		<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
#include "yapi.h"
#include "ydata.h"

#ifndef NULL
#define NULL '\0'
#endif

void Y_jehtech_Version(int argc)
{
   ystring_t *verStr = NULL; /* ystring_t is char*, so this is char** */

   /* Push a ystring_t* onto the stack. This is a char** */
   verStr = ypush_q(0);
   if( !verStr )
      y_error("Could not push return string onto stack"); 

   /* p_strcpy is Yorick's mem-managed of strcpy(). Returns char* */
   *verStr = (ystring_t)p_strcpy("v1.0");
}</pre>
 
			<p>
				Once these are created we can create the Makefile for this plugin. From the linux command line:
			</p>

			<pre class="prettyprint linenums"><b>$ yorick -batch make.i</b>
created Makefile
 automatically generated make macros and dependencies:
PKG_NAME=jehtech
PKG_I=jehtech.i
OBJS=jehtech.o
 edit Makefile by hand to provide PKG_DEPLIBS or other changes</pre>
			<p>
				In your working directory you will now have a ready made <tt>Makefile</tt>. Run it by typeing <tt>make all</tt>.
			</p>
			<p>
				In the directory of compilation you will now have the object and library files <tt>jehtech.o</tt> and <tt>jehtech.so</tt>. There
				will also be two new files <tt>ywrap.c</tt> and <tt>ywrap.o</tt>, the object file having been added into the library.
			</p>
			<p>
				Now, from this directory, fire up Yorick to test our little plugin...
			</p>
			<pre class="prettyprint linenums"><b>$ rlwrap yorick</b>
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; jehtech_Version()
"v1.0"</pre>
			<p>
				The function <tt>jehtech_Version()</tt> has correctly returned the version string!
			</p>
			<p>
				So, we kinda just dived into the deep end of the pool here so now to explain what we've done...
			</p>
			<p>
				The example above shows us how to extend Yorick by binding a Yorick function name to a C function.
				There are two component files, the Yorick include file and the C file that implements the functionality.
				This C-implemented functionality will often call upon other libraries that you are in some way wrapping.
			</p>
			<p>
				The Yorick include file so far has two lines of note:
			</p>
			<ol>
				<li>
					<tt>plug_in, "jehtech"</tt><br/>
					This line declares this script file as one that defines a plugin or library. When this file is
					included Yorick will go off and try to find the dynamic library <tt>jehtech.so</tt> and attempt to
					load it.
				</li>
				<li>
					<tt>extern jehtech_Version;</tt></br/>
					Declares a symbol that will be added to the Yorick interpreters list of recognised symbols.
					The magic Yorick binding will associate this symbol with the C function <tt>Y_jehtech_version</tt>.
					Whenever a Yorick script calls the function <tt>jehtech_Version()</tt>, under the hood
					<tt>Y_jehtech_version()</tt> will be called.
				</li>
			</ol>

			<h4>Quick Debug Tip</h4>
			<p>
				If Yorick is complaining that it cannot find a library you can always try setting <tt>export LD_DEBUG=libs</tt>
				before running Yorick (or <tt>export LD_DEBUG=help</tt> to get help). You'll get debug output describing libraries being searched for and
				loaded. You can also set <tt>export LD_DEBUG=all</tt> for an absolute shed-load of debug info, which might be too much, but at least
				you'll be able to see where the loader is searching for libraries and what, if anything, it finds. To clear the
				loader debug output just set <tt>export LD_DEBUG=</tt>.
			</p>
		</div> <!-- END H3 Div -->



		<h3>Passing Values To C Functions From Yorick</h3>
		<div>
			<h4>Parameters Passed On Yorick Stack</h4>
			<p>
				Yorick maintains a parameter stack that it uses to pass values to an interface function (for example <tt>Y_jehtech_version()</tt>) 
				and receive return values. Function parameters are pushed in-order onto the stack and whatever
				is at the top of the stack when the interface function exists, is it's return value.
			</p>
			<p>
				So, if we have a Yorick function with parameters a, b, c, they will be passed to the C interface function 
				on the Yorick stack. At stack position 0 will be c, at position 1, b, and at position 2, a. If the function
				wanted to return the multiple a*b*c it would put the result on the top of the stack, at position 0, to return
				this value to the Yorick interpreter.
			</p>
			<p>
				All interface functions will have the same return value, <tt>void</tt>, and the same parameter list, consisting
				of one integer, usually called <tt>argc</tt>, which gives the number of parameters pushed onto the stack 
				(note I mean the <em>Yorick stack</em> and *not* the C stack!).
			</p>
			<pre class="prettyprint linenums">void Y_functionName(int argc) {
   /* argc gives the number of elements pushed onto the **Yorick** stack. 
    * Note this has nothing to do with the C stack! */
   ... 
   /* Anything left or placed on the top of the **Yorick** stack is the
    * function's return value */
}</pre>
			<p>
				Lets see this in action by creating a new function <tt>jehtech_ParameterOrder(a,b,c)</tt> and the associated
				interface function <tt>Y_jehtech_ParameterOrder()</tt>:
			</p>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.i
 */
... snip ...
extern jehtech_ParameterOrder;</pre>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
... snip ...
void Y_jehtech_ParameterOrder(int argc)
{
   long hundreds = ygets_l(0),
        tens     = ygets_l(1),
        units    = ygets_l(2);

   ypush_long(hundreds*100 + tens*10 + units);
}</pre>
			<p>
				With the above modifications added and the plugin recompiled (just use <tt>make all</tt>, no need to regenerate the Makefile!) 
				we can run the Yorick interpreter and see the results.
			</p>
			<pre class="prettyprint linenums">$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; <b>jehtech_ParameterOrder(1,2,3)
321</b></pre>
			<p>
				The signature, written in C parlance, for <tt>jehtech_ParameterOrder()</tt> is 
				<tt>long jehtech_Parameters(long units, long tens, long hundreds)</tt>.
			</p>
			<p>
				We can clearly see that the last parameter is at the top of the stack and the first parameter is at the bottom.
				<div class="box_container"><div class="info">
						<p>
							Function parameters, passed on the Yorick stack, are pushed on in parameter order. This means that
							the last parameter will be at the top of the stack and the first at the bottom.
						</p>
				</div></div>
			</p>
			<p>
				As explained in <tt>yapi.h</tt>, the stack has space for at least 8 
				new elements when your plug-in's interface C function is called.
				It notes that if you are going to push more than 8 things onto the stack however, that you must reserve
				that space to avoid stack overflow.
				<div class="box_container"><div class="warning">
						<p>
							If you push more than 8 items onto the Yorick stack you must reserve enough space using 
							<tt>ypush_check()</tt> to avoid stack overflow!
						</p>
				</div></div>
			</p>

			<h4>Getting Scalar Parameters</h4>
			<p>
				The previous example showed how a function could retrieve 3 <tt>long</tt> parameters. The function
				<tt>ygets_l(stack_index)</tt> reads the <tt>long</tt> value at position <tt>stack_index</tt> in the
				stack. Note that it <em>does not pop</em> the value, it <em>only peeks</em> at the value. Position
				zero is the top of the stack.
			</p>
			<p>
				All of the functions that peek at scalars on the stack are called <tt>ygets_X</tt>, where <tt>X</tt>
				is a single character representing the type of value, <tt>l</tt> for long, for example. Here is a list
				of the scalar-peaking functions. Each function has one <tt>int</tt>argument, the stack position to peak.
			</p>
			<table style="border:0px">
				<tr>
					<td><tt>long ygets_l(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>double ygets_d(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>ystring_t ygets_q(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>ypointer_t ygets_p(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>char ygets_c(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>unsigned char ygets_uc(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>short ygets_s(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>int ygets_i(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>float ygets_f(int iarg)</tt></td>
				</tr>
			</table>

			<h4>Getting Array Parameters</h4>
			<p>
				All yorick array dimensions are represented by the list <tt>[rank, ndim1, ndim2, ..., ndimY]</tt>. The first
				parameter of the list, <tt>rank</tt>, gives the number of dimensions that the array possesses. The size of
				each dimension is given by <tt>ndimX</tt>. For example, a 2D array with 10 columns and 90 rows will be
				described by the list <tt>[2, 10, 90]</tt>. The size of the array dimension list is limited in Yorick. It 
				will be a maximum of <tt>Y_DIMSIZE</tt> <tt>long</tt>'s. This means that Yorick arrays cannot have more than
				<tt>Y_DIMSIZE-1</tt> dimensions.
			</p>
			<p>
				The first thing to remember is that <em>Yorick arrays are column major</em>. Therefore a 2D array is 
				described by the dimensions list <tt>[2, #columns, #rows]</tt>. Very easy to see this in action. We'll
				make the following additions to our project (note: generally you should not use <tt>printf</tt> like
				I'm doing here).
			</p>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.i
 */
...
extern jehtech_ArrayTest;</pre>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
...
#include &lt;stdio.h&gt;
...
void Y_jehtech_ArrayTest(int argc)
{
   long i;
   long dimInf[Y_DIMSIZE];
   long ntot;
   long *ary = ygeta_l(0, &amp;ntot, dimInf);
   printf("jehtech_2DArray: ntot == %ld\n", ntot);
   printf("jehtech_2DArray: dimInf = [");
   for(i = 0; i &lt;= dimInf[0]; ++i) {
      printf(&quot;%ld%s&quot;, dimInf[i], i == dimInf[0] ? &quot;]&quot; : &quot;, &quot;);
   }
   printf(&quot;\n&quot;);
}</pre>
			<p>
				Recompile the plugin and running Yorick, we can get the following:
			</p>
			<pre class="prettyprint linenums">
$ make all
...
$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; jehtech_ArrayTest, [1,2,3]
jehtech_2DArray: ntot == 3
jehtech_2DArray: dimInf = [1, 3]
&gt; jehtech_ArrayTest, [[1,2,3], [1,2,3]]
jehtech_2DArray: ntot == 6
jehtech_2DArray: dimInf = [2, 3, 2]
&gt; jehtech_ArrayTest, [[[1,2,3,4], [1,2,3,4]], [[1,2,3,4], [1,2,3,4]]]
jehtech_2DArray: ntot == 16
jehtech_2DArray: dimInf = [3, 4, 2, 2]</pre>

			<p>
				Great so we can, from our C code, get an array of <tt>long</tt>'s, or at least so far, it's dimensions
				so that we can determine what shape the array is. But what about accessing the array values? Yorick
				specifies everything <em>column major</em>, so in the array <tt>[[1,2,3,4], [5,6,7,8]]</tt> to access
				the third column, second row, we would write <tt>a(3,2)</tt>. However, under the hood Yorick stores
				arrays C-style... i.e., from C, when passed an array, we would access it as <tt>a[2][3]</tt> or
				<tt>a[2*num_cols + 3]</tt>. 
			</p>
			<p>
				Lets see this in action to see that this is in fact the case. We'll make the following additions to
				out project files...
			</p>
			<pre class="prettyprint linenums">/* 
 * FILE: jehtech.i
 */
...
extern jehtech_Dump2D;</pre>
			<pre class="prettyprint linenums">/*
 * FILE: jehtech.c
 */
...
void Y_jehtech_Dump2D(int argc)
{
   /* PRE: array is 2D! */
   long row, col;
   long dimInf[Y_DIMSIZE];                       /* [rank, #cols, #rows] */
   long *ary = ygeta_l(0, NULL, dimInf);
   for(row = 0; row &lt; dimInf[2]; ++row) {        /* dimInf[2] is #rows   */
      for(col = 0; col &lt; dimInf[1]; ++col) {     /* dimInf[1] is #cols   */
         printf("%ld\t", ary[row*dimInf[1] + col]);
      }
      printf("\n");
   }
}</pre>
			<p>
				Recompiling and running Yorick we then see the following...
			</p>
			<pre class="prettyprint linenums">$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; require, "jehtech.i"
&gt; jehtech_Dump2D, [[1,2,3,4], [5,6,7,8]]
1	2	3	4	
5	6	7	8</pre>

		</div> <!-- END H3 Div -->
	</div> <!-- END H2 Div -->


	<h2>Run Yorick From Python</h2>
	<div>
		<p>
			Cool... this looks promising as to test some Yorick I have been
			using Robot Framework so being able to do this would make tests 
			easier! Haven't done anything with it yet but Munro has written a
			<a href="https://github.com/dhmunro/pyorick"
				target="_blank">Python module interact with Yorick</a>.
		</p>
	</div> <!-- End H2: Run Yorick From Python -->
</div> <!-- END H1 Div -->
</div> <!-- END "Contents" Div -->
</body>
</html>


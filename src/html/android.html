<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Android notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Android notes</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>Interesting Reads and References</h2>
<div>
  <ol>
    <li><a href="http://www.howtogeek.com/189036/android-is-based-on-linux-but-what-does-that-mean/"
         target="_blank">Android Is based On Linux, But What Does That Mean?</a>, Chris Hoffman on
         howtogeek.com.
    </li>
    <li>
      <a href="http://davidehringer.com/software/android/The_Dalvik_Virtual_Machine.pdf"
         target="_blank">The Dalvik Virtual Machine Architecture</a>, David Ehringer, March 2010.
    </li>
    <li>
      <a href="https://software.intel.com/en-us/blogs/2014/06/18/art-vs-dalvik-introducing-the-new-android-x86-runtime"
         target="_blank">ART vs Dalvik - Introducing the New Android x86 Runtime</a>, Miao W. (Intel), June 18, 2014.
    </li>
    <li>
      <a href="http://www.electronicsweekly.com/blogs/eyes-on-android/what-is/the-dalvik-virtual-machine-2011-10/"
         target="_blank">What is the Dalvik Virtual Machine?</a>, Bright Sparks Staff.
    <li>
      <a href="http://source.android.com/devices/index.html"
         target="_blank">Android Interfaces and Architecture</a>, Android Docs.
    </li>
    <li>
      <a href="http://free-electrons.com/doc/training/android/android-slides.pdf"
         target="_blank">Android System Development</a>, Free Electrons.
    </li>
    <li>
      <a href="http://newandroidbook.com/files/AndroidInput.pdf"
         target="_blank">The Android Input Architecture</a>, Jonathan Levin, Technologeeks.com.
    </li>
    <li>
      <a href="http://stackoverflow.com/questions/11352709/android-device-configuration-for-aosp"
         target="_blank">Config New Android Device SO Thread</a>.
    </li>
    <li>https://blog.jayway.com/2012/10/24/a-practical-approach-to-the-aosp-build-system/</li>
    <li>https://software.intel.com/en-us/articles/building-an-android-command-line-application-using-the-ndk-build-tools</li>
    <li>http://www.imajeenyus.com/computer/20130301_android_tablet/android/unpack_repack_recovery_image.html</li>
    <li>http://www.slideshare.net/jserv/android-ipc-mechanism</li>
    <li>http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf</li>
    <li>http://rts.lab.asu.edu/web_438/project_final/Talk%208%20AndroidArc_Binder.pdf</li>
    <li>http://newandroidbook.com/files/Andevcon-Binder.pdf</li>
    <li>https://code.tutsplus.com/tutorials/android-essentials-working-with-strings-and-string-arrays--mobile-7838</li>
    <li>https://source.android.com/devices/graphics/architecture.html</li>
    <li>https://www.slideshare.net/chrissimmonds/android-bootslides20</li>
    <li>https://forum.xda-developers.com/showthread.php?t=443994  -- HOWTO: Unpack, Edit, and Repack Boot Images</li>
    <li>http://people.redhat.com/dwalsh/SELinux/Presentations/ManageRHEL5.pdf AWESOME SELINUX INTRO</li>
    <li>http://www.technobuzz.net/root-mi-note-2-and-install-twrp-recovery/</li>
    <li>https://source.android.com/devices/input/key-layout-files</li>
    <li>http://newandroidbook.com/code/android-6.0.0_r1/ndk/docs/Programmers_Guide/html/md_3__key__topics__building__chapter_1-section_8_ndk-build.html</li>
  </ol>
</div>

<h2>Using ADB: Cheet sheet.</h2>
<div>
  <h3>Find SDK And Add ADB To Path</h3>
  <p>
    Having downloaded the Android Developer Studio with SDK bundle, I could not find the
    <code>adb</code> command. The solution was given in this
    <a href="http://stackoverflow.com/questions/30812493/adb-exe-not-found-after-installing-android-studio"
       target="_blank">SO thread</a>.
  </p>
  <p>
    The SDK is found in <code>C:\%HOMEPATH%\AppData\Local\Android\sdk</code>. The <code>adb</code>
    utility is found under <code>platform-tools\adb.exe</code>. Add this path to your system
    <code>PATH</code>.
  </p>

  <h3>Run ADB</h3>
  <p>
    To list devices detected type:
  </p>
  <pre>adb devices -l</pre>
  <p>
    To connected to a particular device using a shell interface type:
  </p>
  <pre>adb -s xxx shell</pre>
  <p>Where <code>xxx</code> is identifier for the device you wish to select as seen in the
     <code>adb devices -l</code> output.
  </p>
  <p>
    To wait for a device to become available:
  </p>
  <pre>adb [-s xxx] wait-for-usb-device</pre>
  <p>
    To switch to root (if you're phone has been rooted):
  </p>
  <pre>adb [-s xxx] root</pre>
  <p>
    To push a file to your device:
  </p>
  <pre>adb [-s xxx]  push your.file /data/local/tmp</pre>
  <p>
    To remount <code>/system</code> read/write:
  </p>
  <pre>adb remount</pre>
  <p>
    To view android logs:
  </p>
  <pre>adb logcat</pre>
  <p>
    To view kernel logs:
  </p>
  <pre>adb shell cat /proc/kmsg</pre>
  <p>
    To send keyevents:
  </p>
  <pre>adb shell input keyevent KEYCODE_BACK</pre>
  <p>
    To install an app:
  </p>
  <pre>adb install app-name.apk</pre>
  <p>
    To reboot [into recovery]:
  </p>
  <pre>adb reboot [recovery]</pre>

  <h3>Fastboot &amp; Flash ROMs</h3>
  <pre>adb reboot bootloader
fastboot boot boot.img
fastboot flash boot boot.img
fastboot flash recovery recovery.img
fastboot reboot</pre>

  <h3>Kill Emulators</h3>
  <pre>adb -s emulator-xxxx emu kill</pre>
</div> <!-- END Where is the SDK -->

<h2>Android Shell Utils Cheet Sheet</h2>
<div>
  <p>To <b>broadcast</b> an event:</p>
  <pre>am broadcast -a android.intent.action.BOOT_COMPLETED -p com.mypackage.name</pre>
  <p>Without the <code>-p</code> option to direct the broadcast to your specific
     package you might find it reboots your system...</p>
</div>

<h2>TODO</h2>
<div>
    <ul>
        <li>http://elinux.org/Android_Build_System</li>
        <li>http://ericdev.blogspot.co.uk/2010/06/cc-closer-look-at-android-project-build.html</li>
        <li>http://www.androidenea.com/2009/08/init-process-and-initrc.html</li>
        <li>http://liuluheng.github.io/wiki/public_html/Mobile/Android/Firmware%20Development.html</li>
        <li>https://www.kingoapp.com/root-tutorials/how-to-root-android-6.0-marshmallow.htm</li>
        <li>http://www.addictivetips.com/mobile/android-partitions-explained-boot-system-recovery-data-cache-misc/</li>
        <li>https://en.wikipedia.org/wiki/Evdev</li>
        <li>https://joeshaw.org/linux-input-ecosystem/</li>
        <li>http://rts.lab.asu.edu/web_438/project_final/Talk%208%20AndroidArc_Binder.pdf</li>
        <li>http://www.toptip.ca/2013/01/unix-domain-socket-with-abstract-socket.html?m=1<br/>and<br/>http://stackoverflow.com/questions/14643571/localsocket-communication-with-unix-domain-in-android-ndk<br/>and<br/>https://developer.android.com/reference/android/net/LocalServerSocket.html<br/>and<br/>https://developer.android.com/reference/android/net/LocalSocket.html</li>
        <li>Key Layout Files - how to assign keys your driver passes to android a key code: https://source.android.com/devices/input/key-layout-files and https://developer.android.com/ndk/reference/keycodes_8h.html</li>
    </ul>
</div> <!-- Building Android -->

<h2>Getting Detailed System Information &amp; Backing Up System</h2>
<p>
    Based on the following references:
    <ul>
        <li>The following articles talk about extracting images and device trees and what you can do with
            them once you've got them:
            <ul>
                <li><a href="https://www.youtube.com/watch?v=DyUainEJwLM" target="_blank">Pull Your Own Stock Android Firmware From Your Device</a>, by Rootjunky.com.</li>
                <li><a href="https://forum.xda-developers.com/showthread.php?t=2771411" target="_blank">Dump Stock Rom And Build Flashable Image</a>, XDA Developers thread.</li>
                <li><a href="http://www.imajeenyus.com/computer/20130301_android_tablet/android/unpack_repack_recovery_image.html" target="_blank">Unpack And Repack Recover Image</a> Lindsay Wilson, imajeenyus.com.</li>
                <li><a href="http://www.cnx-software.com/2015/12/07/how-to-extract-kernel-img-with-mkboot-script/" target="_blank">How to Extract a Kernel Image With The MKBoot Script</a>, CNXSoft.</li>
                <li><a href="http://www.cnx-software.com/2014/05/12/how-to-extract-a-device-tree-file-from-android-firmware-files/" target="_blank">How to Extract a Device Tree File from Android Firmware Files</a>, CNXSoft.</li>
                <li><a href="https://github.com/xiaolu/mkbootimg_tools" target="_blank">mkbootimg_tools</a>, xiaolu on GitHub.</li>
                <li><a href="http://batakang.com/ftp/DEVICE_INFO/Android_Device_System_Information.zip" target="_blank">Android_Device_System_Information.zip</a>, BataKang.</li>
            </ul>
        </li>
        <li>For an interesting look at the Android boot process look here:
            <ul>
                <li><a href="http://www.onsandroid.com/2014/10/in-depth-android-boot-sequence-process.html" target="_blank">Android Boot Sequence / Init Process</a>, Suresh Achari.</li>
                <li><a href="http://www.slideshare.net/StacyWylie/timings-of-init-android-ramdisks-for-the-practical-hacker" target="_blank">Timings of Init : Android Ramdisks for the Practical Hacker</a>, Stacy Devino.</li>
            </ul>
        </li>
        <li>For information Android security and SELinux:
            <ul>
                <li><a href="https://events.linuxfoundation.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf" target="_blank">Security Enhancements (SE) for Android</a>, Stephen Smalley, NSA.</li>
                <li><a href="https://www.codeproject.com/Articles/806904/Android-Security-Customization-with-SEAndroid" target="_blank">Android Security Customization with SEAndroid</a>, Code Project.</li>
                <li><a href="https://source.android.com/security/selinux/implement.html" target="_blank">Implementing SELinux</a>, Android Docs.</li>
                <li><a href="https://software.intel.com/en-us/android/articles/android-security-customization-with-seandroid" target="_blank">Android Security Customization with SEAndroid</a>, Liang Zhang (Intel).</li>
                <li>https://wiki.gentoo.org/wiki/SELinux/Tutorials</li>
                <li>http://www.all-things-android.com/content/se-android-commands</li>
                <li>https://boundarydevices.com/android-security-part-3-security-enhanced-linux-in-android/</li>
            </ul>
        </li>
    </ul>
</p>
<p>
  Batakang.com has a really useful script <code>Android_Device_System_Information.bat</code>, which
  you can get
  <a href="http://batakang.com/ftp/DEVICE_INFO/Android_Device_System_Information.zip" target="_blank">here in a ZIP file</a>.
  Download and extract into any directory. you can then use the script to get a ton of useful information about your device.
</p>
<p>
  When I tried running it I was interested in the msm partitions. This line of the script didn't work
  out of the box for me but it was pretty easy to explorer the directory structure under
  <code>/dev/block/platform</code> to eventually find the <code>by-name</code> directory that
  has a load of symbolic links, named by device name, linking to the device on which they reside.
  In my case it was <code>/dev/block/platform/soc/624000.ufshc/by-name/</code>.
</p>
<p>
  By looking into this directory I could see where my recovery image resided:
</p>
<pre>&gt; adb root
&gt; adb shell "ls -la /dev/block/platform/soc/624000.ufshc/by-name"
lrwxrwxrwx root     root              1970-01-12 12:43 aboot -> /dev/block/sde23
lrwxrwxrwx root     root              1970-01-12 12:43 abootbak -> /dev/block/sde24
... &lt;snip&gt; ...
lrwxrwxrwx root     root              1970-01-12 12:43 <b>recovery -> /dev/block/sda13</b></pre>
<p>
    Using the above listing we can find out which block devices correspond to our boot, system, recovery and userdata images.
    These can then be extracted to files using the
    <a href="http://man7.org/linux/man-pages/man1/dd.1.html" target="_blank">dd</a>
    comand to copy the device contents to a file:
</p>
<pre><a href="http://man7.org/linux/man-pages/man1/dd.1.html" target="_blank">dd</a> if=/dev/block/sdXXX of=/directory/of/your/name.img</pre>
<p>
    These files can then be pulled off the device using the following:
</p>
<pre>adb pull /directory/of/your/name.img name.img</pre>
<p>
    For example, from the above I might want to get by boot image. This happened to map to
    <code>/dev/block/sde36</code>. The boot image contains the kernel and ramdisk: the critical
    stuff needed to load the device. So, I would do...
</p>
<pre>dd if=/dev/block/sde36 of=/data/local/tmp/boot.img
adb pull /data/local/tmp/boot.img boot.img</pre>
<p>
    <em>Or</em> as i found out later, it is much easier to do
</p>
<pre>adb pull /dev/block/sde36 boot.img</pre>
<p>Note you can only do this with partitions that are not in use, such as the boot or
   recovery partition. For everything else install a TWRP recover image (see below).
</p>
<p>
    Once you have your boot image you can then use the
    <a href="https://github.com/xiaolu/mkbootimg_tools" target="_blank">mkbootimg_tools</a>
    to unpack your boot image:
</p>
<pre>./mkboot ../boot.img ../boot-unpacked</pre>
<p>
  See also the tool <a href="http://newandroidbook.com/tools/imgtool.html" target="_blank">imgtool</a>, provided by
  Jonathan Levin on his website.
</p>
<p>
Then you can edit things on the RAM disk or place new commands on there etc:
</p>
<pre>vim ../boot-unpacked/ramdisk/service_contexts</pre>
<p>
  You can also do things like checkout the Linux version being used:
</p>
<pre>zgrep -a 'Linux version' ../boot-unpacked/kernel</pre>
<p>
Then you can repack this boot image and either fastboot or flash it to you phone:
</p>
<pre>./mkboot ../boot-unpacked ../boot_new.img</pre>
<p>
    For more information you can see
    <a href="http://android-dls.com/wiki/index.php?title=HOWTO:_Unpack%2C_Edit%2C_and_Re-Pack_Boot_Images" target="_blank">HOWTO: Unpack, Edit, and Re-Pack Boot Images</a>.
</p>
<p>
    If you want to grab other partitions, like system etc, you should download a recovery rom such
    as a TWRP recovery ROM for your device and use the backup features to back partitions up and
    save them to your local disk. The TWRP recovery, which you can fastboot (you don't need to flash it)
    will backup your selected partitions to a folder on your device, which you can mount and copy from.
</p>
<p>
    For example, loading a TWRP recovery ROM and clicking &quot;backup&quot; showed the first screen
    shown below. Just select what you want to backup. Continuing with the backup then loads a
    progress screen (second image below). The screen text will tell you where it is putting the backups on you phone's
    storage (note the second image's text shows the text &quot;<code>Backup Folder: /data/media/0/TWRP/BACKUPS/</code>&quot;).
</p>
<p>
    <img src="##IMG_DIR##/twrp_recovery_backup.png" alt="Screenshot of TRWP recovery backup selection screen"/>
    <img src="##IMG_DIR##/twrp_recovery_backup_progress.png" alt="Screenshot of TRWP recovery backup progress screen"/>
</p>
<p>
     The recovery ROM still lets you access your phone. Mine was mounted on Windows at
     <code>This PC\MIX\Internal Storage\TWRP\BACKUPS\ed16622e\2017-02-03--07-04-30_MXB48T</code>.
</p>
<p>
    PS: Used this
    <a href="http://www.droidviews.com/take-screeshots-in-cwm-twrp-recovery-mode/" target="_blank">utility</a>
    to take the screenshots....
</p>

<h2>Write To Android Log From C (NDK)</h2>
<div>
  <pre>#include &lt;android/log.h&gt;
__android_log_print(ANDROID_LOG_DEBUG, "LOG_TAG", "printf like syntax", ...);</pre>
</div>

<h2>Rooting Your Phone</h2>
<div>
<p>
  The following two articles explain how rooting your phone actually works:
  <ol>
      <li>https://seasonofcode.com/posts/how-rooting-works-a-technical-explanation-of-the-android-rooting-process.html</li>
      <li>https://jon.oberheide.org/files/bsides11-dontrootrobots.pdf</li>
      <li>https://www.kingoapp.com/root-tutorials/how-to-root-android-6.0-marshmallow.htm</li>
  </ol>
</p>
<p>
  Rooting a device means to get root access to the Linux system that Android is built on top of.
  Root access allows you to execute <em>anything</em>. It gives you complete control over your phone.
  A &quot;normal&quot; phone user executes with certain limited permissions so she cannot execute
  or do anything they please.
</p>
<p>
  When we say a bootloader is <em>locked</em>, it means that it will not flash/boot updates unless
  they are digitally signed by its vendor. <b>Warning:</b> unlocking your bootloader completely
  eliminates your device's security - its like not password protecting your desktop's BIOS!
</p>
<blockquote>
  <p>
  Bootloader integrity is always verified using a hardware root of trust. For verifying boot and recovery partitions, the bootloader has a fixed OEM key available to it. It always attempts to verify the boot partition using the OEM key first and try other possible keys only if this verification fails.
  </p>
  <footer>-- <a href="https://source.android.com/security/verifiedboot/verified-boot" target="_blank">Verified Boot, Android Docs</a>.</footer>
</blockquote>
<p>
  When a bootload is <em>unlocked</em>, it will let you flash/boot any ROMs of your choosing,
  signed or not!
</p>
<p>
    So, how can we get root permissions on a device? The following quote explains it nicely:
</p>
<blockquote>
	<p>
	... if you can hack / trick one of these system processes running in privileged mode to execute your arbitrary code, you have just gained privileged access to the system. This how all one-click-root methods work, including z4root, gingerbreak, and so on ...
	</p>
	<foorter>-- <a href="https://seasonofcode.com/posts/how-rooting-works-a-technical-explanation-of-the-android-rooting-process.html" target="_blank">How Rooting Works, By Chuan Ji, Oct 19, 2011.</a>
	</foorter>
</blockquote>
<p></p>
</div> <!-- Rooting your phone -->

<h2>Logs</h2>
<div>
  <pre>adb shell cat /proc/kmsg # Get the system log
logcat # Get the Android log</pre>
</div>

<h2>Camera Stuff</h2>
<div>
    <ul>
        <li>http://stackoverflow.com/questions/37434494/android-camera-2-preview-size-and-devices-aspect-ratio</li>
        <li>http://stackoverflow.com/questions/17019588/crop-camera-preview-for-textureview */</li>
    </ul>
</div>

<h2>Touch Events</h2>
<div>
<p>http://lxr.free-electrons.com/source/Documentation/input/event-codes.txt</p>
<p>https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt</p>
</div> <!-- END Touch Events -->

<h2>Programmatically Generating And Injecting Events In Android</h2>
<div>
  <p>
    I needed to be able to generate touch events for a project I was working on. These touch
    events had to be injected somewhere into the Android event infrastructure so that they would
    appear to the system as if they were actually from the touchscreen.
  </p>

  <h3>References</h3>
  <ol>
    <li><a name="ref1"></a> http://newandroidbook.com/files/AndroidInput.pdf</li>
    <li><a name="ref2"></a>http://www.linuxjournal.com/article/6396 and http://www.linuxjournal.com/article/6429</li>
    <li><a name="ref3"></a>https://github.com/jpunz/AndroidEventInjector/blob/master/Injector.java</li>
    <li><a name="ref4"></a>http://www.pocketmagic.net/injecting-events-programatically-on-android/</li>
    <li><a name="ref5"></a>http://www.pocketmagic.net/programmatically-injecting-events-on-android-part-2/</li>
  </ol>

  <a name="UsingADBSendEventGetEvent"></a>
  <h3>Using ADB sendevent &amp; getevent</h3>
  <p>
    Using ADB there are the
    <code><a href="https://source.android.com/devices/input/getevent.html" target="_blank">getevent</a></code>
    and <code>sendevent</code> commands which are
    usefull while debugging, but I needed to write some kind of service/daemon.
  </p>
  <p>
    To get a pretty printed list of events comming out of your device use:
  </p>
  <pre>getevent -lt /dev/input/eventX</pre>
  <p>
    The <code>-l</code> option tells <code>getevent</code> to label event types and names in
    plain text. The <code>-t</code> option prints out the timestamps.
    For example, a quick tap on my touch screen gives this:
  </p>
  <pre># getevent -lt /dev/input/event4
[    4339.714135] EV_ABS       ABS_MT_TRACKING_ID   00000015
[    4339.714135] EV_ABS       ABS_MT_POSITION_X    0000055c
[    4339.714135] EV_ABS       ABS_MT_POSITION_Y    000001e9
[    4339.714135] EV_ABS       ABS_MT_PRESSURE      00000049
[    4339.714135] EV_ABS       ABS_MT_TOUCH_MAJOR   00000008
[    4339.714135] EV_KEY       BTN_TOUCH            DOWN
[    4339.714135] EV_SYN       SYN_REPORT           00000000
[    4339.720836] EV_ABS       ABS_MT_PRESSURE      00000033
[    4339.720836] EV_ABS       ABS_MT_TOUCH_MAJOR   00000007
[    4339.720836] EV_SYN       SYN_REPORT           00000000
[    4339.738694] EV_ABS       ABS_MT_TRACKING_ID   ffffffff
[    4339.738694] EV_KEY       BTN_TOUCH            UP
[    4339.738694] EV_SYN       SYN_REPORT           00000000</pre>
  <p>Here we are seeing the Linux input layer messages being sent from the driver into the
     input layer. Here we are seeing
     <a href="https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt"
        target="_blank">Linux multi-touch messages</a>.
  </p>
  <p>
    From the above we can see that the device is typ &quot;B&quot;. The first message is the
    tracking ID (<code>ABS_MT_TRACKING_ID</code>). Because screens are multi-touch, i.e., more than
    one finger can be used on the device at any one time, the coordinates sent to the Linux input layer
    have to be associated with a finger, or stylus etc. It is the hardware's/driver's responsibility
    to keep track of the various active touch points and give them an ID. For example, if I touch
    the screen with one finger, as in this case, the first finger is assigned the number 15. If I
    then touched the screen with a second finger, it might be assigned the number 16, for example.
  </p>
  <p>
    The second pair of messages are the x and y coordinates of the pointing device with ID 15. The
    coordinates are, I believe, in device coordinate units. Either the input layer or users of the
    input layer convert these to pixels (I think - need to confirm this).
  </p>
  <p>
    Next we have the pressure and the area of the major touch - see the <a href="https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt"
        target="_blank">Linux multi-touch messages</a> doc.
  </p>
  <p>
    Next to indicate that there is a finger pressed a <code>BTN_TOUCH</code> message is sent with
    the finger-down flag set.
  </p>
  <p>
    Finally to indicate the end of this particular event a <code>SYN_REPORT</code> message is sent.
  </p>
  <p>
    Next a set of pressure and major-touch messages are sent to indicate a change in the pressure
    of my touch. This set of events is ended using another <code>SYN_REPORT</code>. Note, because
    we are still talking about the same touch point, no tracking ID needs to be sent.
  </p>
  <p>
    Finally in the next block of messages we see a tacking ID of -1. This indicates that the current
    slot (the tracking ID) is no longer being used.
  </p>

  <h3>The &quot;input&quot; Command</h3>
  <p>
    It is also possible to use the <code>input</code> command line utitlity. For example,
    the following will inject an artificial home-button touch event, making it look asif the user
    actually pressed the home button <a href="#ref3">[Ref]</a>:
  </p>
  <pre class="prettyprint linenums">input keyevent 3</pre>
  <p>
    The command does appear to be useable <em>without</em> root privileges, which is nice.
  </p>

  <h3>Write To The Device's  /dev/input/xxx</h3>
  <p>http://linuxwacom.sourceforge.net/wiki/index.php/Kernel_Input_Event_Overview</p>
  <p>
    Android is based on Linux and uses the Linux Input Subsystem. This means that every input
    device has created a node under <code>/dev/input</code>. This device can be written to if you
    want to inject event messages into the system and make them appear asif they came from that
    device. Downside is, this requires root privileges.
  </p>
  <p>
    This is essentially, I think, what the <code>send|getevent</code> command line utils are doing,
    but this shows how to do it from your program directly without having to fork these commands.
  </p>
  <p>
    A little example based (heavily) on the rather good pocketmagic articles <a href="#ref4">[Ref]</a><a href="#ref5">[Ref]</a>:
  </p>
  <pre class="prettyprint linenums">// Copy of <a href="http://lxr.free-electrons.com/source/include/uapi/linux/input.h#L25" target="_blank">struct input_event</a>
struct uinput_event
{
  struct timeval time;
  uint16_t type;
  uint16_t code;
  int32_t value;
};

static void sendInputEvent(int fd, uint16_t type, uint16_t code, int32_t value)
{
  struct uinput_event ev = {
    .type  = type,
    .code  = code,
    .value = value
  };
  gettimeofday(&amp;pev.time, NULL);

  write(fd, &amp;ev, sizeof(ev));
}

... &lt;snip&gt; ...

fd = open("/dev/input/eventX", O_RDWR); // X is an integer number
if (fd < 0) {
  // Handle error
}

// Send a touch event at coordinates 100, 100
sendInputEvent(fd, EV_ABS, ABS_MT_POSITION_X, 100);   // Have to get these values from ...
sendInputEvent(fd, EV_ABS, ABS_MT_POSITION_Y, 100);   // ... <a href="http://lxr.free-electrons.com/source/include/uapi/linux/input-event-codes.h" target="_blank">input-event-codes.h</a>.
sendInputEvent(fd, EV_KEY, BTN_TOUCH, 1);
sendInputEvent(fd, EV_SYN, SYN_REPORT, 1);</pre>
</div> <!-- END -->

<h2>MotionEvents</h2>
<div>
    <p>
        You can intercept all touch events to your <code>Activity</code> using the following:
    </p>
    <pre class="prettyprint linenums">public class MainActivity extends AppCompatActivity {

    private static final Map&lt;Integer, String&gt; mMotionEventMap;
    static {
        /* Action event map, not including deprecated values and also not including
         * *_MASK and *_SHIFT constants because these are only needed with getAction() */
        Map&lt;Integer, String&gt; mMEMInitialiser = new HashMap&lt;Integer, String&gt;();
        mMEMInitialiser.put(MotionEvent.ACTION_BUTTON_PRESS,   "ACTION_BUTTON_PRESS");
        mMEMInitialiser.put(MotionEvent.ACTION_BUTTON_RELEASE, "ACTION_BUTTON_RELEASE");
        mMEMInitialiser.put(MotionEvent.ACTION_CANCEL,         "ACTION_CANCEL");
        mMEMInitialiser.put(MotionEvent.ACTION_DOWN,           "ACTION_DOWN");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_ENTER,    "ACTION_HOVER_ENTER");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_EXIT,     "ACTION_HOVER_EXIT");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_MOVE,     "ACTION_HOVER_MOVE");
        mMEMInitialiser.put(MotionEvent.ACTION_MOVE,           "ACTION_MOVE");
        mMEMInitialiser.put(MotionEvent.ACTION_OUTSIDE,        "ACTION_OUTSIDE");
        mMEMInitialiser.put(MotionEvent.ACTION_POINTER_DOWN,   "ACTION_POINTER_DOWN");
        mMEMInitialiser.put(MotionEvent.ACTION_POINTER_UP,     "ACTION_POINTER_UP");
        mMEMInitialiser.put(MotionEvent.ACTION_SCROLL,         "ACTION_SCROLL");
        mMEMInitialiser.put(MotionEvent.ACTION_UP,             "ACTION_UP");
        mMotionEventMap = mMEMInitialiser;
    }

    ... &lt;snip&gt; ...

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        final String DEBUG_TAG = "JEHTECH";
        final int historySize  = event.getHistorySize();
        final int pointerCount = event.getPointerCount();
        final int action       = MotionEventCompat.getActionMasked(event);
        final String actionStr = mMotionEventMap.get(action);

        if (actionStr != null) {
            Log.d(
                DEBUG_TAG,
                "Action was " + actionStr + " (#" + action + "), with " + pointerCount +
                    " pointers and a history size of " + historySize);
            return true;

        }

        Log.d(DEBUG_TAG, "Action was #" + action);
        return super.onTouchEvent(event);
    }

    ... &lt;snip&gt; ...
}</pre>
    <p>To get information on <code>MotionEvent</code>s it appears that the best thing to use is
       <code>MotionEventCompat.getActionMasked()</code> because this offers (at the time of writing
       Jan 2017) the most cross-device compatible and mult-touch capable interface for interpretting
       touch events.
    </p>
    <p>
      The function <code>getAction()</code> is (almost) <em>deprecated</em> by the looks of things:
      <q>You should always use the method <code>getActionMasked()</code> (or better yet, the compatability version
         <code>MotionEventCompat.getActionMasked()</code>) to retrieve the action of a <code>MotionEvent</code>. Unlike the
         older <code>getAction()</code> method, <code>getActionMasked()</code> is designed to work with multiple pointers.
      </q> -- <a href="https://developer.android.com/training/gestures/multi.html" target="_blank">[Ref]</a>.
    </p>
</div> <!-- END MotionEvents DIV -->

<h2>NDK Applications And PThreads</h2>
<div>
  <p>If you want to use the <code>pthread</code> library in Android, you do not have to link
     against an external library: it is baked into the
     <a href="https://android.googlesource.com/platform/bionic/+/ics-mr1-release/libc/docs/OVERVIEW.TXT"
        target="_blank">Bionic C library</a> already. Note, however,
     that it does not give a full <code>pthread</code> implementation. Notably things like
     <code>pthread_cancel</code> are not supported.
  </p>
</div>

<h2>Intent and Broadcast Receiver</h2>
<div>
  <pre class="prettyprint linenums">// In the sender activity
Intent localIntent = new Intent(MY_INTENT_STR).putExtra(MY_INTENT_STR_EXTRA, item);
LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent);

// In the receiver activity
public class MainActivity extends AppCompatActivity {
    protected MyReceiver mReciever;

    // ... &lt;snip&gt; ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // ... &lt;snip&gt; ...
        mReciever = new MyReceiver();
        LocalBroadcastManager.getInstance(this).registerReceiver(mReciever, new IntentFilter(MY_INTENT_STR));
        // ... &lt;snip&gt; ...
    }

    class MyReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, Intent intent) {
            Log.d(DEBUG_TAG, "GOT broadcast: " + intent.getExtras() /* &lt;snip&gt; ... */);
        }
    }
}</pre>
</div> <!-- END Intent -->

<h2>Android Build Tree</h2>
<div>
<p>
  The top-level view of the android build tree is as follows:
</p>
<pre>.
|-- abi
|-- art
|-- bionic          - Bionic is Android's libc (standard C library)
|-- bootable
|-- build
|-- cts
|-- dalvik          - The Dalvik virtual machine
|-- developers
|-- development
|-- device          - Product make definitions
|-- docs
|-- external
|-- frameworks      - Android frameworks, e.g. binder support functions etc, native and Java code
|-- hardware
|-- kernel          - The Linux kernel
|-- libcore
|-- libnativehelper
|-- ndk
|-- out
|-- packages
|-- pdk
|-- prebuilts       - Things like compiler chains for various platforms
|-- sdk
|-- system
|-- tools
`-- vendor</pre>
<p>
  The directory <code>bionic</code> contains the code for Android's implementation of the standard
  C library. The library also wraps up other well known libraries such as pthreads, so when using
  pthreads, you don't need to link against any extra libraries. Note, however, that the Android
  implementation <em>does not support the entire POSIX pthread standard</em>. Notably things like
  <code>pthread_cancel</code> are not supported.
</p>
<p>
  The directory <code>kernel</code> contains the Linux kernel, on top of which Android is build.
  The kernel in the Android build tree contains Android modifications to the Linux kernel. Many
  of these have now gone upstream and exist in the master kernel branch as well. Android introduced
  concepts such as wavelocks.
</p>
<p>
  The <code>device</code> directory contains data and build scripts relevant to specific devices.
  Under <code>device</code> the vendor specific build configs/scripts exist generically as
  &quot;<code>./device/&lt;company-name&gt;/&lt;device-name&gt;</code>&quot;.
  So, for example, the <code>device</code> directory of the build tree from Qualcomm looks like
  this:
</p>

<h3>Devices</h3>
<p>
  References:
</p>
<ul>
  <li><a href="http://source.android.com/source/add-device.html" target="_blank">Adding a New Device</a></li>
</ul>
<pre>device/qcom/
|-- apq8084
|-- common
|-- mpq8064
|-- msm7627a
|-- msm7630_surf
|-- msm8226
&lt;snip&gt;</pre>
<p>
  Under the folder for a particular device the following 3 files are the most significant in
  terms of defining the build:
</p>
<p>
  <ul>
    <li><code>Android.mk</code></li>
    <li><code>AndroidBoard.mk</code></li>
    <li><code>AndroidProducts.mk</code>
      <ul><li>Seems to have one purpose and that is to &quot;point&quot; to the product definition
      makefile, named as the device vendor wishes.</li></ul>
    </li>
    <li><code>BoardConfig.mk</code>
      <ul><li>Board specific configuration</li></ul>
    </li>
    <li><code>vendorsetup.sh</code>
      <ul><li>Adds a lunch combo for your device. e.g. by calling <code>add_lunch_combo &lt;product-name&gt;</code>.</li></ul>
    </li>
  </ul>
</p>
<p>
</p>
<h3>Build Notes</h3>
<h4>Intro</h4>
<p>
     This section is just a summary of
     <a href="http://ericdev.blogspot.co.uk/2010/06/cc-closer-look-at-android-project-build.html" target="_blank">A closer look at the Android project build system</a> and <a href="http://elinux.org/Android_Build_System" target="_blank">Android Build System</a>.
</p>
<ul>
    <li>The linux kernel is cross compiled into a standalone library using a gcc cross compiler. Does not depend on anything else.</li>
    <li>All other native apps depend on bionic.</li>
    <li>Everything else uses Java compiler for Android. Java compiler location specified by <code>$JAVA_HOME</code> env variable.</li>
</ul>
<p>
  Build using <code>source build/envsetup.sh</code>. The build will define the product, build variant, simulator, and type (release or debug).
</p>

<h4>Preparation</h4>
<h5>Install OpenJDK (And Select The Right Version)</h5>
<p>
  If you're building on Ubuntu 16 you will need to install Sun's OpenJDK
  <a href="https://askubuntu.com/questions/761127/how-do-i-install-openjdk-7-on-ubuntu-16-04-or-higher"
     target="_blank">[Ref]</a>:
</p>
<pre class="prettyprint linenums">sudo add-apt-repository ppa:openjdk-r/ppa
sudo apt-get update
sudo apt-get install openjdk-7-jdk</pre>
<p>
    Note that different versions of Android will require different versions of Java. You can
    install multiple versions of Java on your machine using <code>apt-get</code> and it won't
    overwrite existing versions. 
</p>
<div class="box_container">
    <div class="info">
        <p>Different versions of Android require different versions of Java. You can install
        multiple Java versions, but make sure you have selected the &quot;active&quot; version
        that is appropriate to your Android version. The compilation will warn you if it isnt.
        </p>
    </div>
</div>
<p>
    To see what versions of Java you have available on your system type the following:
</p>
<pre><b>jehtech$</b> sudo update-alternatives --list java
/usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java
/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java</pre>
<p>
    Above I see on my system I have Java v 7 and 8 installed.
</p>
<p> 
    To choose an &quot;active&quot; version use
    <code>sudo update-alternatives --config java</code>. It will display a little choice menu
    on your console that lists the installed versions (the currenly active version is marked by
    a *). Just choose the version you want:
</p>
<pre><b>jehtech$</b> sudo update-alternatives --config java
There are 2 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                                            Priority   Status
------------------------------------------------------------
* 0            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      auto mode
  1            /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java   1071      manual mode
  2            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      manual mode

Press &lt;enter&gt; to keep the current choice[*], or type selection number:</pre>

<h5>Install Repo</h5>
<p>
  You will also need to install &quot;Repo&quot;, a tool, written in Python, built on top of git that makes it easier to work with Git and Android <a target="_blank" href="https://source.android.com/source/downloading">[Ref]</a>. Download using the following (you can replace <code>~/bin/repo</code> with a directory of your choice):
</p>
<pre class="prettyprint linenums">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
chmod a+x ~/bin/repo</pre>

<h5>Configure USB Access</h5>
<p>
  You will also need to configure USB access <a href="https://source.android.com/source/initializing" target="_blank">[Ref]</a>
  because might not be able to access USB devices by default:
</p>
<pre class="prettyprint linenums">wget -S -O - http://source.android.com/source/51-android.txt | sed "s/&lt;username&gt;/$USER/" | sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules</pre>

<h5>Building for QualComm chipsets</h5>
<p>
  <b>To build Qualcomm BSPs look at</b>
  <a href="https://wiki.codeaurora.org/xwiki/bin/QAEP/release"
     target="_blank">https://wiki.codeaurora.org/xwiki/bin/QAEP/release</a>.
  Seems to have a more comprehensive BSP list than that available by following the Xiaomi Git Wiki link!
  Checkout using:
</p>
<pre class="prettyprint linenums">repo init \
   -u git://codeaurora.org/platform/manifest.git \
   -b release \
   -m &lt;manifest&gt; \
   â€“-repo-url=git://codeaurora.org/tools/repo.git \
   --repo-branch=caf-stable \
   [--depth=1]</pre>
<p>
  Replace <code>&lt;manifest&gt;</code> with the manifest that matches the BSP you want to build. For example,
  if you want to build for the BSP <code>linux_android_board_support_package_v<b>la.br_.1.2.4-01810-8x16.0-2</b>.zip</code>
  you would need to specify the manifest file as <code><b>LA.BR.1.2.4-01810-8x16.0</b>.xml</code> <a href="https://developer.qualcomm.com/download/db410c/linux-android-software-build-and-installation-guide.pdf" target="_blank">[Ref]</a>.
</p>
<p>
  The repo tool will download the many repositories that make up the entire code base and it is
  the manifest file that tells to tool which repositories and branches need to be retreived.
</p>
<p>
  The other option you might consider is <code>--depth=1</code>. It
  tells repo to create a shallow clone with a history truncated to the last 1 commit, which should
  reduce the amount of history you have to download.
</p>

<h5>Sync Up</h5>
<p>
  Next step, after initialising the repo directory, is to download everything. This is done with the
  &quot;sync&quot; command:
</p>
<pre class="prettyprint linenums">repo sync -j 4</pre>
<p>
  The <code>-j</code> option allows you to specifiy how many projects should be fetched simulataneously.
  The beefier your internet connection and other hardware (like num cores etc) the higher you might
  want to push this number. Fetching nultiple projects at a time may help reduce the total
  download time.
</p>
<p>
  The first sync will take a-g-e-s, as in many hours! From what I've read there is not a lot
  one can do about this (apart from the <code>--depth</code> option discussed above). You could also try
  to edit the manifest file (found in the <code>.repo</code> directory) to remove prebuilt toolchains
  that do not match your system, which may save about 1GB download <a href="https://forum.xda-developers.com/showthread.php?t=2786681" target="_blank">[Ref]</a>.
</p>

<h5>Build the Kernel</h5>
<p>
  use the following to build the kernel:
</p>

<pre>source build/envsetup.sh</pre>

<p> Sourcing <code>envsetup.sh</code> gives you these rather useful commands (and more - the list is truncated) to search and navigate
    the source tree <a href="http://elinux.org/Android_Build_System#Helper_macros_and_functions" target="_blank">[Ref]</a>:

    <table>
        <tr><td><code>croot</code></td><td>change directory to the top of the tree</td></tr>
        <tr><td><code>cgrep <i>&lt;pattern&gt;</i></code></td><td>grep on all local C/C++ files</td></tr>
        <tr><td><code>jgrep <i>&lt;pattern&gt;</i></code></td><td>grep on all local Java files</td></tr>
        <tr><td><code>resgrep <i>&lt;pattern&gt;</i></code></td><td>grep on all local res/*.xml files</td></tr>
        <tr><td><code>godir <i>&lt;filename&gt;</i></code></td><td>go to the directory containing a file</td></tr>
    </table>
</p>

<p>
    Having sourced the environment setup continue to make the boot image like so:
</p>

<pre class="prettyprint linenums">lunch &lt;product you're building for&gt;
make bootimage</pre>

<p>
  The build should produce at least the following files in <code>out/target/product/&lt;product&gt;</code> <a href="https://www.slideshare.net/chrissimmonds/android-bootslides20" target="_blank">[Ref]</a>:
</p>
<ul>
  <li><code>boot.img</code>: Kernel and ramdisk used for normal boot. It is created using the <code>mkbootimg</code> tool and contains a compressed kernel, the kernel command line and optionaly a ramdisk.</li>
  <li><code>recovery.img</code>: Kernel and ramdisk to boot into recover mode. Created in the same way as <code>boot.img</code> with same-ish contents.</li>
  <li><code>system.img</code>: File system image for /system, which contains the OS binaries and frameworks. Mounted read only. Contains all the Android and vendor specific binaries, config files and more.</li>
  <li><code>userdata.img</code>: The file system image for /data, which contains user data and configuration files. This is where user's personal data resides.</li>
  <li><code>cache.img</code>: The file system image for /cache, used for updates and recovery.</li>
</ul>

</div> <!-- END: H2 Android Build Tree -->

<h2>Linux Kernel Input And Android Input Components</h2>
<div>
  <h3>Useful Links &amp; Reference</h3>
  <p>
    <ul>
      <li><a href="https://source.android.com/devices/input/overview" target="_blank">Android Docs: Input Overview</a>
      </li>
    </ul>
  </p>
  <h3>A 30,000 Foot View</h3>
  <p>
    The route that a device input takes is shown in a very high-level sense below.
  </p>
  <p>
    <img src="##IMG_DIR##/android_nix_event_framework.png" alt=""/>
  </p>
  <p>
    The Android docs summarise this process quite well. I'm interested in touch devices and
    the so the section &quot;<a href = "https://source.android.com/devices/input/touch-devices#touch-device-operation" target="_blank">Touch Device Oeration</a>&quot; was very useful. It basically says that events go from the <code>EventHub</code> to <code>InputReader</code> to <code>InputDispatcher</code>.
    The dispatcher then <q>... uses the <code>WindowManagerPolicy</code> to determine whether the events should be dispatched and whether they should wake the device. Then, the <code>InputDispatcher</code> delivers the events to the appropriate applications ...</q>.
  </p>

  <h3>Linux Events</h3>
  <p>
      See also
      <a href="http://www.linuxjournal.com/article/6396" target="_blank">Using the Input Subsystem, Part I</a> and
       <a href="http://www.linuxjournal.com/node/6429/print" target="_blank">Using the Input Subsystem, Part II by Brad Hards</a>.
  </p>
  <p>
     In the Linux Kernel, device drivers register with the linux input core as input devices
     and advertise the type of input that they provide. The driver will then translate events
     into types recognised by the input core, which are then published through the evdev device,
     which is axccessible from user space.
  </p>
  <p>
    As the Android docs say, <q>The [Linux] input device drivers are responsible for translating device-specific
    signals into a standard input event format, by way of the Linux input protocol</q>.
  </p>
  <p>
    <img src="##IMG_DIR##/linux_input_event.png" alt="Linux input_event structure UML diagram"/>
  </p>

  <h3>Getting Information From Pseudo File Systems</h3>
  <p>
    We will see that the Linux device drivers will send events up into userspace, to be collected
    by the Android EventHub via <code>/dev/input/eventX</code>, where X is a number representing
    the event associated with the specific device.
  </p>
  <p>
    We can get more information about this device from various locations.
  </p>
  <p>
    We can list all of the devices in our system, and find their pseudo file locations by
    using the <code>/proc/bus/input/devices</code> pseudo file, for example:
  </p>
  <pre class="prettyprint linenums"># cat /proc/bus/input/devices
...
I: Bus=0018 Vendor=0000 Product=0000 Version=0000
N: Name="atmel-maxtouch"
P: Phys=
S: Sysfs=/devices/soc/75ba000.i2c/i2c-12/12-004a/input/input4
U: Uniq=
H: Handlers=mdss_fb event4 kgsl cpufreq
B: PROP=2
B: EV=b
B: KEY=400 0 0 40008800 4000000000 0
B: ABS=661800000000000
...</pre>
  <p>
    Here, for example, we have found out about our touch controller. This phone is using the
    Atmel MaxTouch chipset. We now know where this devce is located in the sysfs pseudo file system,
    namely <code><b>/sys</b>/devices/soc/75ba000.i2c/i2c-12/12-004a/input/input4</code> (note how
    we prefixed the path with <code>/sys</code>).
  </p>
  <p>
    The important bit is the trailing <code>/inputX</code>, where in this case <code>X</code> is 4.
  </p>
  <p>
    We now know that this devices events should be transmitted from Linux kernel space to user space
    via the special file <code>/dev/input/event4</code>.
  </p>
  <p>
    The reported Sysfs location can also be found using the far more friendly
    symbolic link <code>/sys/class/input/event4</code>, which &quot;points&quot; to
    <code>/sys/devices/soc/75ba000.i2c/i2c-12/12-004a/input/input4</code> in this case.
  </p>

  <h3>Event Hub</h3>
  <p></p>
  <blockquote>
    <p>
    ... the Android EventHub component reads input events from the kernel by opening the evdev driver associated with each input device ...
    </p>
    <footer>-- <a href="https://source.android.com/devices/input/overview" target="_blank">Android Docs: Input Overview</a></footer>
  </blockquote>
  <p>
    In the Android code in the Linux user space the first file to query <code>/dev/input/eventXXX</code> is
    the Android Event Hub, which is found in <code>frameworks/base/services/ionput/EventHub.cpp</code>.
    The event hub is compiled using the NDK because it is native C++ code. Compared to the
    <code>InputReader</code> it is relatively &quot;simple&quot; and most sets up an <code>epoll</code>
    and <code>inotify</code> set to monitor the directory <code>/dev/input</code> to detect additions
    and deletions from this directory, and also poll all the files within to receive input events
    from the various kernel drivers.
  </p>
  <p>
  	Most of the important work in the event hub happens in the function <code>EventHub::getEvents()</code>.
  	This provides a &quot;container&quot; or &quot;manager&quot;, which monitors all the devices, their addition and deletion and
  	polls for events from them. It stashes all of these events in interal linked lists, as <code>RawEvent</code>
  	objects, which can then be
  	emptied into the buffer passed to <code>getEvents()</code>, which is how the <code>InputReader</code>
  	harvests all the input events from all devices in the system.
  </p>
  <p>
  	The Android <code>RawEvent</code> objects map to the Linux <code>input_event</code> structure as follows:
  </p>
  <pre>RawEvent.type  = input_event.type;
RawEvent.code  = input_event.code;
RawEvent.value = input_event.value;</pre>
  <p>
    Other fields that do not correspond to the <code>input_event</code> structure fields are:
  </p>
  <pre>deviceId // The device ID
when     // An event time stamp</pre>
  <p>
    In earlier versions of Android there where also fields for <code>scanCode</code> and <code>flags</code>
    but these have been removed. <code>RawEvent</code> is now, as of Nougat:
  </p>
  <p>
    <img src="##IMG_DIR##/android_raw_event.png" alt="Class diagram of Android RawEvent structure"/>
  </p>
  <p style="clear: all;">
  	There are 3 special raw event types: <code>DEVICE_ADDED</code>, <code>DEVICE_REMOVED</code>
  	and <code>FINISHED_DEVICE_SCAN</code>. As the RawEvent type is assigned the
    Linux event type, these special types are given values higher than the existing Linux event
    types. Values below <code>EventHubInterface::FIRST_SYNTHETIC_EVENT</code> are the Linux event
    types and everything else is an Android specific event type (see <code>InputReader::processEventsLocked()</code>).
  </p>
  <p>
    To keep track of all the devices in the system the event hub maintains three lists as private
    data members: opening-devices, closing-devices and knwon-devices:
  </p>
  <p>
    <img src="##IMG_DIR##/android_event_hub_device_lists.png" alt="Diagram of Android Event Hubs device lists"/>
  </p>
  <p>
    Every time <code>getEvents()</code> is called, as many as possible of the devices in the closing-devices
    list are copied into the caller's buffer as raw events and the device deleted from the event hub's closing-devices list.
    The same applies to the opening-devices list.
  </p>
  <p>
    Next the pending events are examined. The events are held in a list (filled in later in the loop) and dequeued one by one until
    they are all processed or there is no more space in the caller's buffer.
  </p>
  <p>
    Each event is either a notification that a device has become newly available for read, has been
    unexpectedly closed or that a &quot;standard&quot; event has occurred.
  </p>
  <p>
    For standard events, each device, as represented in the event hub's <code>Device</code> structure (keyed vector) is located
    via its <code>deviceId</code>.
  </p>
  <p>
    In <code>getEvents()</code> the <code>deviceId</code> is initialised from <code>eventItem.data.u32</code>, when read into the event list,
    which was set by the event hub <code>epoll_ctl()</code> command when the device was opened
    (see <code>openDeviceLocked()</code>). The <code>deviceId</code> is just a number that is
    incremented each time a new device is opened.
  </p>
  <p>
    Once the device is found, as many as possible of the Linux <code>input_event</code>s are read from the device and
    each is processed and copied (via conversion from an <code>input_event</code> to a <code>RawEvent</code>)
    into the next available space in the caller's input buffer. There is some stuff about overriding the
    event's timestamp but I've skipped that detail.
  </p>
  <p>
    If the device was found but for whatever reason it is no longer available, this is dealt with. This
    is how the closing-devices list is populated.
  </p>
  <p>
    Once all events have been processed, if there were any newly available devices detected, these
    are dealt with. This is how the opening-devices list is populated (see
    <code>openDeviceLocked()</code> via <code>readNotifyLocked</code>).
  </p>
  <p>
    Otherwise, if the caller's buffer is full, or a device was deleted or added, control is returned, otherwise the function may
    block waiting for further events. As many events as possible are read into a list which is then, as descibed already, processed on the
    next loop iteration.
  </p>
  <p style="float: left;">
    <img src="##IMG_DIR##/android_readNotifyLocked.png" alt="Flow diagram of Android EventHub readNotifyLocked function" style="float: left;"/>
    <img src="##IMG_DIR##/android_openDeviceLocked.png" alt="Flow diagram of Android EventHub  openDeviceLocked function" style="float: left;"/>
  </p>
  <p style="clear: both;"></p>

  <h3  style="clear: both;">Input Reader</h3>
  <p>
  	So onto the next component, the <code>InputReader</code>... this is a more complicated class than
  	the event hub - its almost 6 times larger in terms of LoC! (And the EventHub was complicated enough :-S).
    It is here that things like multi-touch events received from the Linux drivers are converted into
    MotionEvents etc.
  </p>
  <blockquote>
    <p>
    ... The Android InputReader component then decodes the input events according to the device class and produces a stream of Android input events. As part of this process, the Linux input protocol event codes are translated into Android event codes according to the input device configuration, keyboard layout files, and various mapping tables ...
    </p>
    <footer>-- <a href="https://source.android.com/devices/input/overview" target="_blank">Android Docs: Input Overview</a></footer>
  </blockquote>
  <p>
    The class comments tell us that the <q>... input reader reads raw event data from the event hub
    and processes it into input events that it sends to the input listener ... Most of the work it
    does happens on the input reader thread but the InputReader can receive queries from other system
    components running on arbitrary threads ...</q>.
  </p>
  <p>
  	The input reader (also native in C++) starts a thread which continually polls <code>EventHub::getEvents()</code>, which
  	incidently, will block if there are no events available. The thread works by calling <code>loopOnce()</code>.
  </p>
  <p>
  	The loop function is where <code>EventHub::getEvents()</code> is called. It passes in a private buffer which
  	is filled with as many events (<code>RawEvent</code> objects) from the event hub as possible.
  </p>
  <p>
  	Structure:
  </p>
  <p>
    <img src="##IMG_DIR##/android_input_mappers.png" alt="Class inheritance diagram of InputMapper classes"/>
  </p>
  <p>
    One function of the reader is to aggregate the fine-grained events comming up from Linux. As
    we saw in the &quot;<a href="#UsingADBSendEventGetEvent">Using ADB sendevent &amp; getevent</a>&quot; section, just one touch on the
    mobile devices screen will generate multiple events:
  </p>
  <pre>EV_ABS       ABS_MT_TRACKING_ID   00000015
EV_ABS       ABS_MT_POSITION_X    0000055c
EV_ABS       ABS_MT_POSITION_Y    000001e9
EV_ABS       ABS_MT_PRESSURE      00000049
EV_ABS       ABS_MT_TOUCH_MAJOR   00000008
EV_KEY       BTN_TOUCH            DOWN
EV_SYN       SYN_REPORT           00000000</pre>
  <p>
    One thing that the InputReader will do is to &quot;accumulate&quot; these events into one event
    that is then sent on to its listener(s).
  </p>

  <h3>Input Dispatcher</h3>
  <p></p>
    <blockquote>
    <p>
    ... Finally, the InputReader sends input events to the InputDispatcher which forwards them to the appropriate window ...
    </p>
    <footer>-- <a href="https://source.android.com/devices/input/overview" target="_blank">Android Docs: Input Overview</a></footer>
  </blockquote>
  <p>
    So, the dispatcher is the guy who sends the events of into the Android input ecosystem. However, the
    above quote doesn't meantion that there is a <b>policy manager which has first dibs on the events</b> and can
    instruct the dispatcher as to whether an event should in fact be forwarded. For example, the policy
    manager may well intercept power button presses.
  </p>
</div>

<h2>LocalSocket &amp; LocalServerSocket</h2>
<div>
  <pre>Files of interest:
  - frameworks/base/core/java/android/net/LocalServerSocket.java
  - frameworks/base/core/java/android/net/LocalSocket.java
  - frameworks/base/core/java/android/net/LocalSocketAddress.java
  - frameworks/base/core/java/android/net/LocalSocketImpl.java
  - frameworks/base/core/jni/android_net_LocalSocketImpl.cpp
  - libcore/luni/src/main/java/libcore/io/Libcore.java
  - libcore/luni/src/main/java/libcore/io/BlockGuardOs.java
  - system/core/libcutils/socket_local_server.c
  - system/core/libcutils/socket_local_client.c

Both the LocalSocket and LocalServerSocket classes use the LocalSocketImpl to do
their socket operatations.

The LocalSocketImpl class is mostly a wrapper for the JNI cpp module that does the actual linux
API calls. It creates the Input and Output socket stream classes (with some thread saftey gaurantees)
and provides the object methods.

The LocalServerSocket constructor
  - Creates the local socket as a stream socket (done through impl.create)
      - Results in call from impl to Libcore.os.socket(OsConstants.AF_UNIX, osType, 0); This function
        ends up calling os.socket(). What is does is to &quot;tag&quot; the socket created by
        os.socket(). Haven't looked into what this actually means, but the base is a call to
        Java os.socket().
  - Creates a new LocalSocketAddress with the given name
      - This is a thin class that mostly just holds the name as a string
  - Binds the socket to the name (done through impl.bind)
     -  impl.bind() doesn't do much more than call bindLocal() which is a JNI function defined in
        android_net_LocalSocketImpl.cpp (as socket_bind_local()). socket_bind_local() is just
        the JNI code to get the utf8 string from java world into CPP world which is then passed
        to socket_local_server_bind() in socket_local_server.c.
          - This in turn creates the socket using the Linux socket API to create a UNIX domain
            socket (AF_LOCAL) using the abstract name space, which decouples the socket from the
            filesystem. It does this by calling socket_make_sockaddr_un() in socket_local_client.c
            (humph!).
  - Listens on that socket (done through impl.listen)
  </pre>
</div>

<h2>Security</h2>
<div>
  <h3>References</h3>
  <ul>
    <li><a href="https://source.android.com/security/selinux/concepts" target="_blank">SELinux concepts</a>, Android docs.
    </li>
  </ul>

  <h3>Intro</h3>
  <p>
    See the <a href="linux_security.html#SELinux">linux section</a> for more details on SELinux.
  </p>
  <p>
    If you have root access to your phone you can disable SELinux enforcement using the <code>setenforce</code> command.
  </p>
</div>

<h2>Kernel Panics</h2>
<div>
<pre>cat /proc/last_kmsg          # device must have CONFIG_ANDROID_RAM enabled in /proc. (newer than deprecated apanic)
cat /proc/last_mcrash             # ???

# The tombstone is simply a file with extra data about the crashed process
cat /data/tombstones/tombstone_01 # replace 01 appropriately.

# enable CONFIG_APANIC and set CONFIG_APANIC_PLABE (oldskool Android)
ls /data/dontpanic                # some devices copy contents of several /proc files here.
/proc/apanic_console              # saved to dontpanic.
/proc/apanic_threads              # saved to dontpanic.

https://stackoverflow.com/questions/18118807/linux-apanic-mechanism-and-difference-from-newer-ram-console-persistent-ram-mech
http://elinux.org/Android_Kernel_Features#RAM_CONSOLE

https://source.android.com/devices/tech/debug/</pre>
</div> <!-- END H2: Kernel Panics -->

<h2>Firmware</h2>
<div>
<p>
  Firmware files will be found in <code>/etc/firmware</code>. When a driver does
  a <code>request_firmware()</code> call, the OS will look there for the
  filename supplied.
</p>
<p>
  To really see where your system is looking, have a look at <code>system/core/init/devices.c</code>.
  In Marshmallow the following snippet is useful:
</p>
<pre>static const char *firmware_dirs[] = { "/etc/firmware",
                                       "/vendor/firmware",
                                       "/firmware/image" };</pre>
<p>
  So, in actual fact it appears that Android looks in several places... yay.
</p>
<p>
  See the <a href="linux_kernel.html#How-Drivers-Request-Firmware">Linux notes</a>
  for further information on how drivers request firmware files from userspace.
</p>
<p>
</p>
</div>

</div> <!-- END PADDING DIV -->
</body>
</html>
 
 
 
 
 
 

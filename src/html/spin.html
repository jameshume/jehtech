<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>SPIN &amp; Promela | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
	<!-- MATHJAX -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>


<div id="content">
<h1 class="title">SPIN &amp; Promela</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References</h2>
<div>
	<ul>
		<li><a href="https://spinroot.com/spin/Doc/Book_extras/" target="_blank">The SPIN Model Checker: Primer And Reference Manual</a>, G. Holzmann.
		</li>
		<li><a href="http://www.cs.tau.ac.il/~annaz/teaching/TAU_winter08/Seminar/daniel.pdf" target="_blank">Temporal Logics I: Theory</a>, 
				Daniel Shahaf, Tel-Aviv University, November 2007
		</li>
		<li>Lecture 25, Linear Temporal Logic, Models of Software Systems, Fall 1999, Carnegie Mellon University</li>
		<li>https://www.cs.utexas.edu/~mooney/cs343/slide-handouts/fopc.4.pdf</li>
		<li>http://www.cs.tau.ac.il/~annaz/teaching/TAU_winter08/Seminar/daniel.pdf</li>
		<li>http://www.cis.upenn.edu/~fisman/documents/EF_HBMC14.pdf</li>
	</ul>
</div>

<h2>To Read</h2>
<pre>
https://www.research.ibm.com/haifa/conferences/hvc2010/present/Testing_and_Debugging_Concurrent_Software.pdf
</pre>
<p></p>

<h2>Promela Notes</h2>
<div>
	<h3>Symbolic Names &amp; Variables</h3>
	<p>
		Almost equivalent of a C <code>enum</code>. Use the <code>mtype</code> declaration to
		introduce symbolic names for constant values.
	</p>
	<pre class="prettyprint linenums">mtype = {SYM_NAME 1, SYM_NAME_2, ... };
mtype my_variable = SUM_NAME_1 // Default would be zero</pre>
	<p>
		The symbol names have unique positive integer Ids.
	</p>
	<p>
		The word <code>mtype</code> is short for &quot;message type&quot; and although
		usually defining values for types of messages between promela-processes can be used
		otherwise.
	</p>
	<p>
		In later versions of spin, subtypes of the form <code>mtype:&lt;sub-type-name&gt; = { ... }</code>
		can also be used.
	</p>

	<h3>Promela Processes</h3>
	<p>
		The keyword <code>proctype</code> declares a promela-process. May be preceeded with the keyword
		<code>active</code> to start an	instance of the promela-process automatically.
	</p>
	<p>
		Note use of &quot;promela-process&quot; v.s. &quot;process&quot;.
	</p>
	<p>
		Example:
	</p>
	<pre class="prettyprint linenums">active [n] proctype some_name()
{
   printf("Do something\n")
}</pre>
	<p>
		The above starts <code>n</code> promela-processes of type <code>some_name</code>. The
		<code>[n]</code> can be ommitted, and is so it is like writing <code>[1]</code>.
	</p>
	<p>
		When more than 1 promela-process could continue to run, the choice of which gets to run
		is randomly made. This means <em>no assumptions</em> are made about scheduling.
	</p>
	<p>
		Processes can be run manually from the <code>init</code> block, although this is less
		favourable as it creates another process (the <code>init</code> process), which could bloat
		a verification state space unecessarily.
	</p>
	<pre class="prettyprint linenums">proctype some_name(int a)
{
   printf("Do something %d\n", a)
}

init {
   run some_name(1);
   run some_name(2);
}</pre>
	<p>
		We can constrain a process using the <code>provided</code> keyword. A promela-process
		cannot take <em>any</em> step unless the <code>provided</code> class is <code>true</code>.
	</p>
	<pre class="prettyprint linenums">active [n] proctype some_name() <b><u>provided (some-boolean-expression)</u></b>
{
   printf("Do something\n");     // This line won't execute until `some-boolean-expression` is true
   printf("Do something else\n") // Neither will this line. 
                                 // Its like each line is guarded by `some-boolean-expression`
}</pre>
	<p></p>

	<h3>Scope</h3>
	<p>
		The only scopes are <em>global</em> and <em>process-local</em>. Thus variables cannot be
		scoped to, for example, an <code>if</code> statement. Variables cannot be used until they
		are declared - there is no JavaScript style hoisting.
	</p>
	<p>
		In the global scope all promela-processes can see the variable. In the process-local scope 
		only the process can see the variable.
	</p>

	<h3>Data Types</h3>
	<p></p>
	<table>
		<tr><td>bit</td>     <td>0, 1</td></tr>
		<tr><td>bool</td>    <td>false, true</td></tr>
		<tr><td>byte</td>    <td>0...255</td></tr>
		<tr><td>chan</td>    <td>1...255</td></tr>
		<tr><td>mtype</td>   <td>1...255</td></tr>
		<tr><td>pid</td>     <td>0...255</td></tr>
		<tr><td>short</td>   <td>-2<sup>15</sup>...2<sup>15</sup>-1</td></tr>
		<tr><td>int</td>     <td>-2<sup>31</sup>...2<sup>31</sup>-1</td></tr>
		<tr><td>unsigned</td><td>0...2<sup>n</sup>-1</td></tr>
	</table>
	<p></p>

	<h3>Data Structures</h3>
	<p>Thing C-style structures</p>
	<pre class="prettyprint linenums">typedef MyType {
   short myShort = 3;
   byte  myByte;
   unsigned myUnsigned : 5 /*&lt; 5 bit unsigned integer */
};

proctype myProc(MyType t) {
   t.myShort = 3;
}</pre>
	<p></p>

	<h3>Flow Control &amp; Execution</h3>
	<h4>Execution</h4>
	<p>
		All conditional statements guard execution, and <em>can block</em>, whether or not they have
		any instructions to execute after the guard or not.
	</p>
	<pre class="prettyprint linenums">...
(x == y) ->
...</pre>
	<p>
		In the above snippet  the promela-process executing the code will <em>block</em> at the line
		<code>(x == y) -></code> until the condition is true. As there are no statements after the
		arrow, it will just block and when the condition becomes true continue onto the next line.
	</p>
	<p>
		In promela <em>every type of statement can act as a guard in any context, even when used
		standalone</em>. But note, it <em>should <u>not</u> have side effects</em>! Only <code>run(...)</code>
		is allowed to have a side effect.
	</p>
	<p>
		Things like prints or assignments are <em>immediately executable</em>.
	</p>
	<p>
		Expressions which evaluate to <em>false guaranteeably have no side effects</em>.
	</p>

	<h4>Do Loop</h4>
	<p>
		A <code>do</code> loop looks like the following. It consists of a set of guard conditions.
		The guard conditions are evaluated on each iteration.
	</p>
	<p>
		If a guard evaluates to <em>true</em> then it is said to be <em>executable</em>.
	</p>
	<p>
		If no guard is executable the promela-process <em>blocks</em> until one is. Otherwise one
		branch out of the set of all executable branches is chosen at <em>random</em>.
	</p>
	<pre class="prettyprint linenums">do
:: boolean-guard-1 -> printf("Execute choice 1");  // What follows the guard is the
                      printf("do something 1")     // &quot;execution sequence &quot;
:: boolean-guard-2 -> printf("Execute choice 2");
                      printf("do something 2")     // Note last statement in sequence
                                                   // has no trailing semi-colon. The semi-
                                                   // colon is a seperator, not a terminator.
...
:: boolean-guard-n -> printf("Execute choice n");
                      printf("do something n")
od</pre>
	<p>
		Exit a loop using the <code>break</code> statement or the <code>goto</code> statement.
	</p>
	<p>
		The arrow is just a nice syntactic sugar for the guard. It is equivalent to a semi-colon.
		We could write it like this:
	</p>
	<pre class="prettyprint linenums">do
:: boolean-guard-1; printf("Execute choice 1");
                    printf("do something 1")
:: boolean-guard-2; printf("Execute choice 2");
                    printf("do something 2")
...
od</pre>
	<p>
		To avoid blocking if no guard is true you can use the <code>else</code> keyword:
	</p>
<pre class="prettyprint linenums">do
:: boolean-guard-1 -> printf("Execute choice 1")
:: else -> printf("Won't block and does busy waiting")
od</pre>
	<p>
		The keyword <code>else</code> will only evaluate to <code>true</code> if and only if
		all other guards are <code>false</code>. When else is selected it is therefore the
		<em>only</em> executable option.
	</p>

	<h4>Selection / If</h4>
	<p>
		Same execuation rules as for <code>do</code> loop:
	</p>
	<pre class="prettyprint linenums">if
:: boolean-guard-1; printf("Execute choice 1");
                    printf("do something 1")
:: boolean-guard-2; printf("Execute choice 2");
                    printf("do something 2")
...
fi</pre>

	<h3>Atomic Sequences</h3>
	<p>
		All statements in an atomic sequence are executed without interruption by another promela-process.
		It is a type of <em>compund statement</em>.
	</p>
	<p>
		An atomic sequence can have a guard (the first statement), in which case the guard determines 
		whether the sequence runs, and when it does run, it does so atomically.
	</p>
	<p>
		Write a sequence as follows:
	</p>
	<pre class="prettyprint linenums">atomic { boolean-guard-condition -> statment1; statement2; ... }</pre>
	<p>
		Sequences can included flow control and be non-deterministic (control structures with multiple
		true guards can randomly choose a path).
	</p>
	<p>
		<em>Warning</em>: If any statement in the sequence, other than the guard blocks, the atomicity
		is broken at the point of blocking and re-gained when unblocking occurs.
	</p>

	<h3>Deterministic Steps</h3>
	<p>
		Like atomic sequences except <em>no</em> non-determinism (control structures will deterministically
		choose a path when multiple guards are true), no jumps, and may <em>not contain blocking</em>
		statements other than the guard. It is a type of <em>compund statement</em>.
	</p>

	<h3>Macros / Inline Functions</h3>
	<p>
		An <code>inline</code> &quot;function&quot; behaves, in many ways, like a C pre-processor macro does.
		The word &quot;function&quot; is in quotes because it is <em>not a function!</em> It is just some
		nice syntactic sugar that defines a macro.
	</p>
	<pre class="prettyprint linenums"><b><u>inline</u></b> macro_name(param1, ...) {
// Do some stuff
}</pre>
	<p>
		To see the result of preprocessing pass the <code>-I</code> option to SPIN.
	</p>
	<p>
		Not that because this is a pre-processor substition the statements in the inline body
		are not atomic unless you explicitly mark them so.
	</p>

	<h3>Special Variables</h3>
	<h4>_pid</h4>
	<p>
		Read-only, local variable. Evaluates to numeric ID of currently running promela-process.
	</p>
	<p>
		Variables holding numeric IDs should be of type <code>pid</code>. E.g.:
	</p>
	<pre class="prettyprint linenums">pid myvar = _pid;</pre>
	<p></p>
	<h4>timeout</h4>
	<p>
		Read-only boolean variable. Is true when no other statement in the <em>entire</em> system
		is executable. False otherwise.
	</p>
	<h4>Don't Care Dummy Write Variable</h4>
	<p>
		The underscore (<code>_</code>).
	</p>

	<h3>Message Passing</h3>
	<p>
		Promela <em>channels</em> are used to pass messages between asynchronous promela-processes.
		Every channel has its own unique ID.
	</p>
	<h4>Declaring Channels</h4>
	<p>
		Declare channels using the <code>chan</code> keyword:
	</p>
	<pre class="prettyprint linenums">mtype = { some, set, of, symbolic_constants };
...
chan CHAN_NAME = [n] of { mtype, ... } </pre>
	<p>
		Where <code>n</code> is zero or a positive integer declaring how many items the channel
		can hold until it blocks. Thus if <code>n == 0</code>, the channel will immediately block
		a sender until a receiver reads the value being sent (creates a <em>rendez-vous</em>). If
		<code>n == 1</code> the sender can send 1 value to an empty channel without blocking. If the
		channel already has a message in it the sender would block, and so on...
	</p>
	<p>
		The type of message is either a symbolic constant, in which case, for example we could
		declare:
	</p>
	<pre class="prettyprint linenums">chan CHAN_NAME = [1] of {mtype}</pre>
	<p>
		Or the message can be an aggregate (think structure in C):
	</p>
	<pre class="prettyprint linenums">chan CHAN_NAME = [1] of {mtype, int, bit, user-defined, ...}</pre>

	<h4>Sending / Receiving From Channels</h4>
	<p>
		To send a message into a channel:
	</p>
	<pre class="prettyprint linenums">CHAN_NAME<b><u>!</u></b>expr1[, expr2, ...]
CHAN_NAME<b><u>!</u></b>expr1(expr2[, ...]) // equivalent to the above</pre>
	<p>
		The default is that the send is executable only if there is space in the channel otherwise
		it will <em>block</em>.
	</p>
	<p>
		To receive a message of particular type from a channel:
	</p>
	<pre class="prettyprint linenums">CHAN_NAME<b><u>?</u></b>var1[, var2, ...]
CHAN_NAME<b><u>?</u></b>var1(var2[, ...]) // equivalent to the above</pre>
	<p>
		The default is that the receive is executable only if there is a message in the channel otherwise
		it will <em>block</em>.
	</p>
	<p>
		The above will receive messages into the listed variables. If you specify constants instead,
		the statement is only executable if the constants match the message to be read.
	</p>
	<p>
		If we want to use a variable as-if it were a constant to constrain what can be received
		surround the variable with <code>eval(varname)</code>.
	</p>

	<h4>Constrain Channel Usage (Make Verification Quicker)</h4>
	<p>
		Use <code>xr</code>, meaning <em>exclusive read</em>, and <code>xs</code> for <em>exculsive
		send</em> as shown:
	</p>
	<pre class="prettyprint linenums">
chan b = [1] of { ... }
chan c = [1] of { ... }
active proctype proc1() {
   xs b; /* assert proc1 only sends to b */
   xr c; /* assert proc2 only receives from c */
}</pre>
	<p>
		Helps reduce amount of work verification algorithm has to do by providing some hints about
		the channel usage in the model. They are <em>assertions</em> that will be checked during a
		validation.
	</p>

	<h4>Other Channel Operations</h4>
	<p>
		<b>Length</b>: Use <code>len(chanName)</code> to get the number of messages in a channel.
	</p>
	<p>
		<b>Emptiness</b>: Use <code>empty/nempty(chanName)</code> to see if channel is empty/not-empty.
	</p>
	<p>
		<b>Full</b>: Use <code>full/nfull(chanName)</code> to see if channel is full/not-full.
	</p>
	<p>
		<b>Would progress</b>: To find out if a send/receive <em>would</em> be executable you cannot use <code>chan!expr</code> or
		<code>chan?const_or_var</code> as these expressions both have side effects.
	</p>
	<p>
		Instead use <code>chan![expr]</code> or <code>chan?<b>[</b>const_or_var<b>]</b></code>. These only
		examine the precondition for the execution of the statement, but don't actually execute it.
	</p>
	<p>
		<b>Read but don't dequeue</b>: <code>chanName?<b>&lt;</b>var_or_const<b>&gt;</b></code>
	</p>
</div>

<h2>Review Of Propositional Logic</h2>
<div>
	<p>
		A quick recap of propositional logic <a href="https://www.geeksforgeeks.org/mathematical-logic-introduction-propositional-logic-set-2/" target="_blank">[Ref]</a>.
	</p>
	<p>
		A <em>proposition</em> is a statement or sentence that is either True or False. For example,
		&quot;it is raining&quot; is a proposition. It can only ever be True or False and has a
		precise and unambiguous meaning.
	</p>
	<p>
		Propositions are usually represented using <em>propositional variables</em>. Popositional
		logic deals with how individual propositions can be combined to produce more complex logical
		popositions. For example, let $a$ mean &quot;it is raining&quot; and "b" mean &quot;it is flooding&quot;.
		We can then construct logical statements like $a \land b$ to mean &quot;it is raining and flooding&quot; or
		$b \implies a$ meaing &quot;if it is flooding then it is raining&quot;.
	</p>
</div>

<h2>Review Of Predicate Logic</h2>
<div>
	<p>
		Lets do a very quick recap of some First Order Predicate Logic (FOPL) stuff <a href="https://www.cs.utexas.edu/~mooney/cs343/slide-handouts/fopc.4.pdf" target="_blank">[Ref]</a>.
	</p>
	<p>
		A <em>predicate</em> represents a property of, or a relation between terms that is either true or
		false. For example, $\mathrm{isAlive}(james)$ or $\mathrm{greaterThan}(1,2)$, for example.
	</p>
	<p>
		Standard <em>logical operators</em> can <em>connect</em> predicates $\lor, \land, \implies, \iff$.
	</p>
	<p>
		Predicates &quot;extend&quot; or add a greater flexibility to propositional logic. In propositial logic, we would have
		to define 2 propositions $a$ = &quot;James is alive&quot; and $b$ = &quot;John is alive&quot;.
		But in predicate logic we just define the predicate $\mathrm{isAlive}()$ and apply it to our objects
		of interest, i.e., $\mathrm{isAlive}(\mathrm{james})$ and $\mathrm{isAlive}(\mathrm{john})$. Because
		of this extra power, predicate logic can be used to reason about sets of objects. We don't need to
		define a proposition for each member of a set; now we define a predicate applied over a set in a
		more abstract way using quantifiers.
	</p>
	<p>
		<em>Quantifiers</em> allow entire ranges of objects to be reasoned about. For example. $\exists x \in \mathrm{N}: isPrime(x)$.
		The <em>universal quantifier</em> says that something is true for all values of a variable - $\forall x \in \text{set}: \mathrm{predicate}(x)$ asserts that the predicate must be true for every value in a set. The <em>existential quantifier</em> says that a predicate must be true for at least one value.
	</p>
	<p>
		The &quot;scope&quot; of a quantifier is everything that occurs after it (inside any brackets it belongs to). So $\forall x: \mathrm{isPurple}(x) \lor \mathrm{isLemon}(x)$ is equivalent to So $\forall x: [\mathrm{isPurple}(x) \land \mathrm{isLemon}(x)]$, i.e., everything in the entire universe is purple and a lemon. But in this - $(\forall x: \mathrm{isPurple}(x)) \land (\forall x: \mathrm{isLemon}(x))$ - the two $x$ variables are independent of eachother, although logically they express the same thing.
	</p>
	<p>
		When quantifiers nest their &quot;scopes&quot; do too. So something like $\forall x \exists y: \mathrm{isChildOf}(y, x)$ means that every child has a parent. It was eqivalent to writing $\forall x: (\exists y: \mathrm{isChildOf}(y, x))$. Note that when the nested quanitifers are not the same that the order matters: $\exists x \forall y: \mathrm{isChildOf}(y, x)$ means that there exists a child for whom everyone is their parent!
	</p>
	<p>
		Scope can also be used with variables of the same name where the inner hides the outer: $\exists x (\mathrm{pred1}(x)\lor \forall x \mathrm{pred2}(x))$. The $x$ in pred1 is existentially quantified and the $x$ in pred2 is universally quantified.
	</p>
	<p>
		The quantifiers are related as follows:
		$$
		\forall x: ¬P \iff ¬\exists x: P
		$$
		$$
		¬\forall x: P \iff \exists x: ¬P
		$$
		$$
		\forall x: P \iff ¬\exists x: ¬P
		$$
		$$
		\exists x: P \iff ¬\forall x: ¬P
		$$
	</p>
</div>

<h2>Linear Temporal Logic (LTL)</h2>
<div>
	<p>
		First order predicate logic (FOPL, aka just &quot;predicate logic&quot;) can reason about a system state at <em>one moment</em> in time. Using
		it one can talk about things like &quot;James is alive&quot;. In the current moment this is true.
		But what about tomorrow, or indeed eventually? We all die sometime. We cannot express this using
		FOPL. This is where LTL comes in.
	</p>
	<p>
		LTL is used to reason about the <em>change</em> in system states over time. We care about:
	</p>
	<ul>
		<li><em>Saftey</em>: Nothing &quot;bad&quot;will happen. (Never conditions).
		</li>
		<li><em>Liveness</em>: Something &quot;good&quot; will happen.
		</li>
		<li><em>Fairness</em>: Processes can make progress - no starvation.
		</li>
	</ul>
	<p>
		To talk about LTL, we need to do a quick review of automata...
	</p>
	<h3>Automata</h3>
	<p>
		Finite State Automaton is defined by a tuple $(S, s_0, L, T, F)$ where:
		<div style="margin-left:20px;">
			$S$ is a finite set of states<br/>
			$s_0$ is the initiatial state such that $s_0 \in S$<br/>
			$L$ is a finite set of labels<br/>
			$T$ is a set of transitions, $T \subseteq (S \times L \times S)$, and<br/>
			$F$ is a set of final states<br/>
		</div>
	</p>
	<p>
		For example, look at the following automaton:
	</p>
	<p>
		<img src="##IMG_DIR##/dummy_fsa.png" alt="Picture of a finite automaton"/>
	</p>
	<p>
		For this automaton we have:
		<div style="margin-left:20px;">
			$S = \{ s_0, s_1, s_2, s_3 \}$<br/>
			$s_0$ is the initiatial state such that $s_0 \in S$<br/>
			$L = \{ a, b, c, d \}$<br/>
			$T \subseteq (S \times L \times S) = \left\{ \{s_0, a, s_1\}, \{s_0, b, s_2\}, \{s_1, c, s_2\}, \{s_2, d, s_1\}, \right\} $, and<br/>
			$F = \{ s_2 \}$<br/>
		</div>
	</p>

	<h3>Runs Through Finite Automatons</h3>
	<p>
		A <em>run</em> of a FA is a an <em>ordered sequence of transitions</em> - possibly infinite.
		For example, if $R$ is the run, and $T$ is the set of all possible transitions within the autonaton,
		then $R = \{ (s_0, l_0, s_1), (s_1, l_1, s_2), \ldots \} : \forall i,j,k, (i,j,k \ge 0) \implies (s_i, l_j, s_k) \in T)$.
		A concrete, finite, example using the automaton above could be
		$R_\text{concrete} = \{ (s_0, a, s_1), (s_1, c, s_2) \}$. 
	</p>
	<p>
		An <b>accepting run</b> is one where the final state is in the set of end states
		(implicity all the end states are seen as accepting). This applies to the concrete example
		just given. Runs defined in this way are all <em>terminating</em>.
	</p>
	<p>
		But what about infinite loops through states? The same automaton we saw above provides the
		possibility for infinite runs that oscillate between $s_1$ and $s_2$. For example:
		$R_\text{inf ex.} = \{ (s_0, a, s_1), (s_1, c, s_2), (s_2, d, s_1), (s_1, c, s_2), (s_2, d, s_1), \ldots \}$.
	</p>
	<p>
		These may or may not be a good thing. These runs must be <em>infinite</em> and are
		referred to as <b>$\omega$-runs</b>. The set of transitions that occur infinitely often in the run
		are denoted $\sigma^\omega$ and other states $\sigma^+$.
	</p>
	<ul>
		<li>$\sigma^\omega$: transitions occuring infinitely often.</li>
		<li>$\sigma^+$: transitions that occur a finite number of times.</li>
	</ul>
	<p>
		An <b>accepting $\omega$-run</b> is one where $\exists s_f: s_f \in F \land s_f \in \sigma^\omega$ - the <em>Buchi acceptance definition</em>.
		I.e., an accepting $\omega$-run is a loop when at least one state is visited infinitely often.
	</p>
	<p>
		This rule is extended to finite runs using the <em>stutter extension rule</em> which adds an end
		state that can be repeated infinitely often.
	</p>
	<p>
		Call $\sigma$ an instance of an $\omega$-run. If the states in the run are $s_0, s_1, \ldots$,
		then:
	</p>
	<ul>
		<li>$\sigma_i = s_i$</li>
		<li>$\sigma[i] = \{ s_i, s_{i+1}, \ldots \}$ - this is called the suffix from position $i$. The indexing starts
			at 1, so $\sigma \equiv \sigma[1] \equiv \sigma_1\sigma[2]$ and so on.
		</li>
	</ul>

	<h3>Into The LTL</h3>
	<p>
		LTL extends classical logic by adding new operators:
	</p>
	<ul>
		<li>$\square P$: &quot;Always&quot;: Holds is $P$ is true henceforth (in the next position $i+1$) until the end of time.</li>
		<li>$\lozenge P$: &quot;Eventually&quot;: Holds if $P$ holds someday, that is unspecified from today onwards,.</li>
		<li>$\bigcirc$: &quot;Next time&quot;: Holds if $P$ holds at the next moment in time, $i+1$.</li>
		<li>$A \bigcup B$: &quot;Until&quot;:  Holds if $A$ does not become false before $B$ becomes true.<br/>
Two variants:
			<ul>
				<li>Strong until.</li>
				<li>Weak until.</li>
			</ul>
		</li>
	</ul>
	<p>
		When a formula $f$ holds for an $\omega$-run $\sigma$, we write $\sigma \models f$.
	</p>

	<h4>Weak Until</h4>
	<p>
		The weak until operator is expressed by the following:
		$$
		\sigma[i] \models (p \bigcup q) \Leftrightarrow \sigma_i \models q \lor \left(\sigma_i \models p \land \sigma[i+1] \models (p \bigcup q)\right)
		$$
		Which, if you're anything like me, makes you want to curl up in the corner of the room and cry!
	</p>
	<p>
		So, can we break this down any? Well,

		$$
		\sigma[i] \models (p \bigcup q)
		$$

		Remember, $\sigma[i]$ means the states $s_i, s_{i+1}, \ldots$. So this chunk of the formula means
		&quot;p until q holds for all the states in suffix $\sigma$ from position $i$.
	</p>
	<p>
		&quot;$\Leftrightarrow$&quot; means &quot;if an only if&quot;. Then,

		$$
		\sigma_i \models q
		$$

		Means that $q$ holds (i.e., is true) in the state $i$ of the $\omega$-run, $\sigma$.
	</p>
	<p>
		So far it is saying that the statement &quot;p is true until q is true (p until q)&quot; is true for
		the run-suffix, starting at state $i$, if and only if $q$ is true at state $i$ in the run or...
	</p>
	<p>
		Lets have a look at that &quot;or...&quot; bit next.
	</p>
	<p>
		We can deal with the next bit in one chunk: 

		$$
		\left(\sigma_i \models p \land \sigma[i+1] \models (p \bigcup q)\right)
		$$

		This is saying that $p$ is true in state $i$ of the run and p-until-q holds for the suffix
		of the run starting at state $i+$.
	</p>
	<p>
		So, in total we have, &quot;p is true until q is true (p until q)&quot; is true for
		the run-suffix, starting at state $i$, if and only if $q$ is true at state $i$ in the run, or
		$p$ is true at state $i$ <em>and</em> &quot;p is true until q is true (p until q)&quot; holds for the
		next suffix startin at state $i + 1$.
	</p>
	<p>
		This is a recursive definition! Starting at the first state in our run, either $q$ is true
		or $p$ is true recurse... therefore, we never actually know or require that $q$ ever become
		true - we keep putting it off!
	</p>

	<h4>Strong Until</h4>
	<p>
		Unlike week until, where for $p \bigcup q$, $q$ was not required to ever become true (as
		we could keep putting it off), strong-until does require that $q$ come true. It is defined
		as follows:

		$$
		\sigma[i] \models (p \bigcup q) \Leftrightarrow \sigma[i] \models (p \bigcup q) \land \exists j, j \ge i, \sigma_j \models q
		$$
	</p>

	<h4>Always</h4>
	<p>
		Always means that something holds <em>invariantly true</em> throughout a run.

		$$
		\sigma \models \square p \Leftrightarrow \sigma \models \left(p \bigcup \text{false}\right)
		$$

		So, always $p$ means $p$ until $\text{false}$... hmmm. Lets break it down. If we consider weak until,
		we know that $p \bigcup q$ does not require $q$ to ever become true and $p$ would therefore <em>always</em>
		be true if $p \bigcup q$ were to hold. Thats why it is defined this way.
	</p>

	<h4>Eventually</h4>
	<p>
		A property will eventually become true at least once in a run.

		$$
		\sigma \models \lozenge q \Leftrightarrow \sigma \models \left(\text{true} \bigcup q \right)
		$$
	</p>

	<h4>Next</h4>
	<p>
		$$
		\sigma[i] \models Xp \Leftrightarrow \sigma_{i+1} \models p
		$$
	</p>

	<h4>Combinations Of LTL Operators</h4>
	<p>
		<em>Recurrence</em> is expressed as $\square\lozenge p$, i.e., &quot;always eventually $p$ becomes true&quot;.
		This expresses an <em>invariance</em>.
	</p>
	<p>
		<em>Stability</em> is expressed as $\lozenge\square p$,i.e., &quot;eventally always $p$&quot;. This expresses
		a <em>guarantee</em>.
	</p>
	<p>
		A <em>response</em> is shown as $p \implies \lozenge q$. This works because if $p$ occurs, for the expression
		to be true that $q$ must eventually become true.
	</p>
	<p>
		A <em>precidence</em> (a usage, tradition, or standard to be followed in the future) is expressed as
		$p \implies q \bigcup r$. I.e., $p$ implies that $q$ will be true until $r$ becomes true. The property
		$q$ is the precedent that holds until a new precedent $r$ is set.
	</p>
	<p>
		A <em>correlation</em> is decribed as $\lozenge p \implies \lozenge q$.
	</p>
	<p>
		Other commonly used rules include:
	</p>
	<ul>
		<li>$¬\square p \Leftrightarrow \lozenge ¬p$</li>
		<li>$¬\lozenge p \Leftrightarrow \square ¬p$</li>
		<li>$¬(p \bigcup q) \Leftrightarrow (¬q) \bigcup (¬p \land ¬q)$</li>
		<li>$\square(p \land q) \Leftrightarrow \square p \land \square q$</li>
		<li>$\lozenge(p \lor q) \Leftrightarrow \lozenge p \lor \lozenge q$</li>
		<li>$p \bigcup (q \lor r) \Leftrightarrow (p \bigcup q) \lor (p \bigcup r)$</li>
		<li>$(p \land q) \bigcup r \Leftrightarrow (p \bigcup r) \land (q \bigcup r)$</li>
		<li>$p \bigcup (q \lor r) \Leftrightarrow (p \bigcup q) \lor(p \bigcup r)$</li>
		<li>$\square\lozenge (p \lor q) \Leftrightarrow \square\lozenge p \lor \square\lozenge q$</li>
		<li>$\lozenge\square(p \land q) \Leftrightarrow \lozenge\square p \land \lozenge\square q$</li>
	</ul>

	<h3>Going From Non-Temporal To Temporal Logic</h3>
	<p>
		The SPIN book uses the example of $p \implies q$. In the context of LTL, what does this mean
		without any temporal operators? A &quot;true&quot; LTL statement implies means that this must
		hold for every run of the system: $\sigma \models p\implies q$. Without temporal operators
		this just applies for the first state in the run. States beyond that... it says nothing
		about!
	</p>
	<p>
		To &quot;implement&quot; this implication in LTL, a more accurate description could be
		$\square(p \implies X(\lozenge q)) \land \lozenge p$. In other words, $p$ is eventuall true
		and it is always the case that $p$ becoming true means that $q$ will eventually become true
		sometime strictly after.
	</p>

</div>

<h2>SPIN Notes</h2>
<div>
	<h3>Types Of Claims</h3>
	<p>
		SPIN is concerned about what is and isn't possible, not what is good or bad, or probable
		and improbable.
	</p>
	<p>
		To allow SPIN to tell you about what is and isn't possible you need to make claims about
		your model. You can make,
	</p>
	<ol>
		<li>Claims about reachable/unreachable states, and</li>
		<li>Claims about feasible/infeasible executions (i.e., paths forming state transitions).
		    E.g., every time state P is visited, subsequently state Q should eventually be visited.</li>
	</ol>
	<p>
		SPIN <em>automatically</em> checks for deadlocks (unintended end states).
	</p>
	<p>
		A <b>system invariant</b> should be true for every reachable state in the system. A
		<b>process invariant</b> is true only for every state reachable in a process.
	</p>

	<h3>Basic Assertions</h3>
	<p>
		Basic assertions use the <code>assert(expr)</code> statement. The <code>expr</code> should
		always evaluate to <code>true</code> (or non-zero <code>int</code>). If it does not SPIN
		considers this an error and fails the model.
	</p>

	<h3>End States</h3>
	<p>
		Only default valid end state is when <em>every</em> promela-process has terminated. Verification
		checks no invalid end states can be reached, which is a <em>saftey</em> issue.
	</p>
	<p>
		To mark alternative states as valid end states use <code>end</code>-state labels. Labels must
		be unique to their <code>proctype</code>. Every label that starts with the prefix <code>end</code>
		marks a valid end state.
	</p>
	<p>
		To make sure all promela-processes are in a valid end state at the end of verification
		<em>and additionally</em> that all message queues are empty use the <code>-q</code> with
		the compiler verifier.
	</p>

	<h3>Progress (Liveness) States</h3>
	<p>
		Used to specify <em>livenesss</em> properties.
	</p>
	<p>
		Similar syntax to end states but use labels with the prefix <code>progress</code> to mark
		statements that accomplishes something - allows infinite cycles to be seen as &quot;good&quot;
		rather than an error condition that signals that a process is stuck making no progress.
	</p>
	<p>
		See the SPIN command line usage on how to search for no-progress cycles. Enabling NP searching
		disables the search for invalid end states (<em>safety</em>).
	</p>

	<h3>Faireness</h3>
	<p>
		Every process that can execute a statement will eventually do so. I.e., no <em>starvation</em>.
		There are two types of faireness: weak and strong faireness.
	</p>
	<blockquote>
		<p>
			[Weak fairness] states that if a process reaches a point where it has an executable statement, and the executability of that statement never changes, it will eventually proceed by executing the statment...
		</p>
		<p>
			...[Strong faireness] states that if the process reaches a point where it has a statement that becomes executable intinitely often, it will eventually proceeed by executing the statement.
		</p>
		<footer>
			-- The SPIN Model Checker, Primer and Reference Manual, G. J. Holzmann.
		</footer>
	</blockquote>
	<p>
		See the SPIN command line usage on how enforce weak fairness. This adds a computational
		burden to the verification so it will be slower. Strong fairness no supported as too
		computationally expensive.
	</p>

	<h3>Accept States</h3>
	<p>
		Mostly used with a <code>never</code> claim. Used to find execution paths that do pass
		through at least one accept state(s) but not infinitely often - use label prefix <code>accept</code>.
	</p>

	<h3>Never Claims</h3>
	<p>
		Claims that apply to <em>every state</em> in the entire system and <em>all times</em>, i.e.
		at <q><em>every execution step</em> of the system</q>.
	</p>
	<p>
		Ignored in simulation mode. Only used in verification mode. Help capture <em>liveness</em>
		requirments.
	</p>
	<p>
		Example of checking system invariant <code>p</code>, taken from &quot;The SPIN Model Checker, Primer and Reference Manual&quot; by G. J. Holzmann.
	</p>
	<pre class="prettyprint linenums">never {
   do
   :: !p -> break /* } Replace both lines with assert(p) */
   :: else        /* } for equivalent behaviour          */
   od
}</pre>
	<p>
		If the invariant is ever broken, i.e. <code>!p</code>, the <code>never</code> claim exits,
		which signals to SPIN that a violation has occured. Expressions in the claim must be
		<em>side effect free</em>!
	</p>
	<p>
		<em>Note the use of <code>else</code></em>. As the claim is to be checked at each statement
		execution the loop must not block, although it is permissible for <code>never</code> claims
		to block.
	</p>
	<p>
		A more comples example from &quot;The SPIN Model Checker&quot; book (annotation mine):
	</p>
	<pre class="prettyprint linenums"><b>/* CHECK that every state in which p is true eventually leads to a state
 * in which q is true, and in the interim, p remains true.
 *
 * SPIN checks for VIOLATIONS of this property only (i.e., does not check
 * satisfaction).*/</b>
<b>never</b> {
S0:    do
       :: p && !q -> break   /* p is true AND q is false -> expect q to become true */
       :: true               /* Always executable, which is how we get the...       */
       od                    /* ...&quot;eventually leads to a true &quot; because even...   */
                             /* ...when (p &&!q) is true, this branch could...      */
                             /* ...execute instead. Also allows for p to go false   */
                             /* ... and then true again before we hit our condition.*/
S1:
accept:                      /* Remaining in this loop is a valid end state         */
/* The loop blocks when p and q true in this accept state and the claim STOPS...    */
/* ...tracking system execution - we don't have to create another infinite accept...*/
/* ...state */
       do
       :: !q                 /* p is any AND q is false **forever**. Must mark as...*/
                             /* ... valid end state, otherwise q never becoming...  */
                             /* ... true would be an error!                         */
       :: !(p || q) -> break /* p is false AND q is false -> true p did not reach...*/
                             /* ...a true q!                                        */
       od
/* The loop will exit (and cause a claim violation) if !p && !q */
<b>}</b></pre>
	<p>
		To generate a never claim you can use the spin command line: <code>spin -f 'ltl-formula'</code>.
		You can make life a little easiler for yourself by combining complex expressions into <code>#define</code>'d
		symbols. For example, in one simulation I wanted to chech that the following would <em>always</em> be
		true: <code>!(lock_grant[0] && lock_grant[1]) && !(bus_connect[0] && bus_connect[1]) && (!bus_connect[0] || lock_grant[0]) && (!bus_connect[1] || lock_grant[1]) && (num_connected < 2)</code>. I also wanted to make sure that the following
		would be <em>eventually</em> true: <code>(lock_grant[0] && bus_connect[0])</code> and
		seperately, <code>(lock_grant[1] && bus_connect[1])</code>.
	</p>
	<p>
		All of this would be a bit of a mouthful to have to type into the command line. So, instead, 
		in the model:
	</p>
	<pre class="prettyprint linenums">#define always_c (!(lock_grant[0] && lock_grant[1]) && !(bus_connect[0] && bus_connect[1]) && (!bus_connect[0] || lock_grant[0]) && (!bus_connect[1] || lock_grant[1]) && (num_connected < 2))
#define eventual_co1 (lock_grant[0] && bus_connect[0])
#define eventual_co2 (lock_grant[1] && bus_connect[1])</pre>
	<p>
		Then, generating the never claim was done like so: <code>spin -f '([]always_c) &amp;&amp; (&lt;&gt;eventual_co1) &amp;&amp; (&lt;&gt;eventual_co2) */
T'</code>. Much easier :)
	</p>
	<p>
		It is also possible to use the <a href="http://spinroot.com/spin/Man/ltl.html" target="_blank">ltl section</a> directly
		in your models:
	</p>
	<pre class="prettyprint linenums">ltl my_model_condition_1 {
    ([]always_c) &amp;&amp; (&lt;&gt;eventual_co1) &amp;&amp; (&lt;&gt;eventual_co2)
}</pre>
	<p></p>

	<h3>Trace Assertions</h3>
	<p>
		Used for <em>message channels</em>. All referenced channels must be <em>global</em> and
		all choices must be <em>deterministic</em>.
	</p>
	<p>
		An example from the SPIN book:
	</p>
	<pre class="prettyprint linenums">trace {
   do
   :: q1!a; q2:b /* Says all ops on queue q1 must be send a, receive b, repeat */
   od
}</pre>
	<p>
		A trace assertion can only use <em>simple</em> queue operations. Values matched must
		be constants or <code>mtype</code> or the special variable <code>_</code>, which means
		&quot;don't care &quot;.
	</p>
	<p>
		Use <code>notrace</code> blocks to achieve the exact opposite.
	</p>

</div>

<h2>SPIN Command Line</h2>
<div>
	<h3>Limit Simulation Steps</h3>
	<p>The following limits the simulation exection to n steps:</p>
	<pre class="prettyprint linenums">spin <b><u>-u&lt;n&gt;</u></b> file.pml</pre>
	<p>For example, to limit it to 50 steps we would write:</p>
	<pre class="prettyprint linenums">spin <b><u>-u50</u></b> file.pml</pre>

	<h3>Columnated Output</h3>
	<p>To just get the <code>prinf</code> output, one column per process:</p>
	<pre class="prettyprint linenums">spin <b><u>-c</u></b> file.pml</pre>

	<h3>Generate Verification model</h3>
	<pre>spin <b><u>-a</u></b> filename.pml
cc -o pan pan.c
./pan</pre>
	<p>
		If there are any errors a <em>trail</em> file will be output named
		<code>filename.pml.trail</code>.
	</p>
	<p>
		The shorthand for the above is to run the following.
	</p>
	<pre>spin -run filename.pml</pre>

	<h3>Find Shortest Execution Trace</h3>
	<p>
		If a tail fails in <code>&lt;n&gt;</code> steps, to find the shortest
		possible path to failure less than or equal to n steps:
	</p>
	<pre>spin <b><u>-a</u></b> file.pml
cc <b><u>-DREACH</u></b> -o pan pan.c
./pan <b><u>-i -m&lt;n&gt;</u></b></pre>
	<p>
		Alternatively compile to use breadth first search:
	</p>
	<pre>cc <b><u>-DBFS</u></b> -o pan pan.c
./pan</pre>
	<p>
		A shortcut for this should be the following.
	</p>
	<pre>spin -run -bfs file.pml</pre>

	<h3>Guided Simulation (Use A Trail File)</h3>
	<p>
		To replay a trail file in a simulation:
	</p>
	<pre class="prettyprint linenums">
spin <b><u>-p -t</u></b> file.pml
           ^  ^
           ^  -t is a trail-hunting option. If the analyzer finds a violation of an 
           ^  assertion, a deadlock or an unspecified reception, it writes an error
           ^  trail into a file named pan.trail. The trail can be inspected in detail
           ^  by invoking Spin with the -t option. In combination with the options pglrs
           ^  different views of the error sequence are then easily obtained.
           ^
           -p Shows the state changes of the Promela processes at every time step.</pre>
	<p>
		Or...
	</p>
	<pre class="prettyprint linenums">spin <b><u>-p -replay</u></b> file.pml</pre>
	<p>
		The pglrs options are:
	</p>
	<table>
		<thead>
			<tr>
				<td>Option</td><td>Description</td>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><code>-p</code></td>
				<td>Shows the state changes of the Promela processes at every time step.</td>
			</tr>
			<tr>
				<td><code>-g</code></td>
				<td>Shows the current value of global variables at every time step.</td>
			</tr>
			<tr>
				<td><code>-l</code></td>
				<td>Shows the current value of local variables, after the process that owns them has changed state. It is best used in combination with option -p.</td>
			</tr>
			<tr>
				<td><code>-r</code></td>
				<td>Shows all message receive events. It shows the process performing the receive, its name and number, the source line number, the message parameter number (there is one line for each parameter), the message type and the message channel number and name.</td>
			</tr>
			<tr>
				<td><code>-s</code></td>
				<td>Shows all message send events.</td>
			</tr>
		</tbody>
	</table>
	<h3>Stricter End States - Message Queues Must Be Empty</h3>
	<p>
		By defailt when verification ends all promela-processes must be in a valid end state but
		the message queues do not have to be empty. To make this stricter and require that message
		queues also be empty use the <code>-q</code> with the compiled verifier.
	</p>

	<h3>Search For No Progress Cycles</h3>
	<pre class="prettyprint linenums">spin -a file.pml     # Compile the verifier
cc -DNP -o pan pan.c # Enable search for no-progress cycles.
./pan -l [-f]        # Search for NP cycles.
#        ^^^^
#        Enforce weak fairness (strong fairness too computationally expensive)</pre>
	<p></p>
</div>

<h2>SPIN In Action</h2>
<div>
	<p>
		Playing with <a target="_blank" href="http://spinroot.com/spin/Man/1_Exercises.html">SPIN verification example exercise 3a</a>:
	</p>
	<div style="float:left;">
		<p>This was my solution to the exercise...</p>
		<pre class="prettyprint linenums:15">bool yield[2];
int lock;
int cr_count = 0;

active [2] proctype mutex_proc()
{
int other_procno = 1 - _pid
C0: yield[_pid] = false
C1: if
    :: lock != _pid -&gt;
C2:        if
           :: !yield[other_procno] -&gt; goto C2
           :: else -&gt; lock = _pid; goto C1
           fi
    :: else -&gt;
CR:        // Enter critical region
           cr_count = cr_count + 1
           // Do some critical stuff
           // Leave CR
           cr_count = cr_count - 1
           yield[_pid] = true
           // Remainder of program (out of CR)
           goto C0
    fi
}

never  {    /* &lt;&gt;(cr_count &gt; 1) */
T0_init:
        do
        :: atomic { ((cr_count &gt; 1)) -&gt;
              assert(!((cr_count &gt; 1))) }
        :: (1) -&gt; goto T0_init
        od;
accept_all:
        skip
}</pre></div>
	<div style="float:left;">
		<p>Following the instructions, one can use a BFS to find the smallest number of steps in which
			the never claim is violated and it can be examined as so:
		</p>
		<pre>~/SPIN$ spin -p -replay ex_3a.pml
starting claim 1
using statement merging
<span style="color: red">^^ yield = {0, 0}, lock = 0, cr_count = 0</span><span style="background: lightgray;">
  1:    proc  1 (mutex_proc:1) ex_3a.pml:22 (state 1)   [yield[_pid] = 0]</span>
<span style="color: red">^^ Proc 1 wants the lock</span><span style="background: lightgray;">
  2:    proc  1 (mutex_proc:1) ex_3a.pml:24 (state 2)   [((lock!=_pid))]</span>
<span style="color: red">^^ Proc 1 examines the lock variable. It does not have the lock!</span>
  3:    proc  0 (mutex_proc:1) ex_3a.pml:22 (state 1)   [yield[_pid] = 0]
<span style="color: red">^^ Proc 0 wants the lock</span>
  4:    proc  0 (mutex_proc:1) ex_3a.pml:29 (state 10)  [else]
<span style="color: red">^^ Proc 0 has the lock</span>
  5:    proc  0 (mutex_proc:1) ex_3a.pml:31 (state 11)  [cr_count = (cr_count+1)]
<span style="color: red">^^ yield = {0, 0}, lock = 0, cr_count = 1</span>
  6:    proc  0 (mutex_proc:1) ex_3a.pml:34 (state 12)  [cr_count = (cr_count-1)]
<span style="color: red">^^ yield = {0, 0}, lock = 0, cr_count = 0</span>
  7:    proc  0 (mutex_proc:1) ex_3a.pml:35 (state 13)  [yield[_pid] = 1]
<span style="color: red">^^ yield = {1, 0}, lock = 0, cr_count = 0. Proc 0 releases lock</span><span style="background: lightgray;">
  8:    proc  1 (mutex_proc:1) ex_3a.pml:27 (state 5)   [else]</span>
<span style="color: red">^^ Proc 1 can take the lock as proc 0 has yielded</span>
  9:    proc  0 (mutex_proc:1) ex_3a.pml:22 (state 1)   [yield[_pid] = 0]
<span style="color: red">^^ Proc 0 wants the lock. yield = {0, 0}, lock = 0, cr_count = 0</span>
 10:    proc  0 (mutex_proc:1) ex_3a.pml:29 (state 10)  [else]
<span style="color: red">^^ ERROR! Proc 0 thinks it has the lock!</span><span style="background: lightgray;">
 11:    proc  1 (mutex_proc:1) ex_3a.pml:27 (state 6)   [lock = _pid]</span>
<span style="color: red">^^ ERROR! Proc 1 thought it was clear to take the lock
          Proc 1 takes the lock: yield = {0, 0}, lock = 1, cr_count = 0</span><span style="background: lightgray;">
 12:    proc  1 (mutex_proc:1) ex_3a.pml:29 (state 10)  [else]
 13:    proc  1 (mutex_proc:1) ex_3a.pml:31 (state 11)  [cr_count = (cr_count+1)]</span>
 14:    proc  0 (mutex_proc:1) ex_3a.pml:31 (state 11)  [cr_count = (cr_count+1)]
<span style="color: red">^^ ERROR! Both proc 0 and 1 are in the CR!</span>
spin: trail ends after 14 steps
#processes: 2
                yield[0] = 0
                yield[1] = 0
                lock = 1
                cr_count = 2
<span style="color: red">                ^^ ERROR! The never claim is violated</span>
 14:    proc  1 (mutex_proc:1) ex_3a.pml:34 (state 12)
 14:    proc  0 (mutex_proc:1) ex_3a.pml:34 (state 12)
 14:    proc  - (never_0:1) ex_3a.pml:43 (state 6)
2 processes created</pre></div>
<p style="clear:both;">By examining the trace we can see why this algorithm has failed. When the lock
is yielded, it is not set to a value that represented &quot;not-owned&quot;, so proc 0 thought it had the lock,
when in fact, no one had the lock!
</p>
<p>
    The never claim, &quot;$\lozenge(cr_{count} &gt; 1)$&quot; was generated using the command line <code>spin -f &quot;&lt;&gt;(cr_count &gt; 1)&quot;</code>
</p>
</div>


</div> <!-- END H1 padding div -->
</div>
</body>
</html>


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
